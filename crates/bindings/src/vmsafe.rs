/**

Generated by the following Solidity interface...
```solidity
interface VmSafe {
    type AccountAccessKind is uint8;
    type BroadcastTxType is uint8;
    type ForgeContext is uint8;
    struct AccountAccess {
        ChainInfo chainInfo;
        AccountAccessKind kind;
        address account;
        address accessor;
        bool initialized;
        uint256 oldBalance;
        uint256 newBalance;
        bytes deployedCode;
        uint256 value;
        bytes data;
        bool reverted;
        StorageAccess[] storageAccesses;
        uint64 depth;
    }
    struct BroadcastTxSummary {
        bytes32 txHash;
        BroadcastTxType txType;
        address contractAddress;
        uint64 blockNumber;
        bool success;
    }
    struct ChainInfo {
        uint256 forkId;
        uint256 chainId;
    }
    struct DebugStep {
        uint256[] stack;
        bytes memoryInput;
        uint8 opcode;
        uint64 depth;
        bool isOutOfGas;
        address contractAddr;
    }
    struct DirEntry {
        string errorMessage;
        string path;
        uint64 depth;
        bool isDir;
        bool isSymlink;
    }
    struct EthGetLogs {
        address emitter;
        bytes32[] topics;
        bytes data;
        bytes32 blockHash;
        uint64 blockNumber;
        bytes32 transactionHash;
        uint64 transactionIndex;
        uint256 logIndex;
        bool removed;
    }
    struct FfiResult {
        int32 exitCode;
        bytes stdout;
        bytes stderr;
    }
    struct FsMetadata {
        bool isDir;
        bool isSymlink;
        uint256 length;
        bool readOnly;
        uint256 modified;
        uint256 accessed;
        uint256 created;
    }
    struct Gas {
        uint64 gasLimit;
        uint64 gasTotalUsed;
        uint64 gasMemoryUsed;
        int64 gasRefunded;
        uint64 gasRemaining;
    }
    struct Log {
        bytes32[] topics;
        bytes data;
        address emitter;
    }
    struct Rpc {
        string key;
        string url;
    }
    struct SignedDelegation {
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint64 nonce;
        address implementation;
    }
    struct StorageAccess {
        address account;
        bytes32 slot;
        bool isWrite;
        bytes32 previousValue;
        bytes32 newValue;
        bool reverted;
    }
    struct Wallet {
        address addr;
        uint256 publicKeyX;
        uint256 publicKeyY;
        uint256 privateKey;
    }

    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
    function addr(uint256 privateKey) external pure returns (address keyAddr);
    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory error) external pure;
    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory error) external pure;
    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals, string memory error) external pure;
    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory error) external pure;
    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string memory error) external pure;
    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string memory error) external pure;
    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals) external pure;
    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals, string memory error) external pure;
    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals) external pure;
    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals, string memory error) external pure;
    function assertEq(bytes32[] memory left, bytes32[] memory right) external pure;
    function assertEq(int256[] memory left, int256[] memory right, string memory error) external pure;
    function assertEq(address left, address right, string memory error) external pure;
    function assertEq(string memory left, string memory right, string memory error) external pure;
    function assertEq(address[] memory left, address[] memory right) external pure;
    function assertEq(address[] memory left, address[] memory right, string memory error) external pure;
    function assertEq(bool left, bool right, string memory error) external pure;
    function assertEq(address left, address right) external pure;
    function assertEq(uint256[] memory left, uint256[] memory right, string memory error) external pure;
    function assertEq(bool[] memory left, bool[] memory right) external pure;
    function assertEq(int256[] memory left, int256[] memory right) external pure;
    function assertEq(int256 left, int256 right, string memory error) external pure;
    function assertEq(bytes32 left, bytes32 right) external pure;
    function assertEq(uint256 left, uint256 right, string memory error) external pure;
    function assertEq(uint256[] memory left, uint256[] memory right) external pure;
    function assertEq(bytes memory left, bytes memory right) external pure;
    function assertEq(uint256 left, uint256 right) external pure;
    function assertEq(bytes32 left, bytes32 right, string memory error) external pure;
    function assertEq(string[] memory left, string[] memory right) external pure;
    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory error) external pure;
    function assertEq(bytes memory left, bytes memory right, string memory error) external pure;
    function assertEq(bool[] memory left, bool[] memory right, string memory error) external pure;
    function assertEq(bytes[] memory left, bytes[] memory right) external pure;
    function assertEq(string[] memory left, string[] memory right, string memory error) external pure;
    function assertEq(string memory left, string memory right) external pure;
    function assertEq(bytes[] memory left, bytes[] memory right, string memory error) external pure;
    function assertEq(bool left, bool right) external pure;
    function assertEq(int256 left, int256 right) external pure;
    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertFalse(bool condition, string memory error) external pure;
    function assertFalse(bool condition) external pure;
    function assertGe(int256 left, int256 right) external pure;
    function assertGe(int256 left, int256 right, string memory error) external pure;
    function assertGe(uint256 left, uint256 right) external pure;
    function assertGe(uint256 left, uint256 right, string memory error) external pure;
    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertGt(int256 left, int256 right) external pure;
    function assertGt(uint256 left, uint256 right, string memory error) external pure;
    function assertGt(uint256 left, uint256 right) external pure;
    function assertGt(int256 left, int256 right, string memory error) external pure;
    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertLe(int256 left, int256 right, string memory error) external pure;
    function assertLe(uint256 left, uint256 right) external pure;
    function assertLe(int256 left, int256 right) external pure;
    function assertLe(uint256 left, uint256 right, string memory error) external pure;
    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertLt(int256 left, int256 right) external pure;
    function assertLt(uint256 left, uint256 right, string memory error) external pure;
    function assertLt(int256 left, int256 right, string memory error) external pure;
    function assertLt(uint256 left, uint256 right) external pure;
    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertNotEq(bytes32[] memory left, bytes32[] memory right) external pure;
    function assertNotEq(int256[] memory left, int256[] memory right) external pure;
    function assertNotEq(bool left, bool right, string memory error) external pure;
    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory error) external pure;
    function assertNotEq(bool left, bool right) external pure;
    function assertNotEq(bool[] memory left, bool[] memory right) external pure;
    function assertNotEq(bytes memory left, bytes memory right) external pure;
    function assertNotEq(address[] memory left, address[] memory right) external pure;
    function assertNotEq(int256 left, int256 right, string memory error) external pure;
    function assertNotEq(uint256[] memory left, uint256[] memory right) external pure;
    function assertNotEq(bool[] memory left, bool[] memory right, string memory error) external pure;
    function assertNotEq(string memory left, string memory right) external pure;
    function assertNotEq(address[] memory left, address[] memory right, string memory error) external pure;
    function assertNotEq(string memory left, string memory right, string memory error) external pure;
    function assertNotEq(address left, address right, string memory error) external pure;
    function assertNotEq(bytes32 left, bytes32 right) external pure;
    function assertNotEq(bytes memory left, bytes memory right, string memory error) external pure;
    function assertNotEq(uint256 left, uint256 right, string memory error) external pure;
    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory error) external pure;
    function assertNotEq(address left, address right) external pure;
    function assertNotEq(bytes32 left, bytes32 right, string memory error) external pure;
    function assertNotEq(string[] memory left, string[] memory right, string memory error) external pure;
    function assertNotEq(uint256 left, uint256 right) external pure;
    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory error) external pure;
    function assertNotEq(string[] memory left, string[] memory right) external pure;
    function assertNotEq(int256[] memory left, int256[] memory right, string memory error) external pure;
    function assertNotEq(bytes[] memory left, bytes[] memory right) external pure;
    function assertNotEq(int256 left, int256 right) external pure;
    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    function assertTrue(bool condition) external pure;
    function assertTrue(bool condition, string memory error) external pure;
    function assume(bool condition) external pure;
    function assumeNoRevert() external pure;
    function attachDelegation(SignedDelegation memory signedDelegation) external;
    function breakpoint(string memory char) external pure;
    function breakpoint(string memory char, bool value) external pure;
    function broadcast() external;
    function broadcast(address signer) external;
    function broadcast(uint256 privateKey) external;
    function broadcastRawTransaction(bytes memory data) external;
    function closeFile(string memory path) external;
    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer) external pure returns (address);
    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
    function contains(string memory subject, string memory search) external returns (bool result);
    function copyFile(string memory from, string memory to) external returns (uint64 copied);
    function copyStorage(address from, address to) external;
    function createDir(string memory path, bool recursive) external;
    function createWallet(string memory walletLabel) external returns (Wallet memory wallet);
    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
    function createWallet(uint256 privateKey, string memory walletLabel) external returns (Wallet memory wallet);
    function deployCode(string memory artifactPath, bytes memory constructorArgs) external returns (address deployedAddress);
    function deployCode(string memory artifactPath) external returns (address deployedAddress);
    function deriveKey(string memory mnemonic, string memory derivationPath, uint32 index, string memory language) external pure returns (uint256 privateKey);
    function deriveKey(string memory mnemonic, uint32 index, string memory language) external pure returns (uint256 privateKey);
    function deriveKey(string memory mnemonic, uint32 index) external pure returns (uint256 privateKey);
    function deriveKey(string memory mnemonic, string memory derivationPath, uint32 index) external pure returns (uint256 privateKey);
    function ensNamehash(string memory name) external pure returns (bytes32);
    function envAddress(string memory name) external view returns (address value);
    function envAddress(string memory name, string memory delim) external view returns (address[] memory value);
    function envBool(string memory name) external view returns (bool value);
    function envBool(string memory name, string memory delim) external view returns (bool[] memory value);
    function envBytes(string memory name) external view returns (bytes memory value);
    function envBytes(string memory name, string memory delim) external view returns (bytes[] memory value);
    function envBytes32(string memory name, string memory delim) external view returns (bytes32[] memory value);
    function envBytes32(string memory name) external view returns (bytes32 value);
    function envExists(string memory name) external view returns (bool result);
    function envInt(string memory name, string memory delim) external view returns (int256[] memory value);
    function envInt(string memory name) external view returns (int256 value);
    function envOr(string memory name, string memory delim, bytes32[] memory defaultValue) external view returns (bytes32[] memory value);
    function envOr(string memory name, string memory delim, int256[] memory defaultValue) external view returns (int256[] memory value);
    function envOr(string memory name, bool defaultValue) external view returns (bool value);
    function envOr(string memory name, address defaultValue) external view returns (address value);
    function envOr(string memory name, uint256 defaultValue) external view returns (uint256 value);
    function envOr(string memory name, string memory delim, bytes[] memory defaultValue) external view returns (bytes[] memory value);
    function envOr(string memory name, string memory delim, uint256[] memory defaultValue) external view returns (uint256[] memory value);
    function envOr(string memory name, string memory delim, string[] memory defaultValue) external view returns (string[] memory value);
    function envOr(string memory name, bytes memory defaultValue) external view returns (bytes memory value);
    function envOr(string memory name, bytes32 defaultValue) external view returns (bytes32 value);
    function envOr(string memory name, int256 defaultValue) external view returns (int256 value);
    function envOr(string memory name, string memory delim, address[] memory defaultValue) external view returns (address[] memory value);
    function envOr(string memory name, string memory defaultValue) external view returns (string memory value);
    function envOr(string memory name, string memory delim, bool[] memory defaultValue) external view returns (bool[] memory value);
    function envString(string memory name, string memory delim) external view returns (string[] memory value);
    function envString(string memory name) external view returns (string memory value);
    function envUint(string memory name) external view returns (uint256 value);
    function envUint(string memory name, string memory delim) external view returns (uint256[] memory value);
    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] memory topics) external returns (EthGetLogs[] memory logs);
    function exists(string memory path) external view returns (bool result);
    function ffi(string[] memory commandInput) external returns (bytes memory result);
    function fsMetadata(string memory path) external view returns (FsMetadata memory metadata);
    function getArtifactPathByCode(bytes memory code) external view returns (string memory path);
    function getArtifactPathByDeployedCode(bytes memory deployedCode) external view returns (string memory path);
    function getBlobBaseFee() external view returns (uint256 blobBaseFee);
    function getBlockNumber() external view returns (uint256 height);
    function getBlockTimestamp() external view returns (uint256 timestamp);
    function getBroadcast(string memory contractName, uint64 chainId, BroadcastTxType txType) external view returns (BroadcastTxSummary memory);
    function getBroadcasts(string memory contractName, uint64 chainId) external view returns (BroadcastTxSummary[] memory);
    function getBroadcasts(string memory contractName, uint64 chainId, BroadcastTxType txType) external view returns (BroadcastTxSummary[] memory);
    function getCode(string memory artifactPath) external view returns (bytes memory creationBytecode);
    function getDeployedCode(string memory artifactPath) external view returns (bytes memory runtimeBytecode);
    function getDeployment(string memory contractName, uint64 chainId) external view returns (address deployedAddress);
    function getDeployment(string memory contractName) external view returns (address deployedAddress);
    function getDeployments(string memory contractName, uint64 chainId) external view returns (address[] memory deployedAddresses);
    function getFoundryVersion() external view returns (string memory version);
    function getLabel(address account) external view returns (string memory currentLabel);
    function getMappingKeyAndParentOf(address target, bytes32 elementSlot) external returns (bool found, bytes32 key, bytes32 parent);
    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
    function getNonce(address account) external view returns (uint64 nonce);
    function getNonce(Wallet memory wallet) external returns (uint64 nonce);
    function getRecordedLogs() external returns (Log[] memory logs);
    function getStateDiff() external view returns (string memory diff);
    function getStateDiffJson() external view returns (string memory diff);
    function getWallets() external returns (address[] memory wallets);
    function indexOf(string memory input, string memory key) external pure returns (uint256);
    function isContext(ForgeContext context) external view returns (bool result);
    function isDir(string memory path) external view returns (bool result);
    function isFile(string memory path) external view returns (bool result);
    function keyExists(string memory json, string memory key) external view returns (bool);
    function keyExistsJson(string memory json, string memory key) external view returns (bool);
    function keyExistsToml(string memory toml, string memory key) external view returns (bool);
    function label(address account, string memory newLabel) external;
    function lastCallGas() external view returns (Gas memory gas);
    function load(address target, bytes32 slot) external view returns (bytes32 data);
    function parseAddress(string memory stringifiedValue) external pure returns (address parsedValue);
    function parseBool(string memory stringifiedValue) external pure returns (bool parsedValue);
    function parseBytes(string memory stringifiedValue) external pure returns (bytes memory parsedValue);
    function parseBytes32(string memory stringifiedValue) external pure returns (bytes32 parsedValue);
    function parseInt(string memory stringifiedValue) external pure returns (int256 parsedValue);
    function parseJson(string memory json) external pure returns (bytes memory abiEncodedData);
    function parseJson(string memory json, string memory key) external pure returns (bytes memory abiEncodedData);
    function parseJsonAddress(string memory json, string memory key) external pure returns (address);
    function parseJsonAddressArray(string memory json, string memory key) external pure returns (address[] memory);
    function parseJsonBool(string memory json, string memory key) external pure returns (bool);
    function parseJsonBoolArray(string memory json, string memory key) external pure returns (bool[] memory);
    function parseJsonBytes(string memory json, string memory key) external pure returns (bytes memory);
    function parseJsonBytes32(string memory json, string memory key) external pure returns (bytes32);
    function parseJsonBytes32Array(string memory json, string memory key) external pure returns (bytes32[] memory);
    function parseJsonBytesArray(string memory json, string memory key) external pure returns (bytes[] memory);
    function parseJsonInt(string memory json, string memory key) external pure returns (int256);
    function parseJsonIntArray(string memory json, string memory key) external pure returns (int256[] memory);
    function parseJsonKeys(string memory json, string memory key) external pure returns (string[] memory keys);
    function parseJsonString(string memory json, string memory key) external pure returns (string memory);
    function parseJsonStringArray(string memory json, string memory key) external pure returns (string[] memory);
    function parseJsonType(string memory json, string memory typeDescription) external pure returns (bytes memory);
    function parseJsonType(string memory json, string memory key, string memory typeDescription) external pure returns (bytes memory);
    function parseJsonTypeArray(string memory json, string memory key, string memory typeDescription) external pure returns (bytes memory);
    function parseJsonUint(string memory json, string memory key) external pure returns (uint256);
    function parseJsonUintArray(string memory json, string memory key) external pure returns (uint256[] memory);
    function parseToml(string memory toml, string memory key) external pure returns (bytes memory abiEncodedData);
    function parseToml(string memory toml) external pure returns (bytes memory abiEncodedData);
    function parseTomlAddress(string memory toml, string memory key) external pure returns (address);
    function parseTomlAddressArray(string memory toml, string memory key) external pure returns (address[] memory);
    function parseTomlBool(string memory toml, string memory key) external pure returns (bool);
    function parseTomlBoolArray(string memory toml, string memory key) external pure returns (bool[] memory);
    function parseTomlBytes(string memory toml, string memory key) external pure returns (bytes memory);
    function parseTomlBytes32(string memory toml, string memory key) external pure returns (bytes32);
    function parseTomlBytes32Array(string memory toml, string memory key) external pure returns (bytes32[] memory);
    function parseTomlBytesArray(string memory toml, string memory key) external pure returns (bytes[] memory);
    function parseTomlInt(string memory toml, string memory key) external pure returns (int256);
    function parseTomlIntArray(string memory toml, string memory key) external pure returns (int256[] memory);
    function parseTomlKeys(string memory toml, string memory key) external pure returns (string[] memory keys);
    function parseTomlString(string memory toml, string memory key) external pure returns (string memory);
    function parseTomlStringArray(string memory toml, string memory key) external pure returns (string[] memory);
    function parseTomlType(string memory toml, string memory typeDescription) external pure returns (bytes memory);
    function parseTomlType(string memory toml, string memory key, string memory typeDescription) external pure returns (bytes memory);
    function parseTomlTypeArray(string memory toml, string memory key, string memory typeDescription) external pure returns (bytes memory);
    function parseTomlUint(string memory toml, string memory key) external pure returns (uint256);
    function parseTomlUintArray(string memory toml, string memory key) external pure returns (uint256[] memory);
    function parseUint(string memory stringifiedValue) external pure returns (uint256 parsedValue);
    function pauseGasMetering() external;
    function pauseTracing() external view;
    function projectRoot() external view returns (string memory path);
    function prompt(string memory promptText) external returns (string memory input);
    function promptAddress(string memory promptText) external returns (address);
    function promptSecret(string memory promptText) external returns (string memory input);
    function promptSecretUint(string memory promptText) external returns (uint256);
    function promptUint(string memory promptText) external returns (uint256);
    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);
    function randomAddress() external returns (address);
    function randomBool() external view returns (bool);
    function randomBytes(uint256 len) external view returns (bytes memory);
    function randomBytes4() external view returns (bytes4);
    function randomBytes8() external view returns (bytes8);
    function randomInt() external view returns (int256);
    function randomInt(uint256 bits) external view returns (int256);
    function randomUint() external returns (uint256);
    function randomUint(uint256 bits) external view returns (uint256);
    function randomUint(uint256 min, uint256 max) external returns (uint256);
    function readDir(string memory path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
    function readDir(string memory path, uint64 maxDepth, bool followLinks) external view returns (DirEntry[] memory entries);
    function readDir(string memory path) external view returns (DirEntry[] memory entries);
    function readFile(string memory path) external view returns (string memory data);
    function readFileBinary(string memory path) external view returns (bytes memory data);
    function readLine(string memory path) external view returns (string memory line);
    function readLink(string memory linkPath) external view returns (string memory targetPath);
    function record() external;
    function recordLogs() external;
    function rememberKey(uint256 privateKey) external returns (address keyAddr);
    function rememberKeys(string memory mnemonic, string memory derivationPath, uint32 count) external returns (address[] memory keyAddrs);
    function rememberKeys(string memory mnemonic, string memory derivationPath, string memory language, uint32 count) external returns (address[] memory keyAddrs);
    function removeDir(string memory path, bool recursive) external;
    function removeFile(string memory path) external;
    function replace(string memory input, string memory from, string memory to) external pure returns (string memory output);
    function resetGasMetering() external;
    function resumeGasMetering() external;
    function resumeTracing() external view;
    function rpc(string memory urlOrAlias, string memory method, string memory params) external returns (bytes memory data);
    function rpc(string memory method, string memory params) external returns (bytes memory data);
    function rpcUrl(string memory rpcAlias) external view returns (string memory json);
    function rpcUrlStructs() external view returns (Rpc[] memory urls);
    function rpcUrls() external view returns (string[2][] memory urls);
    function serializeAddress(string memory objectKey, string memory valueKey, address[] memory values) external returns (string memory json);
    function serializeAddress(string memory objectKey, string memory valueKey, address value) external returns (string memory json);
    function serializeBool(string memory objectKey, string memory valueKey, bool[] memory values) external returns (string memory json);
    function serializeBool(string memory objectKey, string memory valueKey, bool value) external returns (string memory json);
    function serializeBytes(string memory objectKey, string memory valueKey, bytes[] memory values) external returns (string memory json);
    function serializeBytes(string memory objectKey, string memory valueKey, bytes memory value) external returns (string memory json);
    function serializeBytes32(string memory objectKey, string memory valueKey, bytes32[] memory values) external returns (string memory json);
    function serializeBytes32(string memory objectKey, string memory valueKey, bytes32 value) external returns (string memory json);
    function serializeInt(string memory objectKey, string memory valueKey, int256 value) external returns (string memory json);
    function serializeInt(string memory objectKey, string memory valueKey, int256[] memory values) external returns (string memory json);
    function serializeJson(string memory objectKey, string memory value) external returns (string memory json);
    function serializeJsonType(string memory typeDescription, bytes memory value) external pure returns (string memory json);
    function serializeJsonType(string memory objectKey, string memory valueKey, string memory typeDescription, bytes memory value) external returns (string memory json);
    function serializeString(string memory objectKey, string memory valueKey, string[] memory values) external returns (string memory json);
    function serializeString(string memory objectKey, string memory valueKey, string memory value) external returns (string memory json);
    function serializeUint(string memory objectKey, string memory valueKey, uint256 value) external returns (string memory json);
    function serializeUint(string memory objectKey, string memory valueKey, uint256[] memory values) external returns (string memory json);
    function serializeUintToHex(string memory objectKey, string memory valueKey, uint256 value) external returns (string memory json);
    function setArbitraryStorage(address target) external;
    function setEnv(string memory name, string memory value) external;
    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    function sign(Wallet memory wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    function signAndAttachDelegation(address implementation, uint256 privateKey) external returns (SignedDelegation memory signedDelegation);
    function signCompact(Wallet memory wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);
    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    function signDelegation(address implementation, uint256 privateKey) external returns (SignedDelegation memory signedDelegation);
    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
    function sleep(uint256 duration) external;
    function split(string memory input, string memory delimiter) external pure returns (string[] memory outputs);
    function startBroadcast() external;
    function startBroadcast(address signer) external;
    function startBroadcast(uint256 privateKey) external;
    function startDebugTraceRecording() external;
    function startMappingRecording() external;
    function startStateDiffRecording() external;
    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);
    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
    function stopBroadcast() external;
    function stopMappingRecording() external;
    function toBase64(string memory data) external pure returns (string memory);
    function toBase64(bytes memory data) external pure returns (string memory);
    function toBase64URL(string memory data) external pure returns (string memory);
    function toBase64URL(bytes memory data) external pure returns (string memory);
    function toLowercase(string memory input) external pure returns (string memory output);
    function toString(address value) external pure returns (string memory stringifiedValue);
    function toString(uint256 value) external pure returns (string memory stringifiedValue);
    function toString(bytes memory value) external pure returns (string memory stringifiedValue);
    function toString(bool value) external pure returns (string memory stringifiedValue);
    function toString(int256 value) external pure returns (string memory stringifiedValue);
    function toString(bytes32 value) external pure returns (string memory stringifiedValue);
    function toUppercase(string memory input) external pure returns (string memory output);
    function trim(string memory input) external pure returns (string memory output);
    function tryFfi(string[] memory commandInput) external returns (FfiResult memory result);
    function unixTime() external view returns (uint256 milliseconds);
    function writeFile(string memory path, string memory data) external;
    function writeFileBinary(string memory path, bytes memory data) external;
    function writeJson(string memory json, string memory path, string memory valueKey) external;
    function writeJson(string memory json, string memory path) external;
    function writeLine(string memory path, string memory data) external;
    function writeToml(string memory json, string memory path, string memory valueKey) external;
    function writeToml(string memory json, string memory path) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "accesses",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "readSlots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "writeSlots",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addr",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "keyAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbs",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbs",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbs",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbs",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbsDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbsDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbsDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqAbsDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRel",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRel",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRel",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRel",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRelDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRelDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRelDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertApproxEqRelDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "maxPercentDelta",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "right",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "right",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "right",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "right",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "right",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "right",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "right",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "right",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "right",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "right",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "right",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "right",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "right",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "right",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "right",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "right",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "right",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "right",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "right",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "right",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "right",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "right",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "right",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "right",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertFalse",
    "inputs": [
      {
        "name": "condition",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertFalse",
    "inputs": [
      {
        "name": "condition",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGe",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGe",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGe",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGe",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGt",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGt",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGt",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGt",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertGtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLe",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLe",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLe",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLe",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLeDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLt",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLt",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLt",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLt",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertLtDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "right",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "right",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "right",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "right",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "right",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "right",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "right",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "right",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "right",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "right",
        "type": "bool[]",
        "internalType": "bool[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "right",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "right",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "right",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "right",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "right",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "right",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "right",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "right",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "right",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "right",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "right",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "string[]",
        "internalType": "string[]"
      },
      {
        "name": "right",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "right",
        "type": "int256[]",
        "internalType": "int256[]"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "bytes[]",
        "internalType": "bytes[]"
      },
      {
        "name": "right",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEq",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "right",
        "type": "int256",
        "internalType": "int256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertNotEqDecimal",
    "inputs": [
      {
        "name": "left",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "right",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "decimals",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertTrue",
    "inputs": [
      {
        "name": "condition",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assertTrue",
    "inputs": [
      {
        "name": "condition",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "error",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assume",
    "inputs": [
      {
        "name": "condition",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "assumeNoRevert",
    "inputs": [],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "attachDelegation",
    "inputs": [
      {
        "name": "signedDelegation",
        "type": "tuple",
        "internalType": "struct VmSafe.SignedDelegation",
        "components": [
          {
            "name": "v",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "r",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "s",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "nonce",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "implementation",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "breakpoint",
    "inputs": [
      {
        "name": "char",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "breakpoint",
    "inputs": [
      {
        "name": "char",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "broadcast",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "broadcast",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "broadcast",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "broadcastRawTransaction",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "closeFile",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "computeCreate2Address",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initCodeHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "computeCreate2Address",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initCodeHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "computeCreateAddress",
    "inputs": [
      {
        "name": "deployer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "contains",
    "inputs": [
      {
        "name": "subject",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "search",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "copyFile",
    "inputs": [
      {
        "name": "from",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "to",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "copied",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "copyStorage",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "recursive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createWallet",
    "inputs": [
      {
        "name": "walletLabel",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createWallet",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createWallet",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "walletLabel",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deployCode",
    "inputs": [
      {
        "name": "artifactPath",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "constructorArgs",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "deployedAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deployCode",
    "inputs": [
      {
        "name": "artifactPath",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "deployedAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deriveKey",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "derivationPath",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "index",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "language",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "deriveKey",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "index",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "language",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "deriveKey",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "index",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "deriveKey",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "derivationPath",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "index",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "ensNamehash",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "envAddress",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envAddress",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBool",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBool",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBytes",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBytes",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBytes32",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envBytes32",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envExists",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envInt",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envInt",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envOr",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "defaultValue",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envString",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envString",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envUint",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "envUint",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delim",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eth_getLogs",
    "inputs": [
      {
        "name": "fromBlock",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "toBlock",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "topics",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "logs",
        "type": "tuple[]",
        "internalType": "struct VmSafe.EthGetLogs[]",
        "components": [
          {
            "name": "emitter",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "topics",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "blockHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "transactionHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "transactionIndex",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "logIndex",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "removed",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "exists",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ffi",
    "inputs": [
      {
        "name": "commandInput",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fsMetadata",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "metadata",
        "type": "tuple",
        "internalType": "struct VmSafe.FsMetadata",
        "components": [
          {
            "name": "isDir",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "isSymlink",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "length",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "readOnly",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "modified",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "accessed",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "created",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getArtifactPathByCode",
    "inputs": [
      {
        "name": "code",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getArtifactPathByDeployedCode",
    "inputs": [
      {
        "name": "deployedCode",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlobBaseFee",
    "inputs": [],
    "outputs": [
      {
        "name": "blobBaseFee",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockNumber",
    "inputs": [],
    "outputs": [
      {
        "name": "height",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockTimestamp",
    "inputs": [],
    "outputs": [
      {
        "name": "timestamp",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBroadcast",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "txType",
        "type": "uint8",
        "internalType": "enum VmSafe.BroadcastTxType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct VmSafe.BroadcastTxSummary",
        "components": [
          {
            "name": "txHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "txType",
            "type": "uint8",
            "internalType": "enum VmSafe.BroadcastTxType"
          },
          {
            "name": "contractAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "success",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBroadcasts",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct VmSafe.BroadcastTxSummary[]",
        "components": [
          {
            "name": "txHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "txType",
            "type": "uint8",
            "internalType": "enum VmSafe.BroadcastTxType"
          },
          {
            "name": "contractAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "success",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBroadcasts",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "txType",
        "type": "uint8",
        "internalType": "enum VmSafe.BroadcastTxType"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct VmSafe.BroadcastTxSummary[]",
        "components": [
          {
            "name": "txHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "txType",
            "type": "uint8",
            "internalType": "enum VmSafe.BroadcastTxType"
          },
          {
            "name": "contractAddress",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "success",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCode",
    "inputs": [
      {
        "name": "artifactPath",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "creationBytecode",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeployedCode",
    "inputs": [
      {
        "name": "artifactPath",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "runtimeBytecode",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeployment",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "deployedAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeployment",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "deployedAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeployments",
    "inputs": [
      {
        "name": "contractName",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "deployedAddresses",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getFoundryVersion",
    "inputs": [],
    "outputs": [
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLabel",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "currentLabel",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getMappingKeyAndParentOf",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "elementSlot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "found",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "key",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "parent",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getMappingLength",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mappingSlot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getMappingSlotAt",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "mappingSlot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "idx",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getNonce",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "nonce",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNonce",
    "inputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "nonce",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getRecordedLogs",
    "inputs": [],
    "outputs": [
      {
        "name": "logs",
        "type": "tuple[]",
        "internalType": "struct VmSafe.Log[]",
        "components": [
          {
            "name": "topics",
            "type": "bytes32[]",
            "internalType": "bytes32[]"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "emitter",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getStateDiff",
    "inputs": [],
    "outputs": [
      {
        "name": "diff",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getStateDiffJson",
    "inputs": [],
    "outputs": [
      {
        "name": "diff",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getWallets",
    "inputs": [],
    "outputs": [
      {
        "name": "wallets",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "indexOf",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "isContext",
    "inputs": [
      {
        "name": "context",
        "type": "uint8",
        "internalType": "enum VmSafe.ForgeContext"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isFile",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "keyExists",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "keyExistsJson",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "keyExistsToml",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "label",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "newLabel",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "lastCallGas",
    "inputs": [],
    "outputs": [
      {
        "name": "gas",
        "type": "tuple",
        "internalType": "struct VmSafe.Gas",
        "components": [
          {
            "name": "gasLimit",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "gasTotalUsed",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "gasMemoryUsed",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "gasRefunded",
            "type": "int64",
            "internalType": "int64"
          },
          {
            "name": "gasRemaining",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "load",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "parseAddress",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseBool",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseBytes",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseBytes32",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseInt",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJson",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "abiEncodedData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJson",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "abiEncodedData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonAddress",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonAddressArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBool",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBoolArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBytes",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBytes32",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBytes32Array",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonBytesArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonInt",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonIntArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonKeys",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonString",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonStringArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonType",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonType",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonTypeArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonUint",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseJsonUintArray",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseToml",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "abiEncodedData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseToml",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "abiEncodedData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlAddress",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlAddressArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBool",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBoolArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBytes",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBytes32",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBytes32Array",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlBytesArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlInt",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlIntArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlKeys",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "keys",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlString",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlStringArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlType",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlType",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlTypeArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlUint",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseTomlUintArray",
    "inputs": [
      {
        "name": "toml",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "key",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "parseUint",
    "inputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "parsedValue",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "pauseGasMetering",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "pauseTracing",
    "inputs": [],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "projectRoot",
    "inputs": [],
    "outputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "prompt",
    "inputs": [
      {
        "name": "promptText",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "promptAddress",
    "inputs": [
      {
        "name": "promptText",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "promptSecret",
    "inputs": [
      {
        "name": "promptText",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "promptSecretUint",
    "inputs": [
      {
        "name": "promptText",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "promptUint",
    "inputs": [
      {
        "name": "promptText",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "publicKeyP256",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "publicKeyX",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "publicKeyY",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "randomAddress",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "randomBool",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomBytes",
    "inputs": [
      {
        "name": "len",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomBytes4",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomBytes8",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes8",
        "internalType": "bytes8"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomInt",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomInt",
    "inputs": [
      {
        "name": "bits",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomUint",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "randomUint",
    "inputs": [
      {
        "name": "bits",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "randomUint",
    "inputs": [
      {
        "name": "min",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "max",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "readDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "maxDepth",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "entries",
        "type": "tuple[]",
        "internalType": "struct VmSafe.DirEntry[]",
        "components": [
          {
            "name": "errorMessage",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "path",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "depth",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isDir",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "isSymlink",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "maxDepth",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "followLinks",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "entries",
        "type": "tuple[]",
        "internalType": "struct VmSafe.DirEntry[]",
        "components": [
          {
            "name": "errorMessage",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "path",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "depth",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isDir",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "isSymlink",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "entries",
        "type": "tuple[]",
        "internalType": "struct VmSafe.DirEntry[]",
        "components": [
          {
            "name": "errorMessage",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "path",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "depth",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isDir",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "isSymlink",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readFile",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readFileBinary",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readLine",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "line",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "readLink",
    "inputs": [
      {
        "name": "linkPath",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "targetPath",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "record",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "recordLogs",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rememberKey",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "keyAddr",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rememberKeys",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "derivationPath",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "count",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "keyAddrs",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rememberKeys",
    "inputs": [
      {
        "name": "mnemonic",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "derivationPath",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "language",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "count",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "keyAddrs",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeDir",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "recursive",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeFile",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "replace",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "from",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "to",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "resetGasMetering",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeGasMetering",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "resumeTracing",
    "inputs": [],
    "outputs": [],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rpc",
    "inputs": [
      {
        "name": "urlOrAlias",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "method",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "params",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rpc",
    "inputs": [
      {
        "name": "method",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "params",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rpcUrl",
    "inputs": [
      {
        "name": "rpcAlias",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rpcUrlStructs",
    "inputs": [],
    "outputs": [
      {
        "name": "urls",
        "type": "tuple[]",
        "internalType": "struct VmSafe.Rpc[]",
        "components": [
          {
            "name": "key",
            "type": "string",
            "internalType": "string"
          },
          {
            "name": "url",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rpcUrls",
    "inputs": [],
    "outputs": [
      {
        "name": "urls",
        "type": "string[2][]",
        "internalType": "string[2][]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "serializeAddress",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeAddress",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBool",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "bool[]",
        "internalType": "bool[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBool",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBytes",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBytes",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBytes32",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeBytes32",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeInt",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeInt",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "int256[]",
        "internalType": "int256[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeJson",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeJsonType",
    "inputs": [
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "serializeJsonType",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "typeDescription",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeString",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeString",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeUint",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeUint",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "values",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serializeUintToHex",
    "inputs": [
      {
        "name": "objectKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setArbitraryStorage",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setEnv",
    "inputs": [
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "value",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sign",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sign",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sign",
    "inputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sign",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "v",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "signAndAttachDelegation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "signedDelegation",
        "type": "tuple",
        "internalType": "struct VmSafe.SignedDelegation",
        "components": [
          {
            "name": "v",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "r",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "s",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "nonce",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "implementation",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "signCompact",
    "inputs": [
      {
        "name": "wallet",
        "type": "tuple",
        "internalType": "struct VmSafe.Wallet",
        "components": [
          {
            "name": "addr",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "publicKeyX",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "publicKeyY",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "privateKey",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "vs",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "signCompact",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "vs",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "signCompact",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "vs",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "signCompact",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "vs",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "signDelegation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "signedDelegation",
        "type": "tuple",
        "internalType": "struct VmSafe.SignedDelegation",
        "components": [
          {
            "name": "v",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "r",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "s",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "nonce",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "implementation",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "signP256",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "r",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "sleep",
    "inputs": [
      {
        "name": "duration",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "split",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "delimiter",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "outputs",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "startBroadcast",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startBroadcast",
    "inputs": [
      {
        "name": "signer",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startBroadcast",
    "inputs": [
      {
        "name": "privateKey",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startDebugTraceRecording",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startMappingRecording",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startStateDiffRecording",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stopAndReturnDebugTraceRecording",
    "inputs": [],
    "outputs": [
      {
        "name": "step",
        "type": "tuple[]",
        "internalType": "struct VmSafe.DebugStep[]",
        "components": [
          {
            "name": "stack",
            "type": "uint256[]",
            "internalType": "uint256[]"
          },
          {
            "name": "memoryInput",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "opcode",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "depth",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "isOutOfGas",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "contractAddr",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stopAndReturnStateDiff",
    "inputs": [],
    "outputs": [
      {
        "name": "accountAccesses",
        "type": "tuple[]",
        "internalType": "struct VmSafe.AccountAccess[]",
        "components": [
          {
            "name": "chainInfo",
            "type": "tuple",
            "internalType": "struct VmSafe.ChainInfo",
            "components": [
              {
                "name": "forkId",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "chainId",
                "type": "uint256",
                "internalType": "uint256"
              }
            ]
          },
          {
            "name": "kind",
            "type": "uint8",
            "internalType": "enum VmSafe.AccountAccessKind"
          },
          {
            "name": "account",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "accessor",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "initialized",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "oldBalance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "newBalance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "deployedCode",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "value",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "reverted",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "storageAccesses",
            "type": "tuple[]",
            "internalType": "struct VmSafe.StorageAccess[]",
            "components": [
              {
                "name": "account",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "slot",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "isWrite",
                "type": "bool",
                "internalType": "bool"
              },
              {
                "name": "previousValue",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "newValue",
                "type": "bytes32",
                "internalType": "bytes32"
              },
              {
                "name": "reverted",
                "type": "bool",
                "internalType": "bool"
              }
            ]
          },
          {
            "name": "depth",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stopBroadcast",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "stopMappingRecording",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "toBase64",
    "inputs": [
      {
        "name": "data",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toBase64",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toBase64URL",
    "inputs": [
      {
        "name": "data",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toBase64URL",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toLowercase",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toString",
    "inputs": [
      {
        "name": "value",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "stringifiedValue",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "toUppercase",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "trim",
    "inputs": [
      {
        "name": "input",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [
      {
        "name": "output",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "tryFfi",
    "inputs": [
      {
        "name": "commandInput",
        "type": "string[]",
        "internalType": "string[]"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "tuple",
        "internalType": "struct VmSafe.FfiResult",
        "components": [
          {
            "name": "exitCode",
            "type": "int32",
            "internalType": "int32"
          },
          {
            "name": "stdout",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "stderr",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unixTime",
    "inputs": [],
    "outputs": [
      {
        "name": "milliseconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "writeFile",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "data",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeFileBinary",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeJson",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeJson",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeLine",
    "inputs": [
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "data",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeToml",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "valueKey",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "writeToml",
    "inputs": [
      {
        "name": "json",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "path",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod VmSafe {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountAccessKind(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<AccountAccessKind> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::abi_encoded_size(
                    self,
                )
            }
        }
        #[automatically_derived]
        impl AccountAccessKind {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AccountAccessKind {
            type RustType = u8;
            type Token<'a> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AccountAccessKind {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BroadcastTxType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BroadcastTxType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::abi_encoded_size(
                    self,
                )
            }
        }
        #[automatically_derived]
        impl BroadcastTxType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BroadcastTxType {
            type RustType = u8;
            type Token<'a> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BroadcastTxType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ForgeContext(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ForgeContext> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::abi_encoded_size(
                    self,
                )
            }
        }
        #[automatically_derived]
        impl ForgeContext {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ForgeContext {
            type RustType = u8;
            type Token<'a> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ForgeContext {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    /**```solidity
    struct AccountAccess { ChainInfo chainInfo; AccountAccessKind kind; address account; address accessor; bool initialized; uint256 oldBalance; uint256 newBalance; bytes deployedCode; uint256 value; bytes data; bool reverted; StorageAccess[] storageAccesses; uint64 depth; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccountAccess {
        pub chainInfo: <ChainInfo as alloy::sol_types::SolType>::RustType,
        pub kind: <AccountAccessKind as alloy::sol_types::SolType>::RustType,
        pub account: alloy::sol_types::private::Address,
        pub accessor: alloy::sol_types::private::Address,
        pub initialized: bool,
        pub oldBalance: alloy::sol_types::private::primitives::aliases::U256,
        pub newBalance: alloy::sol_types::private::primitives::aliases::U256,
        pub deployedCode: alloy::sol_types::private::Bytes,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        pub data: alloy::sol_types::private::Bytes,
        pub reverted: bool,
        pub storageAccesses:
            alloy::sol_types::private::Vec<<StorageAccess as alloy::sol_types::SolType>::RustType>,
        pub depth: u64,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ChainInfo,
            AccountAccessKind,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Array<StorageAccess>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <ChainInfo as alloy::sol_types::SolType>::RustType,
            <AccountAccessKind as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
            bool,
            alloy::sol_types::private::Vec<<StorageAccess as alloy::sol_types::SolType>::RustType>,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccountAccess> for UnderlyingRustTuple<'_> {
            fn from(value: AccountAccess) -> Self {
                (
                    value.chainInfo,
                    value.kind,
                    value.account,
                    value.accessor,
                    value.initialized,
                    value.oldBalance,
                    value.newBalance,
                    value.deployedCode,
                    value.value,
                    value.data,
                    value.reverted,
                    value.storageAccesses,
                    value.depth,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AccountAccess {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    chainInfo: tuple.0,
                    kind: tuple.1,
                    account: tuple.2,
                    accessor: tuple.3,
                    initialized: tuple.4,
                    oldBalance: tuple.5,
                    newBalance: tuple.6,
                    deployedCode: tuple.7,
                    value: tuple.8,
                    data: tuple.9,
                    reverted: tuple.10,
                    storageAccesses: tuple.11,
                    depth: tuple.12,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AccountAccess {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AccountAccess {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <ChainInfo as alloy_sol_types::SolType>::tokenize(&self.chainInfo),
                    <AccountAccessKind as alloy_sol_types::SolType>::tokenize(
                        &self.kind,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.accessor,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.initialized,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldBalance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newBalance),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.deployedCode,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.reverted,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        StorageAccess,
                    > as alloy_sol_types::SolType>::tokenize(&self.storageAccesses),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.depth),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AccountAccess {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AccountAccess {
            const NAME: &'static str = "AccountAccess";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AccountAccess(ChainInfo chainInfo,uint8 kind,address account,address accessor,bool initialized,uint256 oldBalance,uint256 newBalance,bytes deployedCode,uint256 value,bytes data,bool reverted,StorageAccess[] storageAccesses,uint64 depth)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                let mut components = alloy_sol_types::private::Vec::with_capacity(2);
                components.push(<ChainInfo as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<ChainInfo as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<StorageAccess as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<StorageAccess as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <ChainInfo as alloy_sol_types::SolType>::eip712_data_word(
                            &self.chainInfo,
                        )
                        .0,
                    <AccountAccessKind as alloy_sol_types::SolType>::eip712_data_word(
                            &self.kind,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.account,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.accessor,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.initialized,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.oldBalance)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.newBalance)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.deployedCode,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.value)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.reverted,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        StorageAccess,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.storageAccesses,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.depth)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AccountAccess {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <ChainInfo as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainInfo,
                    )
                    + <AccountAccessKind as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kind,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.account,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.accessor,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.initialized,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.oldBalance,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newBalance,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.deployedCode,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.value)
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.reverted,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        StorageAccess,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.storageAccesses,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.depth)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <ChainInfo as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainInfo,
                    out,
                );
                <AccountAccessKind as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kind, out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.account,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.accessor,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.initialized,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.oldBalance,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newBalance,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.deployedCode,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.value,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.reverted,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    StorageAccess,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.storageAccesses,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.depth,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct BroadcastTxSummary { bytes32 txHash; BroadcastTxType txType; address contractAddress; uint64 blockNumber; bool success; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BroadcastTxSummary {
        pub txHash: alloy::sol_types::private::FixedBytes<32>,
        pub txType: <BroadcastTxType as alloy::sol_types::SolType>::RustType,
        pub contractAddress: alloy::sol_types::private::Address,
        pub blockNumber: u64,
        pub success: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            BroadcastTxType,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            <BroadcastTxType as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
            u64,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BroadcastTxSummary> for UnderlyingRustTuple<'_> {
            fn from(value: BroadcastTxSummary) -> Self {
                (
                    value.txHash,
                    value.txType,
                    value.contractAddress,
                    value.blockNumber,
                    value.success,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BroadcastTxSummary {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    txHash: tuple.0,
                    txType: tuple.1,
                    contractAddress: tuple.2,
                    blockNumber: tuple.3,
                    success: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BroadcastTxSummary {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BroadcastTxSummary {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txHash),
                    <BroadcastTxType as alloy_sol_types::SolType>::tokenize(
                        &self.txType,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.contractAddress,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.success,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BroadcastTxSummary {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BroadcastTxSummary {
            const NAME: &'static str = "BroadcastTxSummary";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BroadcastTxSummary(bytes32 txHash,uint8 txType,address contractAddress,uint64 blockNumber,bool success)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.txHash)
                        .0,
                    <BroadcastTxType as alloy_sol_types::SolType>::eip712_data_word(
                            &self.txType,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.contractAddress,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockNumber)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.success,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BroadcastTxSummary {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txHash,
                    )
                    + <BroadcastTxType as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.txType,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.contractAddress,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockNumber,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.success,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txHash,
                    out,
                );
                <BroadcastTxType as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.txType,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.contractAddress,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockNumber,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.success,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct ChainInfo { uint256 forkId; uint256 chainId; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChainInfo {
        pub forkId: alloy::sol_types::private::primitives::aliases::U256,
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> =
            (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChainInfo> for UnderlyingRustTuple<'_> {
            fn from(value: ChainInfo) -> Self {
                (value.forkId, value.chainId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChainInfo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { forkId: tuple.0, chainId: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ChainInfo {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ChainInfo {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.forkId,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ChainInfo {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ChainInfo {
            const NAME: &'static str = "ChainInfo";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("ChainInfo(uint256 forkId,uint256 chainId)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.forkId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.chainId)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ChainInfo {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.forkId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.chainId,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.forkId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.chainId,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct DebugStep { uint256[] stack; bytes memoryInput; uint8 opcode; uint64 depth; bool isOutOfGas; address contractAddr; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DebugStep {
        pub stack:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub memoryInput: alloy::sol_types::private::Bytes,
        pub opcode: u8,
        pub depth: u64,
        pub isOutOfGas: bool,
        pub contractAddr: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
            alloy::sol_types::private::Bytes,
            u8,
            u64,
            bool,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DebugStep> for UnderlyingRustTuple<'_> {
            fn from(value: DebugStep) -> Self {
                (
                    value.stack,
                    value.memoryInput,
                    value.opcode,
                    value.depth,
                    value.isOutOfGas,
                    value.contractAddr,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DebugStep {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    stack: tuple.0,
                    memoryInput: tuple.1,
                    opcode: tuple.2,
                    depth: tuple.3,
                    isOutOfGas: tuple.4,
                    contractAddr: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DebugStep {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DebugStep {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.stack),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.memoryInput,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.opcode),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.depth),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isOutOfGas,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.contractAddr,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DebugStep {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DebugStep {
            const NAME: &'static str = "DebugStep";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DebugStep(uint256[] stack,bytes memoryInput,uint8 opcode,uint64 depth,bool isOutOfGas,address contractAddr)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stack)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.memoryInput,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.opcode)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.depth)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isOutOfGas,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.contractAddr,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DebugStep {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.stack)
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.memoryInput,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.opcode,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.depth)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isOutOfGas,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.contractAddr,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<256>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stack,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.memoryInput,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.opcode,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.depth,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isOutOfGas,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.contractAddr,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct DirEntry { string errorMessage; string path; uint64 depth; bool isDir; bool isSymlink; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DirEntry {
        pub errorMessage: alloy::sol_types::private::String,
        pub path: alloy::sol_types::private::String,
        pub depth: u64,
        pub isDir: bool,
        pub isSymlink: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::String,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> =
            (alloy::sol_types::private::String, alloy::sol_types::private::String, u64, bool, bool);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DirEntry> for UnderlyingRustTuple<'_> {
            fn from(value: DirEntry) -> Self {
                (value.errorMessage, value.path, value.depth, value.isDir, value.isSymlink)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DirEntry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    errorMessage: tuple.0,
                    path: tuple.1,
                    depth: tuple.2,
                    isDir: tuple.3,
                    isSymlink: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for DirEntry {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for DirEntry {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.errorMessage,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.depth,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isDir,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isSymlink,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for DirEntry {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for DirEntry {
            const NAME: &'static str = "DirEntry";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "DirEntry(string errorMessage,string path,uint64 depth,bool isDir,bool isSymlink)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.errorMessage,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.path,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.depth)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isDir,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isSymlink,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for DirEntry {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.errorMessage,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.path,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.depth)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isDir,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isSymlink,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.errorMessage,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.path,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.depth,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isDir,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isSymlink,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct EthGetLogs { address emitter; bytes32[] topics; bytes data; bytes32 blockHash; uint64 blockNumber; bytes32 transactionHash; uint64 transactionIndex; uint256 logIndex; bool removed; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EthGetLogs {
        pub emitter: alloy::sol_types::private::Address,
        pub topics: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub data: alloy::sol_types::private::Bytes,
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        pub blockNumber: u64,
        pub transactionHash: alloy::sol_types::private::FixedBytes<32>,
        pub transactionIndex: u64,
        pub logIndex: alloy::sol_types::private::primitives::aliases::U256,
        pub removed: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::FixedBytes<32>,
            u64,
            alloy::sol_types::private::FixedBytes<32>,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EthGetLogs> for UnderlyingRustTuple<'_> {
            fn from(value: EthGetLogs) -> Self {
                (
                    value.emitter,
                    value.topics,
                    value.data,
                    value.blockHash,
                    value.blockNumber,
                    value.transactionHash,
                    value.transactionIndex,
                    value.logIndex,
                    value.removed,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EthGetLogs {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    emitter: tuple.0,
                    topics: tuple.1,
                    data: tuple.2,
                    blockHash: tuple.3,
                    blockNumber: tuple.4,
                    transactionHash: tuple.5,
                    transactionIndex: tuple.6,
                    logIndex: tuple.7,
                    removed: tuple.8,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for EthGetLogs {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for EthGetLogs {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emitter,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.topics),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.transactionHash),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.transactionIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.logIndex),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.removed,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for EthGetLogs {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for EthGetLogs {
            const NAME: &'static str = "EthGetLogs";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "EthGetLogs(address emitter,bytes32[] topics,bytes data,bytes32 blockHash,uint64 blockNumber,bytes32 transactionHash,uint64 transactionIndex,uint256 logIndex,bool removed)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.emitter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.topics)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockHash)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockNumber)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.transactionHash,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.transactionIndex,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.logIndex)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.removed,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for EthGetLogs {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.emitter,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.topics,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockHash,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockNumber,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.transactionHash,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.transactionIndex,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.logIndex,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.removed,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.emitter,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.topics,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockHash,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockNumber,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.transactionHash,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.transactionIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.logIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.removed,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct FfiResult { int32 exitCode; bytes stdout; bytes stderr; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FfiResult {
        pub exitCode: i32,
        pub stdout: alloy::sol_types::private::Bytes,
        pub stderr: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Int<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> =
            (i32, alloy::sol_types::private::Bytes, alloy::sol_types::private::Bytes);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FfiResult> for UnderlyingRustTuple<'_> {
            fn from(value: FfiResult) -> Self {
                (value.exitCode, value.stdout, value.stderr)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FfiResult {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { exitCode: tuple.0, stdout: tuple.1, stderr: tuple.2 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for FfiResult {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for FfiResult {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<32> as alloy_sol_types::SolType>::tokenize(
                        &self.exitCode,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.stdout,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.stderr,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FfiResult {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for FfiResult {
            const NAME: &'static str = "FfiResult";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "FfiResult(int32 exitCode,bytes stdout,bytes stderr)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Int<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.exitCode)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.stdout,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.stderr,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FfiResult {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Int<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exitCode,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stdout,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.stderr,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Int<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exitCode,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stdout,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stderr,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct FsMetadata { bool isDir; bool isSymlink; uint256 length; bool readOnly; uint256 modified; uint256 accessed; uint256 created; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FsMetadata {
        pub isDir: bool,
        pub isSymlink: bool,
        pub length: alloy::sol_types::private::primitives::aliases::U256,
        pub readOnly: bool,
        pub modified: alloy::sol_types::private::primitives::aliases::U256,
        pub accessed: alloy::sol_types::private::primitives::aliases::U256,
        pub created: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            bool,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FsMetadata> for UnderlyingRustTuple<'_> {
            fn from(value: FsMetadata) -> Self {
                (
                    value.isDir,
                    value.isSymlink,
                    value.length,
                    value.readOnly,
                    value.modified,
                    value.accessed,
                    value.created,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FsMetadata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    isDir: tuple.0,
                    isSymlink: tuple.1,
                    length: tuple.2,
                    readOnly: tuple.3,
                    modified: tuple.4,
                    accessed: tuple.5,
                    created: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for FsMetadata {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for FsMetadata {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isDir,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isSymlink,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.length,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.readOnly,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.modified,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.accessed,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.created,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for FsMetadata {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for FsMetadata {
            const NAME: &'static str = "FsMetadata";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "FsMetadata(bool isDir,bool isSymlink,uint256 length,bool readOnly,uint256 modified,uint256 accessed,uint256 created)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isDir,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isSymlink,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.length)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.readOnly,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.modified)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.accessed)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.created)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for FsMetadata {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isDir,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isSymlink,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.length,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.readOnly,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.modified,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.accessed,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.created,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isDir,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isSymlink,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.length,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.readOnly,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.modified,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.accessed,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.created,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct Gas { uint64 gasLimit; uint64 gasTotalUsed; uint64 gasMemoryUsed; int64 gasRefunded; uint64 gasRemaining; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Gas {
        pub gasLimit: u64,
        pub gasTotalUsed: u64,
        pub gasMemoryUsed: u64,
        pub gasRefunded: i64,
        pub gasRemaining: u64,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Int<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, u64, i64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Gas> for UnderlyingRustTuple<'_> {
            fn from(value: Gas) -> Self {
                (
                    value.gasLimit,
                    value.gasTotalUsed,
                    value.gasMemoryUsed,
                    value.gasRefunded,
                    value.gasRemaining,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Gas {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    gasLimit: tuple.0,
                    gasTotalUsed: tuple.1,
                    gasMemoryUsed: tuple.2,
                    gasRefunded: tuple.3,
                    gasRemaining: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Gas {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Gas {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.gasLimit,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.gasTotalUsed,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.gasMemoryUsed,
                    ),
                    <alloy::sol_types::sol_data::Int<64> as alloy_sol_types::SolType>::tokenize(
                        &self.gasRefunded,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.gasRemaining,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Gas {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Gas {
            const NAME: &'static str = "Gas";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Gas(uint64 gasLimit,uint64 gasTotalUsed,uint64 gasMemoryUsed,int64 gasRefunded,uint64 gasRemaining)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasLimit)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasTotalUsed)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasMemoryUsed)
                        .0,
                    <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasRefunded)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.gasRemaining)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Gas {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasLimit,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasTotalUsed,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasMemoryUsed,
                    )
                    + <alloy::sol_types::sol_data::Int<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasRefunded,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.gasRemaining,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasLimit,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasTotalUsed,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasMemoryUsed,
                    out,
                );
                <alloy::sol_types::sol_data::Int<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasRefunded,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.gasRemaining,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct Log { bytes32[] topics; bytes data; address emitter; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Log {
        pub topics: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub data: alloy::sol_types::private::Bytes,
        pub emitter: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Log> for UnderlyingRustTuple<'_> {
            fn from(value: Log) -> Self {
                (value.topics, value.data, value.emitter)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Log {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { topics: tuple.0, data: tuple.1, emitter: tuple.2 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Log {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Log {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.topics),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.emitter,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Log {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Log {
            const NAME: &'static str = "Log";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Log(bytes32[] topics,bytes data,address emitter)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.topics)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.emitter,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Log {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.topics,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.emitter,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.topics,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.emitter,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct Rpc { string key; string url; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Rpc {
        pub key: alloy::sol_types::private::String,
        pub url: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> =
            (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> =
            (alloy::sol_types::private::String, alloy::sol_types::private::String);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Rpc> for UnderlyingRustTuple<'_> {
            fn from(value: Rpc) -> Self {
                (value.key, value.url)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Rpc {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { key: tuple.0, url: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Rpc {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Rpc {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.url,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Rpc {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Rpc {
            const NAME: &'static str = "Rpc";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("Rpc(string key,string url)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.key,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.url,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Rpc {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.key,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.url,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.key,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.url,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct SignedDelegation { uint8 v; bytes32 r; bytes32 s; uint64 nonce; address implementation; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SignedDelegation {
        pub v: u8,
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
        pub nonce: u64,
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            u64,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SignedDelegation> for UnderlyingRustTuple<'_> {
            fn from(value: SignedDelegation) -> Self {
                (value.v, value.r, value.s, value.nonce, value.implementation)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SignedDelegation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { v: tuple.0, r: tuple.1, s: tuple.2, nonce: tuple.3, implementation: tuple.4 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SignedDelegation {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SignedDelegation {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.v),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.r),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SignedDelegation {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SignedDelegation {
            const NAME: &'static str = "SignedDelegation";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SignedDelegation(uint8 v,bytes32 r,bytes32 s,uint64 nonce,address implementation)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.v)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.r)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.s)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.nonce)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.implementation,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SignedDelegation {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.v)
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.r)
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.s)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonce)
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.implementation,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.v, out);
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.r, out);
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.s, out);
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonce,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.implementation,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct StorageAccess { address account; bytes32 slot; bool isWrite; bytes32 previousValue; bytes32 newValue; bool reverted; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StorageAccess {
        pub account: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::FixedBytes<32>,
        pub isWrite: bool,
        pub previousValue: alloy::sol_types::private::FixedBytes<32>,
        pub newValue: alloy::sol_types::private::FixedBytes<32>,
        pub reverted: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
            bool,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StorageAccess> for UnderlyingRustTuple<'_> {
            fn from(value: StorageAccess) -> Self {
                (
                    value.account,
                    value.slot,
                    value.isWrite,
                    value.previousValue,
                    value.newValue,
                    value.reverted,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StorageAccess {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    slot: tuple.1,
                    isWrite: tuple.2,
                    previousValue: tuple.3,
                    newValue: tuple.4,
                    reverted: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for StorageAccess {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for StorageAccess {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isWrite,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousValue),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.newValue),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.reverted,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for StorageAccess {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for StorageAccess {
            const NAME: &'static str = "StorageAccess";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "StorageAccess(address account,bytes32 slot,bool isWrite,bytes32 previousValue,bytes32 newValue,bool reverted)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.account,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.slot)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.isWrite,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.previousValue)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.newValue)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.reverted,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for StorageAccess {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.account,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.slot)
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.isWrite,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.previousValue,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.newValue,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.reverted,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.account,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.slot,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.isWrite,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.previousValue,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.newValue,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.reverted,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**```solidity
    struct Wallet { address addr; uint256 publicKeyX; uint256 publicKeyY; uint256 privateKey; }
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Wallet {
        pub addr: alloy::sol_types::private::Address,
        pub publicKeyX: alloy::sol_types::private::primitives::aliases::U256,
        pub publicKeyY: alloy::sol_types::private::primitives::aliases::U256,
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Wallet> for UnderlyingRustTuple<'_> {
            fn from(value: Wallet) -> Self {
                (value.addr, value.publicKeyX, value.publicKeyY, value.privateKey)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Wallet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    addr: tuple.0,
                    publicKeyX: tuple.1,
                    publicKeyY: tuple.2,
                    privateKey: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Wallet {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Wallet {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.addr,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.publicKeyX,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.publicKeyY,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.privateKey,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Wallet {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Wallet {
            const NAME: &'static str = "Wallet";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Wallet(address addr,uint256 publicKeyX,uint256 publicKeyY,uint256 privateKey)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.addr,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.publicKeyX)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.publicKeyY)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.privateKey)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Wallet {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.addr,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicKeyX,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.publicKeyY,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.privateKey,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.addr,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicKeyX,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.publicKeyY,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.privateKey,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    /**Function with signature `accesses(address)` and selector `0x65bc9481`.
    ```solidity
    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct accessesCall {
        pub target: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`accesses(address)`](accessesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct accessesReturn {
        pub readSlots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub writeSlots: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<accessesCall> for UnderlyingRustTuple<'_> {
                fn from(value: accessesCall) -> Self {
                    (value.target,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for accessesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<accessesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: accessesReturn) -> Self {
                    (value.readSlots, value.writeSlots)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for accessesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { readSlots: tuple.0, writeSlots: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for accessesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = accessesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "accesses(address)";
            const SELECTOR: [u8; 4] = [101u8, 188u8, 148u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.target,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `addr(uint256)` and selector `0xffa18649`.
    ```solidity
    function addr(uint256 privateKey) external pure returns (address keyAddr);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addrCall {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`addr(uint256)`](addrCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addrReturn {
        pub keyAddr: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addrCall> for UnderlyingRustTuple<'_> {
                fn from(value: addrCall) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addrCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addrReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addrReturn) -> Self {
                    (value.keyAddr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addrReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyAddr: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addrCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = addrReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addr(uint256)";
            const SELECTOR: [u8; 4] = [255u8, 161u8, 134u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbs(uint256,uint256,uint256)` and selector `0x16d207c6`.
    ```solidity
    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbs(uint256,uint256,uint256)`](assertApproxEqAbs_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_0Call) -> Self {
                    (value.left, value.right, value.maxDelta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbs_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbs_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqAbs(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [22u8, 210u8, 7u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbs(int256,int256,uint256)` and selector `0x240f839d`.
    ```solidity
    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbs(int256,int256,uint256)`](assertApproxEqAbs_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_1Call) -> Self {
                    (value.left, value.right, value.maxDelta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbs_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbs_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqAbs(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [36u8, 15u8, 131u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbs(int256,int256,uint256,string)` and selector `0x8289e621`.
    ```solidity
    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbs(int256,int256,uint256,string)`](assertApproxEqAbs_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_2Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbs_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbs_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqAbs(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [130u8, 137u8, 230u8, 33u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbs(uint256,uint256,uint256,string)` and selector `0xf710b062`.
    ```solidity
    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbs(uint256,uint256,uint256,string)`](assertApproxEqAbs_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbs_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_3Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbs_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbs_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbs_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbs_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbs_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqAbs(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [247u8, 16u8, 176u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)` and selector `0x045c55ce`.
    ```solidity
    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)`](assertApproxEqAbsDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_0Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2, decimals: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbsDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbsDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [4u8, 92u8, 85u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbsDecimal(int256,int256,uint256,uint256)` and selector `0x3d5bc8bc`.
    ```solidity
    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbsDecimal(int256,int256,uint256,uint256)`](assertApproxEqAbsDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_1Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxDelta: tuple.2, decimals: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbsDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbsDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqAbsDecimal(int256,int256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [61u8, 91u8, 200u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)` and selector `0x60429eb2`.
    ```solidity
    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)`](assertApproxEqAbsDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_2Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxDelta: tuple.2,
                        decimals: tuple.3,
                        error: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbsDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbsDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqAbsDecimal(uint256,uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [96u8, 66u8, 158u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)` and selector `0x6a5066d4`.
    ```solidity
    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)`](assertApproxEqAbsDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqAbsDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_3Call) -> Self {
                    (value.left, value.right, value.maxDelta, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxDelta: tuple.2,
                        decimals: tuple.3,
                        error: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqAbsDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqAbsDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqAbsDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqAbsDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqAbsDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqAbsDecimal(int256,int256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [106u8, 80u8, 102u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRel(uint256,uint256,uint256,string)` and selector `0x1ecb7d33`.
    ```solidity
    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqRel(uint256,uint256,uint256,string)`](assertApproxEqRel_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_0Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxPercentDelta: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRel_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRel_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqRel(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [30u8, 203u8, 125u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRel(uint256,uint256,uint256)` and selector `0x8cf25ef4`.
    ```solidity
    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqRel(uint256,uint256,uint256)`](assertApproxEqRel_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_1Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxPercentDelta: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRel_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRel_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqRel(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [140u8, 242u8, 94u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRel(int256,int256,uint256,string)` and selector `0xef277d72`.
    ```solidity
    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqRel(int256,int256,uint256,string)`](assertApproxEqRel_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_2Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxPercentDelta: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRel_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRel_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqRel(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [239u8, 39u8, 125u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRel(int256,int256,uint256)` and selector `0xfea2d14f`.
    ```solidity
    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqRel(int256,int256,uint256)`](assertApproxEqRel_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRel_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_3Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, maxPercentDelta: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRel_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRel_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRel_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRel_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRel_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertApproxEqRel(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [254u8, 162u8, 209u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)` and selector `0x21ed2977`.
    ```solidity
    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)`](assertApproxEqRelDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_0Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxPercentDelta: tuple.2,
                        decimals: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRelDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRelDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [33u8, 237u8, 41u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)` and selector `0x82d6c8fd`.
    ```solidity
    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)`](assertApproxEqRelDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_1Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxPercentDelta: tuple.2,
                        decimals: tuple.3,
                        error: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRelDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRelDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqRelDecimal(uint256,uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [130u8, 214u8, 200u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRelDecimal(int256,int256,uint256,uint256)` and selector `0xabbf21cc`.
    ```solidity
    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertApproxEqRelDecimal(int256,int256,uint256,uint256)`](assertApproxEqRelDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_2Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxPercentDelta: tuple.2,
                        decimals: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRelDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRelDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqRelDecimal(int256,int256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [171u8, 191u8, 33u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)` and selector `0xfccc11c4`.
    ```solidity
    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)`](assertApproxEqRelDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertApproxEqRelDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_3Call) -> Self {
                    (value.left, value.right, value.maxPercentDelta, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        left: tuple.0,
                        right: tuple.1,
                        maxPercentDelta: tuple.2,
                        decimals: tuple.3,
                        error: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertApproxEqRelDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertApproxEqRelDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertApproxEqRelDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertApproxEqRelDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertApproxEqRelDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "assertApproxEqRelDecimal(int256,int256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [252u8, 204u8, 17u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.maxPercentDelta,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes32[],bytes32[])` and selector `0x0cc9ee84`.
    ```solidity
    function assertEq(bytes32[] memory left, bytes32[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_0Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`assertEq(bytes32[],bytes32[])`](assertEq_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_0Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [12u8, 201u8, 238u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(int256[],int256[],string)` and selector `0x191f1b30`.
    ```solidity
    function assertEq(int256[] memory left, int256[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_1Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(int256[],int256[],string)`](assertEq_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_1Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(int256[],int256[],string)";
            const SELECTOR: [u8; 4] = [25u8, 31u8, 27u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(address,address,string)` and selector `0x2f2769d1`.
    ```solidity
    function assertEq(address left, address right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_2Call {
        pub left: alloy::sol_types::private::Address,
        pub right: alloy::sol_types::private::Address,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(address,address,string)`](assertEq_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_2Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(address,address,string)";
            const SELECTOR: [u8; 4] = [47u8, 39u8, 105u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(string,string,string)` and selector `0x36f656d8`.
    ```solidity
    function assertEq(string memory left, string memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_3Call {
        pub left: alloy::sol_types::private::String,
        pub right: alloy::sol_types::private::String,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(string,string,string)`](assertEq_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_3Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(string,string,string)";
            const SELECTOR: [u8; 4] = [54u8, 246u8, 86u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(address[],address[])` and selector `0x3868ac34`.
    ```solidity
    function assertEq(address[] memory left, address[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_4Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`assertEq(address[],address[])`](assertEq_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_4Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_4Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_4Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_4Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_4Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(address[],address[])";
            const SELECTOR: [u8; 4] = [56u8, 104u8, 172u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(address[],address[],string)` and selector `0x3e9173c5`.
    ```solidity
    function assertEq(address[] memory left, address[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_5Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(address[],address[],string)`](assertEq_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_5Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_5Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_5Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_5Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_5Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(address[],address[],string)";
            const SELECTOR: [u8; 4] = [62u8, 145u8, 115u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bool,bool,string)` and selector `0x4db19e7e`.
    ```solidity
    function assertEq(bool left, bool right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_6Call {
        pub left: bool,
        pub right: bool,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bool,bool,string)`](assertEq_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_6Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_6Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_6Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_6Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_6Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bool,bool,string)";
            const SELECTOR: [u8; 4] = [77u8, 177u8, 158u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(address,address)` and selector `0x515361f6`.
    ```solidity
    function assertEq(address left, address right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_7Call {
        pub left: alloy::sol_types::private::Address,
        pub right: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`assertEq(address,address)`](assertEq_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_7Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_7Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_7Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_7Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_7Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_7Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_7Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(address,address)";
            const SELECTOR: [u8; 4] = [81u8, 83u8, 97u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(uint256[],uint256[],string)` and selector `0x5d18c73a`.
    ```solidity
    function assertEq(uint256[] memory left, uint256[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_8Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(uint256[],uint256[],string)`](assertEq_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_8Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_8Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_8Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_8Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_8Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_8Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_8Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(uint256[],uint256[],string)";
            const SELECTOR: [u8; 4] = [93u8, 24u8, 199u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bool[],bool[])` and selector `0x707df785`.
    ```solidity
    function assertEq(bool[] memory left, bool[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_9Call {
        pub left: alloy::sol_types::private::Vec<bool>,
        pub right: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`assertEq(bool[],bool[])`](assertEq_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_9Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<bool>, alloy::sol_types::private::Vec<bool>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_9Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_9Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_9Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_9Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_9Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_9Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bool[],bool[])";
            const SELECTOR: [u8; 4] = [112u8, 125u8, 247u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(int256[],int256[])` and selector `0x711043ac`.
    ```solidity
    function assertEq(int256[] memory left, int256[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_10Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    ///Container type for the return parameters of the [`assertEq(int256[],int256[])`](assertEq_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_10Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_10Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_10Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_10Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_10Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_10Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_10Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(int256[],int256[])";
            const SELECTOR: [u8; 4] = [113u8, 16u8, 67u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(int256,int256,string)` and selector `0x714a2f13`.
    ```solidity
    function assertEq(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_11Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(int256,int256,string)`](assertEq_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_11Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_11Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_11Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_11Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_11Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_11Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_11Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(int256,int256,string)";
            const SELECTOR: [u8; 4] = [113u8, 74u8, 47u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes32,bytes32)` and selector `0x7c84c69b`.
    ```solidity
    function assertEq(bytes32 left, bytes32 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_12Call {
        pub left: alloy::sol_types::private::FixedBytes<32>,
        pub right: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`assertEq(bytes32,bytes32)`](assertEq_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_12Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_12Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_12Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_12Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_12Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_12Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_12Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [124u8, 132u8, 198u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(uint256,uint256,string)` and selector `0x88b44c85`.
    ```solidity
    function assertEq(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_13Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(uint256,uint256,string)`](assertEq_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_13Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_13Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_13Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_13Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_13Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_13Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_13Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [136u8, 180u8, 76u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(uint256[],uint256[])` and selector `0x975d5a12`.
    ```solidity
    function assertEq(uint256[] memory left, uint256[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_14Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`assertEq(uint256[],uint256[])`](assertEq_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_14Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_14Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_14Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_14Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_14Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_14Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_14Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [151u8, 93u8, 90u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes,bytes)` and selector `0x97624631`.
    ```solidity
    function assertEq(bytes memory left, bytes memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_15Call {
        pub left: alloy::sol_types::private::Bytes,
        pub right: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`assertEq(bytes,bytes)`](assertEq_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_15Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bytes, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Bytes, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_15Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_15Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_15Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_15Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_15Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bytes, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_15Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes,bytes)";
            const SELECTOR: [u8; 4] = [151u8, 98u8, 70u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(uint256,uint256)` and selector `0x98296c54`.
    ```solidity
    function assertEq(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_16Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertEq(uint256,uint256)`](assertEq_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_16Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_16Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_16Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_16Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_16Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_16Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_16Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(uint256,uint256)";
            const SELECTOR: [u8; 4] = [152u8, 41u8, 108u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes32,bytes32,string)` and selector `0xc1fa1ed0`.
    ```solidity
    function assertEq(bytes32 left, bytes32 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_17Call {
        pub left: alloy::sol_types::private::FixedBytes<32>,
        pub right: alloy::sol_types::private::FixedBytes<32>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bytes32,bytes32,string)`](assertEq_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_17Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_17Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_17Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_17Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_17Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_17Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_17Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [193u8, 250u8, 30u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(string[],string[])` and selector `0xcf1c049c`.
    ```solidity
    function assertEq(string[] memory left, string[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_18Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`assertEq(string[],string[])`](assertEq_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_18Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_18Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_18Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_18Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_18Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_18Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_18Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(string[],string[])";
            const SELECTOR: [u8; 4] = [207u8, 28u8, 4u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes32[],bytes32[],string)` and selector `0xe03e9177`.
    ```solidity
    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_19Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bytes32[],bytes32[],string)`](assertEq_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_19Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_19Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_19Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_19Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_19Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_19Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_19Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes32[],bytes32[],string)";
            const SELECTOR: [u8; 4] = [224u8, 62u8, 145u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes,bytes,string)` and selector `0xe24fed00`.
    ```solidity
    function assertEq(bytes memory left, bytes memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_20Call {
        pub left: alloy::sol_types::private::Bytes,
        pub right: alloy::sol_types::private::Bytes,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bytes,bytes,string)`](assertEq_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_20Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_20Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_20Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_20Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_20Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_20Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_20Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes,bytes,string)";
            const SELECTOR: [u8; 4] = [226u8, 79u8, 237u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bool[],bool[],string)` and selector `0xe48a8f8d`.
    ```solidity
    function assertEq(bool[] memory left, bool[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_21Call {
        pub left: alloy::sol_types::private::Vec<bool>,
        pub right: alloy::sol_types::private::Vec<bool>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bool[],bool[],string)`](assertEq_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_21Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<bool>,
                alloy::sol_types::private::Vec<bool>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_21Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_21Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_21Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_21Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_21Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_21Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bool[],bool[],string)";
            const SELECTOR: [u8; 4] = [228u8, 138u8, 143u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes[],bytes[])` and selector `0xe5fb9b4a`.
    ```solidity
    function assertEq(bytes[] memory left, bytes[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_22Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    ///Container type for the return parameters of the [`assertEq(bytes[],bytes[])`](assertEq_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_22Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_22Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_22Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_22Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_22Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_22Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_22Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes[],bytes[])";
            const SELECTOR: [u8; 4] = [229u8, 251u8, 155u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(string[],string[],string)` and selector `0xeff6b27d`.
    ```solidity
    function assertEq(string[] memory left, string[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_23Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(string[],string[],string)`](assertEq_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_23Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_23Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_23Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_23Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_23Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_23Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_23Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(string[],string[],string)";
            const SELECTOR: [u8; 4] = [239u8, 246u8, 178u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(string,string)` and selector `0xf320d963`.
    ```solidity
    function assertEq(string memory left, string memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_24Call {
        pub left: alloy::sol_types::private::String,
        pub right: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(string,string)`](assertEq_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_24Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_24Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_24Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_24Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_24Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_24Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_24Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(string,string)";
            const SELECTOR: [u8; 4] = [243u8, 32u8, 217u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bytes[],bytes[],string)` and selector `0xf413f0b6`.
    ```solidity
    function assertEq(bytes[] memory left, bytes[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_25Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEq(bytes[],bytes[],string)`](assertEq_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_25Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_25Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_25Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_25Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_25Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_25Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_25Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bytes[],bytes[],string)";
            const SELECTOR: [u8; 4] = [244u8, 19u8, 240u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(bool,bool)` and selector `0xf7fe3477`.
    ```solidity
    function assertEq(bool left, bool right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_26Call {
        pub left: bool,
        pub right: bool,
    }
    ///Container type for the return parameters of the [`assertEq(bool,bool)`](assertEq_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_26Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_26Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_26Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_26Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_26Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_26Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_26Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(bool,bool)";
            const SELECTOR: [u8; 4] = [247u8, 254u8, 52u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEq(int256,int256)` and selector `0xfe74f05b`.
    ```solidity
    function assertEq(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_27Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertEq(int256,int256)`](assertEq_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEq_27Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_27Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_27Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEq_27Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEq_27Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEq_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEq_27Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEq_27Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEq(int256,int256)";
            const SELECTOR: [u8; 4] = [254u8, 116u8, 240u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEqDecimal(uint256,uint256,uint256)` and selector `0x27af7d9c`.
    ```solidity
    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertEqDecimal(uint256,uint256,uint256)`](assertEqDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEqDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEqDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEqDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [39u8, 175u8, 125u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEqDecimal(int256,int256,uint256)` and selector `0x48016c04`.
    ```solidity
    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertEqDecimal(int256,int256,uint256)`](assertEqDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEqDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEqDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEqDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [72u8, 1u8, 108u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEqDecimal(int256,int256,uint256,string)` and selector `0x7e77b0c5`.
    ```solidity
    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEqDecimal(int256,int256,uint256,string)`](assertEqDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEqDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEqDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEqDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [126u8, 119u8, 176u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertEqDecimal(uint256,uint256,uint256,string)` and selector `0xd0cbbdef`.
    ```solidity
    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertEqDecimal(uint256,uint256,uint256,string)`](assertEqDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertEqDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertEqDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertEqDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertEqDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertEqDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertEqDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertEqDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [208u8, 203u8, 189u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertFalse(bool,string)` and selector `0x7ba04809`.
    ```solidity
    function assertFalse(bool condition, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertFalse_0Call {
        pub condition: bool,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertFalse(bool,string)`](assertFalse_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertFalse_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertFalse_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertFalse_0Call) -> Self {
                    (value.condition, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertFalse_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { condition: tuple.0, error: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertFalse_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertFalse_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertFalse_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertFalse_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertFalse_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertFalse(bool,string)";
            const SELECTOR: [u8; 4] = [123u8, 160u8, 72u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertFalse(bool)` and selector `0xa5982885`.
    ```solidity
    function assertFalse(bool condition) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertFalse_1Call {
        pub condition: bool,
    }
    ///Container type for the return parameters of the [`assertFalse(bool)`](assertFalse_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertFalse_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertFalse_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertFalse_1Call) -> Self {
                    (value.condition,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertFalse_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { condition: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertFalse_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertFalse_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertFalse_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertFalse_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertFalse_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertFalse(bool)";
            const SELECTOR: [u8; 4] = [165u8, 152u8, 40u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                    &self.condition,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGe(int256,int256)` and selector `0x0a30b771`.
    ```solidity
    function assertGe(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertGe(int256,int256)`](assertGe_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_0Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGe_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGe_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGe(int256,int256)";
            const SELECTOR: [u8; 4] = [10u8, 48u8, 183u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGe(int256,int256,string)` and selector `0xa84328dd`.
    ```solidity
    function assertGe(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGe(int256,int256,string)`](assertGe_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_1Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGe_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGe_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGe(int256,int256,string)";
            const SELECTOR: [u8; 4] = [168u8, 67u8, 40u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGe(uint256,uint256)` and selector `0xa8d4d1d9`.
    ```solidity
    function assertGe(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGe(uint256,uint256)`](assertGe_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_2Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGe_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGe_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGe(uint256,uint256)";
            const SELECTOR: [u8; 4] = [168u8, 212u8, 209u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGe(uint256,uint256,string)` and selector `0xe25242c0`.
    ```solidity
    function assertGe(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGe(uint256,uint256,string)`](assertGe_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGe_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_3Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGe_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGe_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGe_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGe_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGe_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGe(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [226u8, 82u8, 66u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGeDecimal(uint256,uint256,uint256)` and selector `0x3d1fe08a`.
    ```solidity
    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGeDecimal(uint256,uint256,uint256)`](assertGeDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGeDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGeDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGeDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [61u8, 31u8, 224u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGeDecimal(int256,int256,uint256,string)` and selector `0x5df93c9b`.
    ```solidity
    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGeDecimal(int256,int256,uint256,string)`](assertGeDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGeDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGeDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGeDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [93u8, 249u8, 60u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGeDecimal(uint256,uint256,uint256,string)` and selector `0x8bff9133`.
    ```solidity
    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGeDecimal(uint256,uint256,uint256,string)`](assertGeDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGeDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGeDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGeDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [139u8, 255u8, 145u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGeDecimal(int256,int256,uint256)` and selector `0xdc28c0f1`.
    ```solidity
    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGeDecimal(int256,int256,uint256)`](assertGeDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGeDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGeDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGeDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGeDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGeDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGeDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGeDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [220u8, 40u8, 192u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGt(int256,int256)` and selector `0x5a362d45`.
    ```solidity
    function assertGt(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertGt(int256,int256)`](assertGt_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_0Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGt_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGt_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGt(int256,int256)";
            const SELECTOR: [u8; 4] = [90u8, 54u8, 45u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGt(uint256,uint256,string)` and selector `0xd9a3c4d2`.
    ```solidity
    function assertGt(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGt(uint256,uint256,string)`](assertGt_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_1Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGt_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGt_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGt(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [217u8, 163u8, 196u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGt(uint256,uint256)` and selector `0xdb07fcd2`.
    ```solidity
    function assertGt(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGt(uint256,uint256)`](assertGt_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_2Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGt_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGt_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGt(uint256,uint256)";
            const SELECTOR: [u8; 4] = [219u8, 7u8, 252u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGt(int256,int256,string)` and selector `0xf8d33b9b`.
    ```solidity
    function assertGt(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGt(int256,int256,string)`](assertGt_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGt_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_3Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGt_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGt_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGt_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGt_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGt_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGt(int256,int256,string)";
            const SELECTOR: [u8; 4] = [248u8, 211u8, 59u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGtDecimal(int256,int256,uint256,string)` and selector `0x04a5c7ab`.
    ```solidity
    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGtDecimal(int256,int256,uint256,string)`](assertGtDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGtDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGtDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGtDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [4u8, 165u8, 199u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGtDecimal(uint256,uint256,uint256,string)` and selector `0x64949a8d`.
    ```solidity
    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertGtDecimal(uint256,uint256,uint256,string)`](assertGtDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGtDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGtDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGtDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [100u8, 148u8, 154u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGtDecimal(int256,int256,uint256)` and selector `0x78611f0e`.
    ```solidity
    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGtDecimal(int256,int256,uint256)`](assertGtDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGtDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGtDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGtDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [120u8, 97u8, 31u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertGtDecimal(uint256,uint256,uint256)` and selector `0xeccd2437`.
    ```solidity
    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertGtDecimal(uint256,uint256,uint256)`](assertGtDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertGtDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertGtDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertGtDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertGtDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertGtDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertGtDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertGtDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [236u8, 205u8, 36u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLe(int256,int256,string)` and selector `0x4dfe692c`.
    ```solidity
    function assertLe(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLe(int256,int256,string)`](assertLe_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_0Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLe_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLe_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLe(int256,int256,string)";
            const SELECTOR: [u8; 4] = [77u8, 254u8, 105u8, 44u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLe(uint256,uint256)` and selector `0x8466f415`.
    ```solidity
    function assertLe(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLe(uint256,uint256)`](assertLe_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_1Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLe_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLe_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLe(uint256,uint256)";
            const SELECTOR: [u8; 4] = [132u8, 102u8, 244u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLe(int256,int256)` and selector `0x95fd154e`.
    ```solidity
    function assertLe(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertLe(int256,int256)`](assertLe_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_2Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLe_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLe_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLe(int256,int256)";
            const SELECTOR: [u8; 4] = [149u8, 253u8, 21u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLe(uint256,uint256,string)` and selector `0xd17d4b0d`.
    ```solidity
    function assertLe(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLe(uint256,uint256,string)`](assertLe_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLe_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_3Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLe_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLe_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLe_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLe_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLe_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLe(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [209u8, 125u8, 75u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLeDecimal(int256,int256,uint256)` and selector `0x11d1364a`.
    ```solidity
    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLeDecimal(int256,int256,uint256)`](assertLeDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLeDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLeDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLeDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [17u8, 209u8, 54u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLeDecimal(uint256,uint256,uint256,string)` and selector `0x7fefbbe0`.
    ```solidity
    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLeDecimal(uint256,uint256,uint256,string)`](assertLeDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLeDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLeDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLeDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [127u8, 239u8, 187u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLeDecimal(int256,int256,uint256,string)` and selector `0xaa5cf788`.
    ```solidity
    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLeDecimal(int256,int256,uint256,string)`](assertLeDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLeDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLeDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLeDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [170u8, 92u8, 247u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLeDecimal(uint256,uint256,uint256)` and selector `0xc304aab7`.
    ```solidity
    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLeDecimal(uint256,uint256,uint256)`](assertLeDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLeDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLeDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLeDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLeDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLeDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLeDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLeDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [195u8, 4u8, 170u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLt(int256,int256)` and selector `0x3e914080`.
    ```solidity
    function assertLt(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertLt(int256,int256)`](assertLt_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_0Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLt_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLt_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLt(int256,int256)";
            const SELECTOR: [u8; 4] = [62u8, 145u8, 64u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLt(uint256,uint256,string)` and selector `0x65d5c135`.
    ```solidity
    function assertLt(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLt(uint256,uint256,string)`](assertLt_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_1Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLt_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLt_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLt(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [101u8, 213u8, 193u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLt(int256,int256,string)` and selector `0x9ff531e3`.
    ```solidity
    function assertLt(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLt(int256,int256,string)`](assertLt_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_2Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLt_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLt_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLt(int256,int256,string)";
            const SELECTOR: [u8; 4] = [159u8, 245u8, 49u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLt(uint256,uint256)` and selector `0xb12fc005`.
    ```solidity
    function assertLt(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLt(uint256,uint256)`](assertLt_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLt_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_3Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLt_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLt_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLt_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLt_3Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLt_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLt(uint256,uint256)";
            const SELECTOR: [u8; 4] = [177u8, 47u8, 192u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLtDecimal(uint256,uint256,uint256)` and selector `0x2077337e`.
    ```solidity
    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLtDecimal(uint256,uint256,uint256)`](assertLtDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLtDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLtDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLtDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [32u8, 119u8, 51u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLtDecimal(int256,int256,uint256,string)` and selector `0x40f0b4e0`.
    ```solidity
    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLtDecimal(int256,int256,uint256,string)`](assertLtDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLtDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLtDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLtDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [64u8, 240u8, 180u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLtDecimal(uint256,uint256,uint256,string)` and selector `0xa972d037`.
    ```solidity
    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertLtDecimal(uint256,uint256,uint256,string)`](assertLtDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLtDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLtDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLtDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [169u8, 114u8, 208u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertLtDecimal(int256,int256,uint256)` and selector `0xdbe8d88b`.
    ```solidity
    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertLtDecimal(int256,int256,uint256)`](assertLtDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertLtDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertLtDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertLtDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertLtDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertLtDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertLtDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertLtDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [219u8, 232u8, 216u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes32[],bytes32[])` and selector `0x0603ea68`.
    ```solidity
    function assertNotEq(bytes32[] memory left, bytes32[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_0Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes32[],bytes32[])`](assertNotEq_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_0Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes32[],bytes32[])";
            const SELECTOR: [u8; 4] = [6u8, 3u8, 234u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(int256[],int256[])` and selector `0x0b72f4ef`.
    ```solidity
    function assertNotEq(int256[] memory left, int256[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_1Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    ///Container type for the return parameters of the [`assertNotEq(int256[],int256[])`](assertNotEq_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_1Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(int256[],int256[])";
            const SELECTOR: [u8; 4] = [11u8, 114u8, 244u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bool,bool,string)` and selector `0x1091a261`.
    ```solidity
    function assertNotEq(bool left, bool right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_2Call {
        pub left: bool,
        pub right: bool,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bool,bool,string)`](assertNotEq_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_2Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bool,bool,string)";
            const SELECTOR: [u8; 4] = [16u8, 145u8, 162u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes[],bytes[],string)` and selector `0x1dcd1f68`.
    ```solidity
    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_3Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes[],bytes[],string)`](assertNotEq_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_3Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes[],bytes[],string)";
            const SELECTOR: [u8; 4] = [29u8, 205u8, 31u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bool,bool)` and selector `0x236e4d66`.
    ```solidity
    function assertNotEq(bool left, bool right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_4Call {
        pub left: bool,
        pub right: bool,
    }
    ///Container type for the return parameters of the [`assertNotEq(bool,bool)`](assertNotEq_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_4Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_4Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_4Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_4Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_4Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bool,bool)";
            const SELECTOR: [u8; 4] = [35u8, 110u8, 77u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bool[],bool[])` and selector `0x286fafea`.
    ```solidity
    function assertNotEq(bool[] memory left, bool[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_5Call {
        pub left: alloy::sol_types::private::Vec<bool>,
        pub right: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`assertNotEq(bool[],bool[])`](assertNotEq_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_5Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<bool>, alloy::sol_types::private::Vec<bool>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_5Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_5Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_5Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_5Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bool[],bool[])";
            const SELECTOR: [u8; 4] = [40u8, 111u8, 175u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes,bytes)` and selector `0x3cf78e28`.
    ```solidity
    function assertNotEq(bytes memory left, bytes memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_6Call {
        pub left: alloy::sol_types::private::Bytes,
        pub right: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes,bytes)`](assertNotEq_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_6Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bytes, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Bytes, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_6Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_6Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_6Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bytes, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_6Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes,bytes)";
            const SELECTOR: [u8; 4] = [60u8, 247u8, 142u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(address[],address[])` and selector `0x46d0b252`.
    ```solidity
    function assertNotEq(address[] memory left, address[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_7Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`assertNotEq(address[],address[])`](assertNotEq_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_7Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_7Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_7Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_7Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_7Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_7Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_7Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(address[],address[])";
            const SELECTOR: [u8; 4] = [70u8, 208u8, 178u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(int256,int256,string)` and selector `0x4724c5b9`.
    ```solidity
    function assertNotEq(int256 left, int256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_8Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(int256,int256,string)`](assertNotEq_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_8Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_8Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_8Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_8Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_8Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_8Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_8Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(int256,int256,string)";
            const SELECTOR: [u8; 4] = [71u8, 36u8, 197u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(uint256[],uint256[])` and selector `0x56f29cba`.
    ```solidity
    function assertNotEq(uint256[] memory left, uint256[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_9Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`assertNotEq(uint256[],uint256[])`](assertNotEq_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_9Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_9Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_9Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_9Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_9Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_9Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_9Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(uint256[],uint256[])";
            const SELECTOR: [u8; 4] = [86u8, 242u8, 156u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bool[],bool[],string)` and selector `0x62c6f9fb`.
    ```solidity
    function assertNotEq(bool[] memory left, bool[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_10Call {
        pub left: alloy::sol_types::private::Vec<bool>,
        pub right: alloy::sol_types::private::Vec<bool>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bool[],bool[],string)`](assertNotEq_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_10Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<bool>,
                alloy::sol_types::private::Vec<bool>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_10Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_10Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_10Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_10Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_10Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_10Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bool[],bool[],string)";
            const SELECTOR: [u8; 4] = [98u8, 198u8, 249u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(string,string)` and selector `0x6a8237b3`.
    ```solidity
    function assertNotEq(string memory left, string memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_11Call {
        pub left: alloy::sol_types::private::String,
        pub right: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(string,string)`](assertNotEq_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_11Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_11Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_11Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_11Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_11Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_11Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_11Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(string,string)";
            const SELECTOR: [u8; 4] = [106u8, 130u8, 55u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(address[],address[],string)` and selector `0x72c7e0b5`.
    ```solidity
    function assertNotEq(address[] memory left, address[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_12Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(address[],address[],string)`](assertNotEq_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_12Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_12Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_12Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_12Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_12Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_12Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_12Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(address[],address[],string)";
            const SELECTOR: [u8; 4] = [114u8, 199u8, 224u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(string,string,string)` and selector `0x78bdcea7`.
    ```solidity
    function assertNotEq(string memory left, string memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_13Call {
        pub left: alloy::sol_types::private::String,
        pub right: alloy::sol_types::private::String,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(string,string,string)`](assertNotEq_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_13Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_13Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_13Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_13Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_13Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_13Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_13Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(string,string,string)";
            const SELECTOR: [u8; 4] = [120u8, 189u8, 206u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(address,address,string)` and selector `0x8775a591`.
    ```solidity
    function assertNotEq(address left, address right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_14Call {
        pub left: alloy::sol_types::private::Address,
        pub right: alloy::sol_types::private::Address,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(address,address,string)`](assertNotEq_14Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_14Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_14Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_14Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_14Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_14Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_14Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_14Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_14Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_14Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(address,address,string)";
            const SELECTOR: [u8; 4] = [135u8, 117u8, 165u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes32,bytes32)` and selector `0x898e83fc`.
    ```solidity
    function assertNotEq(bytes32 left, bytes32 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_15Call {
        pub left: alloy::sol_types::private::FixedBytes<32>,
        pub right: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes32,bytes32)`](assertNotEq_15Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_15Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_15Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_15Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_15Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_15Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_15Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_15Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_15Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_15Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [137u8, 142u8, 131u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes,bytes,string)` and selector `0x9507540e`.
    ```solidity
    function assertNotEq(bytes memory left, bytes memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_16Call {
        pub left: alloy::sol_types::private::Bytes,
        pub right: alloy::sol_types::private::Bytes,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes,bytes,string)`](assertNotEq_16Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_16Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_16Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_16Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_16Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_16Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_16Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_16Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_16Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_16Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes,bytes,string)";
            const SELECTOR: [u8; 4] = [149u8, 7u8, 84u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(uint256,uint256,string)` and selector `0x98f9bdbd`.
    ```solidity
    function assertNotEq(uint256 left, uint256 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_17Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(uint256,uint256,string)`](assertNotEq_17Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_17Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_17Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_17Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_17Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_17Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_17Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_17Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_17Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_17Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [152u8, 249u8, 189u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(uint256[],uint256[],string)` and selector `0x9a7fbd8f`.
    ```solidity
    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_18Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(uint256[],uint256[],string)`](assertNotEq_18Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_18Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_18Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_18Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_18Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_18Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_18Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_18Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_18Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_18Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(uint256[],uint256[],string)";
            const SELECTOR: [u8; 4] = [154u8, 127u8, 189u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(address,address)` and selector `0xb12e1694`.
    ```solidity
    function assertNotEq(address left, address right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_19Call {
        pub left: alloy::sol_types::private::Address,
        pub right: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`assertNotEq(address,address)`](assertNotEq_19Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_19Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_19Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_19Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_19Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_19Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_19Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_19Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_19Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_19Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(address,address)";
            const SELECTOR: [u8; 4] = [177u8, 46u8, 22u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes32,bytes32,string)` and selector `0xb2332f51`.
    ```solidity
    function assertNotEq(bytes32 left, bytes32 right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_20Call {
        pub left: alloy::sol_types::private::FixedBytes<32>,
        pub right: alloy::sol_types::private::FixedBytes<32>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes32,bytes32,string)`](assertNotEq_20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_20Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_20Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_20Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_20Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_20Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_20Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_20Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes32,bytes32,string)";
            const SELECTOR: [u8; 4] = [178u8, 51u8, 47u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(string[],string[],string)` and selector `0xb67187f3`.
    ```solidity
    function assertNotEq(string[] memory left, string[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_21Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(string[],string[],string)`](assertNotEq_21Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_21Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_21Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_21Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_21Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_21Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_21Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_21Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_21Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_21Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(string[],string[],string)";
            const SELECTOR: [u8; 4] = [182u8, 113u8, 135u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(uint256,uint256)` and selector `0xb7909320`.
    ```solidity
    function assertNotEq(uint256 left, uint256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_22Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertNotEq(uint256,uint256)`](assertNotEq_22Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_22Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_22Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_22Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_22Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_22Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_22Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_22Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_22Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_22Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(uint256,uint256)";
            const SELECTOR: [u8; 4] = [183u8, 144u8, 147u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes32[],bytes32[],string)` and selector `0xb873634c`.
    ```solidity
    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_23Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes32[],bytes32[],string)`](assertNotEq_23Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_23Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_23Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_23Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_23Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_23Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_23Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_23Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_23Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_23Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes32[],bytes32[],string)";
            const SELECTOR: [u8; 4] = [184u8, 115u8, 99u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(string[],string[])` and selector `0xbdfacbe8`.
    ```solidity
    function assertNotEq(string[] memory left, string[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_24Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`assertNotEq(string[],string[])`](assertNotEq_24Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_24Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_24Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_24Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_24Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_24Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_24Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_24Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_24Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_24Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(string[],string[])";
            const SELECTOR: [u8; 4] = [189u8, 250u8, 203u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(int256[],int256[],string)` and selector `0xd3977322`.
    ```solidity
    function assertNotEq(int256[] memory left, int256[] memory right, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_25Call {
        pub left:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub right:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEq(int256[],int256[],string)`](assertNotEq_25Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_25Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_25Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_25Call) -> Self {
                    (value.left, value.right, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_25Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, error: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_25Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_25Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_25Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_25Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_25Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(int256[],int256[],string)";
            const SELECTOR: [u8; 4] = [211u8, 151u8, 115u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(bytes[],bytes[])` and selector `0xedecd035`.
    ```solidity
    function assertNotEq(bytes[] memory left, bytes[] memory right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_26Call {
        pub left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        pub right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    ///Container type for the return parameters of the [`assertNotEq(bytes[],bytes[])`](assertNotEq_26Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_26Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_26Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_26Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_26Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_26Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_26Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_26Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_26Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_26Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(bytes[],bytes[])";
            const SELECTOR: [u8; 4] = [237u8, 236u8, 208u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.left),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.right),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEq(int256,int256)` and selector `0xf4c004e3`.
    ```solidity
    function assertNotEq(int256 left, int256 right) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_27Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`assertNotEq(int256,int256)`](assertNotEq_27Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEq_27Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_27Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_27Call) -> Self {
                    (value.left, value.right)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_27Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEq_27Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEq_27Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEq_27Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEq_27Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Int<256>, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEq_27Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEq(int256,int256)";
            const SELECTOR: [u8; 4] = [244u8, 192u8, 4u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEqDecimal(int256,int256,uint256)` and selector `0x14e75680`.
    ```solidity
    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_0Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertNotEqDecimal(int256,int256,uint256)`](assertNotEqDecimal_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_0Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEqDecimal_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEqDecimal_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEqDecimal(int256,int256,uint256)";
            const SELECTOR: [u8; 4] = [20u8, 231u8, 86u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEqDecimal(int256,int256,uint256,string)` and selector `0x33949f0b`.
    ```solidity
    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_1Call {
        pub left: alloy::sol_types::private::primitives::aliases::I256,
        pub right: alloy::sol_types::private::primitives::aliases::I256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEqDecimal(int256,int256,uint256,string)`](assertNotEqDecimal_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::I256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_1Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEqDecimal_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEqDecimal_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEqDecimal(int256,int256,uint256,string)";
            const SELECTOR: [u8; 4] = [51u8, 148u8, 159u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEqDecimal(uint256,uint256,uint256)` and selector `0x669efca7`.
    ```solidity
    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_2Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`assertNotEqDecimal(uint256,uint256,uint256)`](assertNotEqDecimal_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_2Call) -> Self {
                    (value.left, value.right, value.decimals)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEqDecimal_2Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEqDecimal_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEqDecimal(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [102u8, 158u8, 252u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertNotEqDecimal(uint256,uint256,uint256,string)` and selector `0xf5a55558`.
    ```solidity
    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_3Call {
        pub left: alloy::sol_types::private::primitives::aliases::U256,
        pub right: alloy::sol_types::private::primitives::aliases::U256,
        pub decimals: alloy::sol_types::private::primitives::aliases::U256,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertNotEqDecimal(uint256,uint256,uint256,string)`](assertNotEqDecimal_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertNotEqDecimal_3Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_3Call) -> Self {
                    (value.left, value.right, value.decimals, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { left: tuple.0, right: tuple.1, decimals: tuple.2, error: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertNotEqDecimal_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertNotEqDecimal_3Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertNotEqDecimal_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertNotEqDecimal_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertNotEqDecimal_3Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertNotEqDecimal(uint256,uint256,uint256,string)";
            const SELECTOR: [u8; 4] = [245u8, 165u8, 85u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.left,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.right,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.decimals,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertTrue(bool)` and selector `0x0c9fd581`.
    ```solidity
    function assertTrue(bool condition) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertTrue_0Call {
        pub condition: bool,
    }
    ///Container type for the return parameters of the [`assertTrue(bool)`](assertTrue_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertTrue_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertTrue_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertTrue_0Call) -> Self {
                    (value.condition,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertTrue_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { condition: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertTrue_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertTrue_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertTrue_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertTrue_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertTrue_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertTrue(bool)";
            const SELECTOR: [u8; 4] = [12u8, 159u8, 213u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                    &self.condition,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assertTrue(bool,string)` and selector `0xa34edc03`.
    ```solidity
    function assertTrue(bool condition, string memory error) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertTrue_1Call {
        pub condition: bool,
        pub error: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`assertTrue(bool,string)`](assertTrue_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assertTrue_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertTrue_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: assertTrue_1Call) -> Self {
                    (value.condition, value.error)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertTrue_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { condition: tuple.0, error: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assertTrue_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: assertTrue_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assertTrue_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assertTrue_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Bool, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assertTrue_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assertTrue(bool,string)";
            const SELECTOR: [u8; 4] = [163u8, 78u8, 220u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.condition,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.error,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assume(bool)` and selector `0x4c63e562`.
    ```solidity
    function assume(bool condition) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assumeCall {
        pub condition: bool,
    }
    ///Container type for the return parameters of the [`assume(bool)`](assumeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assumeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assumeCall> for UnderlyingRustTuple<'_> {
                fn from(value: assumeCall) -> Self {
                    (value.condition,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assumeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { condition: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assumeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: assumeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assumeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assumeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assumeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assume(bool)";
            const SELECTOR: [u8; 4] = [76u8, 99u8, 229u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                    &self.condition,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `assumeNoRevert()` and selector `0x285b366a`.
    ```solidity
    function assumeNoRevert() external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assumeNoRevertCall {}
    ///Container type for the return parameters of the [`assumeNoRevert()`](assumeNoRevertCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct assumeNoRevertReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assumeNoRevertCall> for UnderlyingRustTuple<'_> {
                fn from(value: assumeNoRevertCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assumeNoRevertCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<assumeNoRevertReturn> for UnderlyingRustTuple<'_> {
                fn from(value: assumeNoRevertReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for assumeNoRevertReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for assumeNoRevertCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = assumeNoRevertReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "assumeNoRevert()";
            const SELECTOR: [u8; 4] = [40u8, 91u8, 54u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `attachDelegation((uint8,bytes32,bytes32,uint64,address))` and selector `0x14ae3519`.
    ```solidity
    function attachDelegation(SignedDelegation memory signedDelegation) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct attachDelegationCall {
        pub signedDelegation: <SignedDelegation as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`attachDelegation((uint8,bytes32,bytes32,uint64,address))`](attachDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct attachDelegationReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SignedDelegation,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<SignedDelegation as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<attachDelegationCall> for UnderlyingRustTuple<'_> {
                fn from(value: attachDelegationCall) -> Self {
                    (value.signedDelegation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for attachDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signedDelegation: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<attachDelegationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: attachDelegationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for attachDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for attachDelegationCall {
            type Parameters<'a> = (SignedDelegation,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = attachDelegationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "attachDelegation((uint8,bytes32,bytes32,uint64,address))";
            const SELECTOR: [u8; 4] = [20u8, 174u8, 53u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<SignedDelegation as alloy_sol_types::SolType>::tokenize(&self.signedDelegation),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `breakpoint(string)` and selector `0xf0259e92`.
    ```solidity
    function breakpoint(string memory char) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct breakpoint_0Call {
        pub char: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`breakpoint(string)`](breakpoint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct breakpoint_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<breakpoint_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: breakpoint_0Call) -> Self {
                    (value.char,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for breakpoint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { char: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<breakpoint_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: breakpoint_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for breakpoint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for breakpoint_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = breakpoint_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "breakpoint(string)";
            const SELECTOR: [u8; 4] = [240u8, 37u8, 158u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.char,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `breakpoint(string,bool)` and selector `0xf7d39a8d`.
    ```solidity
    function breakpoint(string memory char, bool value) external pure;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct breakpoint_1Call {
        pub char: alloy::sol_types::private::String,
        pub value: bool,
    }
    ///Container type for the return parameters of the [`breakpoint(string,bool)`](breakpoint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct breakpoint_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<breakpoint_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: breakpoint_1Call) -> Self {
                    (value.char, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for breakpoint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { char: tuple.0, value: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<breakpoint_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: breakpoint_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for breakpoint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for breakpoint_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = breakpoint_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "breakpoint(string,bool)";
            const SELECTOR: [u8; 4] = [247u8, 211u8, 154u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.char,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `broadcast()` and selector `0xafc98040`.
    ```solidity
    function broadcast() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_0Call {}
    ///Container type for the return parameters of the [`broadcast()`](broadcast_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for broadcast_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = broadcast_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "broadcast()";
            const SELECTOR: [u8; 4] = [175u8, 201u8, 128u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `broadcast(address)` and selector `0xe6962cdb`.
    ```solidity
    function broadcast(address signer) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_1Call {
        pub signer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`broadcast(address)`](broadcast_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_1Call) -> Self {
                    (value.signer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for broadcast_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = broadcast_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "broadcast(address)";
            const SELECTOR: [u8; 4] = [230u8, 150u8, 44u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.signer,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `broadcast(uint256)` and selector `0xf67a965b`.
    ```solidity
    function broadcast(uint256 privateKey) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_2Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`broadcast(uint256)`](broadcast_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcast_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_2Call) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcast_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: broadcast_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcast_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for broadcast_2Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = broadcast_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "broadcast(uint256)";
            const SELECTOR: [u8; 4] = [246u8, 122u8, 150u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `broadcastRawTransaction(bytes)` and selector `0x8c0c72e0`.
    ```solidity
    function broadcastRawTransaction(bytes memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcastRawTransactionCall {
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`broadcastRawTransaction(bytes)`](broadcastRawTransactionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct broadcastRawTransactionReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcastRawTransactionCall> for UnderlyingRustTuple<'_> {
                fn from(value: broadcastRawTransactionCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcastRawTransactionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<broadcastRawTransactionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: broadcastRawTransactionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for broadcastRawTransactionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for broadcastRawTransactionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = broadcastRawTransactionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "broadcastRawTransaction(bytes)";
            const SELECTOR: [u8; 4] = [140u8, 12u8, 114u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.data,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `closeFile(string)` and selector `0x48c3241f`.
    ```solidity
    function closeFile(string memory path) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeFileCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`closeFile(string)`](closeFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeFileReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: closeFileCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: closeFileReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeFileCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeFileReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeFile(string)";
            const SELECTOR: [u8; 4] = [72u8, 195u8, 36u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `computeCreate2Address(bytes32,bytes32)` and selector `0x890c283b`.
    ```solidity
    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreate2Address_0Call {
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        pub initCodeHash: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`computeCreate2Address(bytes32,bytes32)`](computeCreate2Address_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreate2Address_0Return {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreate2Address_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreate2Address_0Call) -> Self {
                    (value.salt, value.initCodeHash)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreate2Address_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { salt: tuple.0, initCodeHash: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreate2Address_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreate2Address_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreate2Address_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeCreate2Address_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = computeCreate2Address_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeCreate2Address(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [137u8, 12u8, 40u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initCodeHash),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `computeCreate2Address(bytes32,bytes32,address)` and selector `0xd323826a`.
    ```solidity
    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer) external pure returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreate2Address_1Call {
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        pub initCodeHash: alloy::sol_types::private::FixedBytes<32>,
        pub deployer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`computeCreate2Address(bytes32,bytes32,address)`](computeCreate2Address_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreate2Address_1Return {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreate2Address_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreate2Address_1Call) -> Self {
                    (value.salt, value.initCodeHash, value.deployer)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreate2Address_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { salt: tuple.0, initCodeHash: tuple.1, deployer: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreate2Address_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreate2Address_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreate2Address_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeCreate2Address_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = computeCreate2Address_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeCreate2Address(bytes32,bytes32,address)";
            const SELECTOR: [u8; 4] = [211u8, 35u8, 130u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initCodeHash),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `computeCreateAddress(address,uint256)` and selector `0x74637a7a`.
    ```solidity
    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreateAddressCall {
        pub deployer: alloy::sol_types::private::Address,
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`computeCreateAddress(address,uint256)`](computeCreateAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct computeCreateAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreateAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreateAddressCall) -> Self {
                    (value.deployer, value.nonce)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreateAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployer: tuple.0, nonce: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<computeCreateAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: computeCreateAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for computeCreateAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for computeCreateAddressCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = computeCreateAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "computeCreateAddress(address,uint256)";
            const SELECTOR: [u8; 4] = [116u8, 99u8, 122u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.deployer,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.nonce,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `contains(string,string)` and selector `0x3fb18aec`.
    ```solidity
    function contains(string memory subject, string memory search) external returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsCall {
        pub subject: alloy::sol_types::private::String,
        pub search: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`contains(string,string)`](containsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct containsReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsCall> for UnderlyingRustTuple<'_> {
                fn from(value: containsCall) -> Self {
                    (value.subject, value.search)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { subject: tuple.0, search: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<containsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: containsReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for containsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for containsCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = containsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "contains(string,string)";
            const SELECTOR: [u8; 4] = [63u8, 177u8, 138u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.subject,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.search,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `copyFile(string,string)` and selector `0xa54a87d8`.
    ```solidity
    function copyFile(string memory from, string memory to) external returns (uint64 copied);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct copyFileCall {
        pub from: alloy::sol_types::private::String,
        pub to: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`copyFile(string,string)`](copyFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct copyFileReturn {
        pub copied: u64,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<copyFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: copyFileCall) -> Self {
                    (value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for copyFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<copyFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: copyFileReturn) -> Self {
                    (value.copied,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for copyFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { copied: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for copyFileCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = copyFileReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "copyFile(string,string)";
            const SELECTOR: [u8; 4] = [165u8, 74u8, 135u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `copyStorage(address,address)` and selector `0x203dac0d`.
    ```solidity
    function copyStorage(address from, address to) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct copyStorageCall {
        pub from: alloy::sol_types::private::Address,
        pub to: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`copyStorage(address,address)`](copyStorageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct copyStorageReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<copyStorageCall> for UnderlyingRustTuple<'_> {
                fn from(value: copyStorageCall) -> Self {
                    (value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for copyStorageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<copyStorageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: copyStorageReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for copyStorageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for copyStorageCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = copyStorageReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "copyStorage(address,address)";
            const SELECTOR: [u8; 4] = [32u8, 61u8, 172u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `createDir(string,bool)` and selector `0x168b64d3`.
    ```solidity
    function createDir(string memory path, bool recursive) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createDirCall {
        pub path: alloy::sol_types::private::String,
        pub recursive: bool,
    }
    ///Container type for the return parameters of the [`createDir(string,bool)`](createDirCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createDirReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createDirCall> for UnderlyingRustTuple<'_> {
                fn from(value: createDirCall) -> Self {
                    (value.path, value.recursive)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createDirCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, recursive: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createDirReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createDirReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createDirReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createDirCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createDirReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createDir(string,bool)";
            const SELECTOR: [u8; 4] = [22u8, 139u8, 100u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.recursive,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `createWallet(string)` and selector `0x7404f1d2`.
    ```solidity
    function createWallet(string memory walletLabel) external returns (Wallet memory wallet);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_0Call {
        pub walletLabel: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`createWallet(string)`](createWallet_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_0Return {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_0Call) -> Self {
                    (value.walletLabel,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { walletLabel: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Wallet as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_0Return) -> Self {
                    (value.wallet,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createWallet_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createWallet_0Return;
            type ReturnTuple<'a> = (Wallet,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createWallet(string)";
            const SELECTOR: [u8; 4] = [116u8, 4u8, 241u8, 210u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.walletLabel,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `createWallet(uint256)` and selector `0x7a675bb6`.
    ```solidity
    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_1Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`createWallet(uint256)`](createWallet_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_1Return {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_1Call) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Wallet as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_1Return) -> Self {
                    (value.wallet,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createWallet_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createWallet_1Return;
            type ReturnTuple<'a> = (Wallet,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createWallet(uint256)";
            const SELECTOR: [u8; 4] = [122u8, 103u8, 91u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `createWallet(uint256,string)` and selector `0xed7c5462`.
    ```solidity
    function createWallet(uint256 privateKey, string memory walletLabel) external returns (Wallet memory wallet);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_2Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
        pub walletLabel: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`createWallet(uint256,string)`](createWallet_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createWallet_2Return {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_2Call) -> Self {
                    (value.privateKey, value.walletLabel)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0, walletLabel: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Wallet as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createWallet_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: createWallet_2Return) -> Self {
                    (value.wallet,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createWallet_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createWallet_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createWallet_2Return;
            type ReturnTuple<'a> = (Wallet,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createWallet(uint256,string)";
            const SELECTOR: [u8; 4] = [237u8, 124u8, 84u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.privateKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.walletLabel,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deployCode(string,bytes)` and selector `0x29ce9dde`.
    ```solidity
    function deployCode(string memory artifactPath, bytes memory constructorArgs) external returns (address deployedAddress);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployCode_0Call {
        pub artifactPath: alloy::sol_types::private::String,
        pub constructorArgs: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`deployCode(string,bytes)`](deployCode_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployCode_0Return {
        pub deployedAddress: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployCode_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: deployCode_0Call) -> Self {
                    (value.artifactPath, value.constructorArgs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployCode_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { artifactPath: tuple.0, constructorArgs: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployCode_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: deployCode_0Return) -> Self {
                    (value.deployedAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployCode_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deployCode_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deployCode_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deployCode(string,bytes)";
            const SELECTOR: [u8; 4] = [41u8, 206u8, 157u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.artifactPath,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.constructorArgs,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deployCode(string)` and selector `0x9a8325a0`.
    ```solidity
    function deployCode(string memory artifactPath) external returns (address deployedAddress);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployCode_1Call {
        pub artifactPath: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`deployCode(string)`](deployCode_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deployCode_1Return {
        pub deployedAddress: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployCode_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: deployCode_1Call) -> Self {
                    (value.artifactPath,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployCode_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { artifactPath: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deployCode_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: deployCode_1Return) -> Self {
                    (value.deployedAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deployCode_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deployCode_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deployCode_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deployCode(string)";
            const SELECTOR: [u8; 4] = [154u8, 131u8, 37u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.artifactPath,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deriveKey(string,string,uint32,string)` and selector `0x29233b1f`.
    ```solidity
    function deriveKey(string memory mnemonic, string memory derivationPath, uint32 index, string memory language) external pure returns (uint256 privateKey);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_0Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub derivationPath: alloy::sol_types::private::String,
        pub index: u32,
        pub language: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`deriveKey(string,string,uint32,string)`](deriveKey_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_0Return {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                u32,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_0Call) -> Self {
                    (value.mnemonic, value.derivationPath, value.index, value.language)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mnemonic: tuple.0,
                        derivationPath: tuple.1,
                        index: tuple.2,
                        language: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_0Return) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deriveKey_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deriveKey_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deriveKey(string,string,uint32,string)";
            const SELECTOR: [u8; 4] = [41u8, 35u8, 59u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.derivationPath,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.language,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deriveKey(string,uint32,string)` and selector `0x32c8176d`.
    ```solidity
    function deriveKey(string memory mnemonic, uint32 index, string memory language) external pure returns (uint256 privateKey);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_1Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub index: u32,
        pub language: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`deriveKey(string,uint32,string)`](deriveKey_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_1Return {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, u32, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_1Call) -> Self {
                    (value.mnemonic, value.index, value.language)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mnemonic: tuple.0, index: tuple.1, language: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_1Return) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deriveKey_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deriveKey_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deriveKey(string,uint32,string)";
            const SELECTOR: [u8; 4] = [50u8, 200u8, 23u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.language,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deriveKey(string,uint32)` and selector `0x6229498b`.
    ```solidity
    function deriveKey(string memory mnemonic, uint32 index) external pure returns (uint256 privateKey);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_2Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub index: u32,
    }
    ///Container type for the return parameters of the [`deriveKey(string,uint32)`](deriveKey_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_2Return {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_2Call) -> Self {
                    (value.mnemonic, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mnemonic: tuple.0, index: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_2Return) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deriveKey_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deriveKey_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deriveKey(string,uint32)";
            const SELECTOR: [u8; 4] = [98u8, 41u8, 73u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `deriveKey(string,string,uint32)` and selector `0x6bcb2c1b`.
    ```solidity
    function deriveKey(string memory mnemonic, string memory derivationPath, uint32 index) external pure returns (uint256 privateKey);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_3Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub derivationPath: alloy::sol_types::private::String,
        pub index: u32,
    }
    ///Container type for the return parameters of the [`deriveKey(string,string,uint32)`](deriveKey_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deriveKey_3Return {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_3Call) -> Self {
                    (value.mnemonic, value.derivationPath, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mnemonic: tuple.0, derivationPath: tuple.1, index: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deriveKey_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: deriveKey_3Return) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deriveKey_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deriveKey_3Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deriveKey_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deriveKey(string,string,uint32)";
            const SELECTOR: [u8; 4] = [107u8, 203u8, 44u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.derivationPath,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `ensNamehash(string)` and selector `0x8c374c65`.
    ```solidity
    function ensNamehash(string memory name) external pure returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ensNamehashCall {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`ensNamehash(string)`](ensNamehashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ensNamehashReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ensNamehashCall> for UnderlyingRustTuple<'_> {
                fn from(value: ensNamehashCall) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ensNamehashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ensNamehashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ensNamehashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ensNamehashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ensNamehashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ensNamehashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ensNamehash(string)";
            const SELECTOR: [u8; 4] = [140u8, 55u8, 76u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envAddress(string)` and selector `0x350d56bf`.
    ```solidity
    function envAddress(string memory name) external view returns (address value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envAddress_0Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envAddress(string)`](envAddress_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envAddress_0Return {
        pub value: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envAddress_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envAddress_0Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envAddress_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envAddress_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envAddress_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envAddress_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envAddress_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envAddress_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envAddress(string)";
            const SELECTOR: [u8; 4] = [53u8, 13u8, 86u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envAddress(string,string)` and selector `0xad31b9fa`.
    ```solidity
    function envAddress(string memory name, string memory delim) external view returns (address[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envAddress_1Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envAddress(string,string)`](envAddress_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envAddress_1Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envAddress_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envAddress_1Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envAddress_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envAddress_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envAddress_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envAddress_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envAddress_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envAddress_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envAddress(string,string)";
            const SELECTOR: [u8; 4] = [173u8, 49u8, 185u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBool(string)` and selector `0x7ed1ec7d`.
    ```solidity
    function envBool(string memory name) external view returns (bool value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBool_0Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBool(string)`](envBool_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBool_0Return {
        pub value: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBool_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBool_0Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBool_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBool_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBool_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBool_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBool_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBool_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBool(string)";
            const SELECTOR: [u8; 4] = [126u8, 209u8, 236u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBool(string,string)` and selector `0xaaaddeaf`.
    ```solidity
    function envBool(string memory name, string memory delim) external view returns (bool[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBool_1Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBool(string,string)`](envBool_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBool_1Return {
        pub value: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBool_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBool_1Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBool_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<bool>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBool_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBool_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBool_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBool_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBool_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBool(string,string)";
            const SELECTOR: [u8; 4] = [170u8, 173u8, 222u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBytes(string)` and selector `0x4d7baf06`.
    ```solidity
    function envBytes(string memory name) external view returns (bytes memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes_0Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBytes(string)`](envBytes_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes_0Return {
        pub value: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes_0Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBytes_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBytes_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBytes(string)";
            const SELECTOR: [u8; 4] = [77u8, 123u8, 175u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBytes(string,string)` and selector `0xddc2651b`.
    ```solidity
    function envBytes(string memory name, string memory delim) external view returns (bytes[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes_1Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBytes(string,string)`](envBytes_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes_1Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes_1Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBytes_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBytes_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBytes(string,string)";
            const SELECTOR: [u8; 4] = [221u8, 194u8, 101u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBytes32(string,string)` and selector `0x5af231c1`.
    ```solidity
    function envBytes32(string memory name, string memory delim) external view returns (bytes32[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes32_0Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBytes32(string,string)`](envBytes32_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes32_0Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes32_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes32_0Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes32_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes32_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes32_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes32_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBytes32_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBytes32_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBytes32(string,string)";
            const SELECTOR: [u8; 4] = [90u8, 242u8, 49u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envBytes32(string)` and selector `0x97949042`.
    ```solidity
    function envBytes32(string memory name) external view returns (bytes32 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes32_1Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envBytes32(string)`](envBytes32_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envBytes32_1Return {
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes32_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes32_1Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes32_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envBytes32_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envBytes32_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envBytes32_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envBytes32_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envBytes32_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envBytes32(string)";
            const SELECTOR: [u8; 4] = [151u8, 148u8, 144u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envExists(string)` and selector `0xce8365f9`.
    ```solidity
    function envExists(string memory name) external view returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envExistsCall {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envExists(string)`](envExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envExistsReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envExistsCall> for UnderlyingRustTuple<'_> {
                fn from(value: envExistsCall) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envExistsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: envExistsReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envExistsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envExistsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envExists(string)";
            const SELECTOR: [u8; 4] = [206u8, 131u8, 101u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envInt(string,string)` and selector `0x42181150`.
    ```solidity
    function envInt(string memory name, string memory delim) external view returns (int256[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envInt_0Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envInt(string,string)`](envInt_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envInt_0Return {
        pub value:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envInt_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envInt_0Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envInt_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envInt_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envInt_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envInt_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envInt_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envInt_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envInt(string,string)";
            const SELECTOR: [u8; 4] = [66u8, 24u8, 17u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envInt(string)` and selector `0x892a0c61`.
    ```solidity
    function envInt(string memory name) external view returns (int256 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envInt_1Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envInt(string)`](envInt_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envInt_1Return {
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envInt_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envInt_1Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envInt_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envInt_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envInt_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envInt_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envInt_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envInt_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envInt(string)";
            const SELECTOR: [u8; 4] = [137u8, 42u8, 12u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,bytes32[])` and selector `0x2281f367`.
    ```solidity
    function envOr(string memory name, string memory delim, bytes32[] memory defaultValue) external view returns (bytes32[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_0Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,bytes32[])`](envOr_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_0Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_0Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,bytes32[])";
            const SELECTOR: [u8; 4] = [34u8, 129u8, 243u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,int256[])` and selector `0x4700d74b`.
    ```solidity
    function envOr(string memory name, string memory delim, int256[] memory defaultValue) external view returns (int256[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_1Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,int256[])`](envOr_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_1Return {
        pub value:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_1Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,int256[])";
            const SELECTOR: [u8; 4] = [71u8, 0u8, 215u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,bool)` and selector `0x4777f3cf`.
    ```solidity
    function envOr(string memory name, bool defaultValue) external view returns (bool value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_2Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: bool,
    }
    ///Container type for the return parameters of the [`envOr(string,bool)`](envOr_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_2Return {
        pub value: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_2Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_2Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,bool)";
            const SELECTOR: [u8; 4] = [71u8, 119u8, 243u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,address)` and selector `0x561fe540`.
    ```solidity
    function envOr(string memory name, address defaultValue) external view returns (address value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_3Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`envOr(string,address)`](envOr_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_3Return {
        pub value: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Address);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_3Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_3Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_3Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,address)";
            const SELECTOR: [u8; 4] = [86u8, 31u8, 229u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,uint256)` and selector `0x5e97348f`.
    ```solidity
    function envOr(string memory name, uint256 defaultValue) external view returns (uint256 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_4Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`envOr(string,uint256)`](envOr_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_4Return {
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_4Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_4Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_4Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,uint256)";
            const SELECTOR: [u8; 4] = [94u8, 151u8, 52u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,bytes[])` and selector `0x64bc3e64`.
    ```solidity
    function envOr(string memory name, string memory delim, bytes[] memory defaultValue) external view returns (bytes[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_5Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,bytes[])`](envOr_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_5Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_5Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_5Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_5Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_5Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,bytes[])";
            const SELECTOR: [u8; 4] = [100u8, 188u8, 62u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,uint256[])` and selector `0x74318528`.
    ```solidity
    function envOr(string memory name, string memory delim, uint256[] memory defaultValue) external view returns (uint256[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_6Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,uint256[])`](envOr_6Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_6Return {
        pub value:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_6Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_6Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_6Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_6Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_6Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_6Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_6Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_6Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,uint256[])";
            const SELECTOR: [u8; 4] = [116u8, 49u8, 133u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,string[])` and selector `0x859216bc`.
    ```solidity
    function envOr(string memory name, string memory delim, string[] memory defaultValue) external view returns (string[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_7Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,string[])`](envOr_7Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_7Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_7Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_7Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_7Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_7Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_7Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_7Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_7Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_7Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,string[])";
            const SELECTOR: [u8; 4] = [133u8, 146u8, 22u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,bytes)` and selector `0xb3e47705`.
    ```solidity
    function envOr(string memory name, bytes memory defaultValue) external view returns (bytes memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_8Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`envOr(string,bytes)`](envOr_8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_8Return {
        pub value: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_8Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_8Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_8Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_8Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_8Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,bytes)";
            const SELECTOR: [u8; 4] = [179u8, 228u8, 119u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,bytes32)` and selector `0xb4a85892`.
    ```solidity
    function envOr(string memory name, bytes32 defaultValue) external view returns (bytes32 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_9Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`envOr(string,bytes32)`](envOr_9Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_9Return {
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_9Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_9Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_9Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_9Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_9Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_9Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_9Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_9Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,bytes32)";
            const SELECTOR: [u8; 4] = [180u8, 168u8, 88u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,int256)` and selector `0xbbcb713e`.
    ```solidity
    function envOr(string memory name, int256 defaultValue) external view returns (int256 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_10Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`envOr(string,int256)`](envOr_10Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_10Return {
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Int<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_10Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_10Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_10Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_10Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_10Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_10Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_10Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Int<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_10Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,int256)";
            const SELECTOR: [u8; 4] = [187u8, 203u8, 113u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,address[])` and selector `0xc74e9deb`.
    ```solidity
    function envOr(string memory name, string memory delim, address[] memory defaultValue) external view returns (address[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_11Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,address[])`](envOr_11Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_11Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_11Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_11Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_11Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_11Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_11Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_11Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_11Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_11Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,address[])";
            const SELECTOR: [u8; 4] = [199u8, 78u8, 157u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string)` and selector `0xd145736c`.
    ```solidity
    function envOr(string memory name, string memory defaultValue) external view returns (string memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_12Call {
        pub name: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envOr(string,string)`](envOr_12Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_12Return {
        pub value: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_12Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_12Call) -> Self {
                    (value.name, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_12Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, defaultValue: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_12Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_12Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_12Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_12Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_12Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string)";
            const SELECTOR: [u8; 4] = [209u8, 69u8, 115u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.defaultValue,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envOr(string,string,bool[])` and selector `0xeb85e83b`.
    ```solidity
    function envOr(string memory name, string memory delim, bool[] memory defaultValue) external view returns (bool[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_13Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
        pub defaultValue: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`envOr(string,string,bool[])`](envOr_13Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envOr_13Return {
        pub value: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_13Call> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_13Call) -> Self {
                    (value.name, value.delim, value.defaultValue)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_13Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1, defaultValue: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<bool>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envOr_13Return> for UnderlyingRustTuple<'_> {
                fn from(value: envOr_13Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envOr_13Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envOr_13Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envOr_13Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envOr(string,string,bool[])";
            const SELECTOR: [u8; 4] = [235u8, 133u8, 232u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.defaultValue),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envString(string,string)` and selector `0x14b02bc9`.
    ```solidity
    function envString(string memory name, string memory delim) external view returns (string[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envString_0Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envString(string,string)`](envString_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envString_0Return {
        pub value: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envString_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envString_0Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envString_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envString_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envString_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envString_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envString_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envString_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envString(string,string)";
            const SELECTOR: [u8; 4] = [20u8, 176u8, 43u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envString(string)` and selector `0xf877cb19`.
    ```solidity
    function envString(string memory name) external view returns (string memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envString_1Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envString(string)`](envString_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envString_1Return {
        pub value: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envString_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envString_1Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envString_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envString_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envString_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envString_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envString_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envString_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envString(string)";
            const SELECTOR: [u8; 4] = [248u8, 119u8, 203u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envUint(string)` and selector `0xc1978d1f`.
    ```solidity
    function envUint(string memory name) external view returns (uint256 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envUint_0Call {
        pub name: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envUint(string)`](envUint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envUint_0Return {
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envUint_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: envUint_0Call) -> Self {
                    (value.name,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envUint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envUint_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: envUint_0Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envUint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envUint_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envUint_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envUint(string)";
            const SELECTOR: [u8; 4] = [193u8, 151u8, 141u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.name,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `envUint(string,string)` and selector `0xf3dec099`.
    ```solidity
    function envUint(string memory name, string memory delim) external view returns (uint256[] memory value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envUint_1Call {
        pub name: alloy::sol_types::private::String,
        pub delim: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`envUint(string,string)`](envUint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct envUint_1Return {
        pub value:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envUint_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: envUint_1Call) -> Self {
                    (value.name, value.delim)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envUint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, delim: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<envUint_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: envUint_1Return) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for envUint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for envUint_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = envUint_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "envUint(string,string)";
            const SELECTOR: [u8; 4] = [243u8, 222u8, 192u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delim,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `eth_getLogs(uint256,uint256,address,bytes32[])` and selector `0x35e1349b`.
    ```solidity
    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] memory topics) external returns (EthGetLogs[] memory logs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eth_getLogsCall {
        pub fromBlock: alloy::sol_types::private::primitives::aliases::U256,
        pub toBlock: alloy::sol_types::private::primitives::aliases::U256,
        pub target: alloy::sol_types::private::Address,
        pub topics: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`eth_getLogs(uint256,uint256,address,bytes32[])`](eth_getLogsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eth_getLogsReturn {
        pub logs:
            alloy::sol_types::private::Vec<<EthGetLogs as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eth_getLogsCall> for UnderlyingRustTuple<'_> {
                fn from(value: eth_getLogsCall) -> Self {
                    (value.fromBlock, value.toBlock, value.target, value.topics)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eth_getLogsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { fromBlock: tuple.0, toBlock: tuple.1, target: tuple.2, topics: tuple.3 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<EthGetLogs>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<<EthGetLogs as alloy::sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eth_getLogsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eth_getLogsReturn) -> Self {
                    (value.logs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eth_getLogsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { logs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eth_getLogsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = eth_getLogsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<EthGetLogs>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eth_getLogs(uint256,uint256,address,bytes32[])";
            const SELECTOR: [u8; 4] = [53u8, 225u8, 52u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromBlock),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.toBlock),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.topics),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `exists(string)` and selector `0x261a323e`.
    ```solidity
    function exists(string memory path) external view returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct existsCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`exists(string)`](existsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct existsReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<existsCall> for UnderlyingRustTuple<'_> {
                fn from(value: existsCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for existsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<existsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: existsReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for existsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for existsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = existsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exists(string)";
            const SELECTOR: [u8; 4] = [38u8, 26u8, 50u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `ffi(string[])` and selector `0x89160467`.
    ```solidity
    function ffi(string[] memory commandInput) external returns (bytes memory result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ffiCall {
        pub commandInput: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`ffi(string[])`](ffiCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ffiReturn {
        pub result: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ffiCall> for UnderlyingRustTuple<'_> {
                fn from(value: ffiCall) -> Self {
                    (value.commandInput,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ffiCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { commandInput: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ffiReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ffiReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ffiReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ffiCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ffiReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ffi(string[])";
            const SELECTOR: [u8; 4] = [137u8, 22u8, 4u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.commandInput),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `fsMetadata(string)` and selector `0xaf368a08`.
    ```solidity
    function fsMetadata(string memory path) external view returns (FsMetadata memory metadata);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fsMetadataCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`fsMetadata(string)`](fsMetadataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fsMetadataReturn {
        pub metadata: <FsMetadata as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fsMetadataCall> for UnderlyingRustTuple<'_> {
                fn from(value: fsMetadataCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fsMetadataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (FsMetadata,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<FsMetadata as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fsMetadataReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fsMetadataReturn) -> Self {
                    (value.metadata,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fsMetadataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { metadata: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fsMetadataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = fsMetadataReturn;
            type ReturnTuple<'a> = (FsMetadata,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fsMetadata(string)";
            const SELECTOR: [u8; 4] = [175u8, 54u8, 138u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getArtifactPathByCode(bytes)` and selector `0xeb74848c`.
    ```solidity
    function getArtifactPathByCode(bytes memory code) external view returns (string memory path);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getArtifactPathByCodeCall {
        pub code: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`getArtifactPathByCode(bytes)`](getArtifactPathByCodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getArtifactPathByCodeReturn {
        pub path: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getArtifactPathByCodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getArtifactPathByCodeCall) -> Self {
                    (value.code,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getArtifactPathByCodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { code: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getArtifactPathByCodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getArtifactPathByCodeReturn) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getArtifactPathByCodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getArtifactPathByCodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getArtifactPathByCodeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getArtifactPathByCode(bytes)";
            const SELECTOR: [u8; 4] = [235u8, 116u8, 132u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.code,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getArtifactPathByDeployedCode(bytes)` and selector `0x6d853ba5`.
    ```solidity
    function getArtifactPathByDeployedCode(bytes memory deployedCode) external view returns (string memory path);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getArtifactPathByDeployedCodeCall {
        pub deployedCode: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`getArtifactPathByDeployedCode(bytes)`](getArtifactPathByDeployedCodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getArtifactPathByDeployedCodeReturn {
        pub path: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getArtifactPathByDeployedCodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getArtifactPathByDeployedCodeCall) -> Self {
                    (value.deployedCode,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getArtifactPathByDeployedCodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedCode: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getArtifactPathByDeployedCodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getArtifactPathByDeployedCodeReturn) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getArtifactPathByDeployedCodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getArtifactPathByDeployedCodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getArtifactPathByDeployedCodeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getArtifactPathByDeployedCode(bytes)";
            const SELECTOR: [u8; 4] = [109u8, 133u8, 59u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.deployedCode,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlobBaseFee()` and selector `0x1f6d6ef7`.
    ```solidity
    function getBlobBaseFee() external view returns (uint256 blobBaseFee);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlobBaseFeeCall {}
    ///Container type for the return parameters of the [`getBlobBaseFee()`](getBlobBaseFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlobBaseFeeReturn {
        pub blobBaseFee: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlobBaseFeeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlobBaseFeeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlobBaseFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlobBaseFeeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlobBaseFeeReturn) -> Self {
                    (value.blobBaseFee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlobBaseFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blobBaseFee: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlobBaseFeeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlobBaseFeeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlobBaseFee()";
            const SELECTOR: [u8; 4] = [31u8, 109u8, 110u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlockNumber()` and selector `0x42cbb15c`.
    ```solidity
    function getBlockNumber() external view returns (uint256 height);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockNumberCall {}
    ///Container type for the return parameters of the [`getBlockNumber()`](getBlockNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockNumberReturn {
        pub height: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockNumberReturn) -> Self {
                    (value.height,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { height: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlockNumberReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockNumber()";
            const SELECTOR: [u8; 4] = [66u8, 203u8, 177u8, 92u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlockTimestamp()` and selector `0x796b89b9`.
    ```solidity
    function getBlockTimestamp() external view returns (uint256 timestamp);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampCall {}
    ///Container type for the return parameters of the [`getBlockTimestamp()`](getBlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampReturn {
        pub timestamp: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampReturn) -> Self {
                    (value.timestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timestamp: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockTimestampCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlockTimestampReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockTimestamp()";
            const SELECTOR: [u8; 4] = [121u8, 107u8, 137u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBroadcast(string,uint64,uint8)` and selector `0x3dc90cb3`.
    ```solidity
    function getBroadcast(string memory contractName, uint64 chainId, BroadcastTxType txType) external view returns (BroadcastTxSummary memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcastCall {
        pub contractName: alloy::sol_types::private::String,
        pub chainId: u64,
        pub txType: <BroadcastTxType as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`getBroadcast(string,uint64,uint8)`](getBroadcastCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcastReturn {
        pub _0: <BroadcastTxSummary as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                BroadcastTxType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                u64,
                <BroadcastTxType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcastCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcastCall) -> Self {
                    (value.contractName, value.chainId, value.txType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcastCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0, chainId: tuple.1, txType: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (BroadcastTxSummary,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<BroadcastTxSummary as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcastReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcastReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcastReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBroadcastCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                BroadcastTxType,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBroadcastReturn;
            type ReturnTuple<'a> = (BroadcastTxSummary,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBroadcast(string,uint64,uint8)";
            const SELECTOR: [u8; 4] = [61u8, 201u8, 12u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.contractName,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                    <BroadcastTxType as alloy_sol_types::SolType>::tokenize(&self.txType),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBroadcasts(string,uint64)` and selector `0xf2fa4a26`.
    ```solidity
    function getBroadcasts(string memory contractName, uint64 chainId) external view returns (BroadcastTxSummary[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcasts_0Call {
        pub contractName: alloy::sol_types::private::String,
        pub chainId: u64,
    }
    ///Container type for the return parameters of the [`getBroadcasts(string,uint64)`](getBroadcasts_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcasts_0Return {
        pub _0: alloy::sol_types::private::Vec<
            <BroadcastTxSummary as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcasts_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcasts_0Call) -> Self {
                    (value.contractName, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcasts_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0, chainId: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<BroadcastTxSummary>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <BroadcastTxSummary as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcasts_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcasts_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcasts_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBroadcasts_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBroadcasts_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<BroadcastTxSummary>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBroadcasts(string,uint64)";
            const SELECTOR: [u8; 4] = [242u8, 250u8, 74u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.contractName,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getBroadcasts(string,uint64,uint8)` and selector `0xf7afe919`.
    ```solidity
    function getBroadcasts(string memory contractName, uint64 chainId, BroadcastTxType txType) external view returns (BroadcastTxSummary[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcasts_1Call {
        pub contractName: alloy::sol_types::private::String,
        pub chainId: u64,
        pub txType: <BroadcastTxType as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`getBroadcasts(string,uint64,uint8)`](getBroadcasts_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBroadcasts_1Return {
        pub _0: alloy::sol_types::private::Vec<
            <BroadcastTxSummary as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                BroadcastTxType,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                u64,
                <BroadcastTxType as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcasts_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcasts_1Call) -> Self {
                    (value.contractName, value.chainId, value.txType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcasts_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0, chainId: tuple.1, txType: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<BroadcastTxSummary>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <BroadcastTxSummary as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBroadcasts_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: getBroadcasts_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBroadcasts_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBroadcasts_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                BroadcastTxType,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBroadcasts_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<BroadcastTxSummary>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBroadcasts(string,uint64,uint8)";
            const SELECTOR: [u8; 4] = [247u8, 175u8, 233u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.contractName,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                    <BroadcastTxType as alloy_sol_types::SolType>::tokenize(&self.txType),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getCode(string)` and selector `0x8d1cc925`.
    ```solidity
    function getCode(string memory artifactPath) external view returns (bytes memory creationBytecode);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCodeCall {
        pub artifactPath: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`getCode(string)`](getCodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCodeReturn {
        pub creationBytecode: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCodeCall) -> Self {
                    (value.artifactPath,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { artifactPath: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getCodeReturn) -> Self {
                    (value.creationBytecode,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { creationBytecode: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCodeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCode(string)";
            const SELECTOR: [u8; 4] = [141u8, 28u8, 201u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.artifactPath,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getDeployedCode(string)` and selector `0x3ebf73b4`.
    ```solidity
    function getDeployedCode(string memory artifactPath) external view returns (bytes memory runtimeBytecode);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployedCodeCall {
        pub artifactPath: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`getDeployedCode(string)`](getDeployedCodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployedCodeReturn {
        pub runtimeBytecode: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployedCodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployedCodeCall) -> Self {
                    (value.artifactPath,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployedCodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { artifactPath: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployedCodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployedCodeReturn) -> Self {
                    (value.runtimeBytecode,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployedCodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { runtimeBytecode: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDeployedCodeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDeployedCodeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeployedCode(string)";
            const SELECTOR: [u8; 4] = [62u8, 191u8, 115u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.artifactPath,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getDeployment(string,uint64)` and selector `0x0debd5d6`.
    ```solidity
    function getDeployment(string memory contractName, uint64 chainId) external view returns (address deployedAddress);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployment_0Call {
        pub contractName: alloy::sol_types::private::String,
        pub chainId: u64,
    }
    ///Container type for the return parameters of the [`getDeployment(string,uint64)`](getDeployment_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployment_0Return {
        pub deployedAddress: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployment_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployment_0Call) -> Self {
                    (value.contractName, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployment_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0, chainId: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployment_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployment_0Return) -> Self {
                    (value.deployedAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployment_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDeployment_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDeployment_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeployment(string,uint64)";
            const SELECTOR: [u8; 4] = [13u8, 235u8, 213u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.contractName,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getDeployment(string)` and selector `0xa8091d97`.
    ```solidity
    function getDeployment(string memory contractName) external view returns (address deployedAddress);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployment_1Call {
        pub contractName: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`getDeployment(string)`](getDeployment_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeployment_1Return {
        pub deployedAddress: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployment_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployment_1Call) -> Self {
                    (value.contractName,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployment_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeployment_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: getDeployment_1Return) -> Self {
                    (value.deployedAddress,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeployment_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedAddress: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDeployment_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDeployment_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeployment(string)";
            const SELECTOR: [u8; 4] = [168u8, 9u8, 29u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.contractName,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getDeployments(string,uint64)` and selector `0x74e133dd`.
    ```solidity
    function getDeployments(string memory contractName, uint64 chainId) external view returns (address[] memory deployedAddresses);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeploymentsCall {
        pub contractName: alloy::sol_types::private::String,
        pub chainId: u64,
    }
    ///Container type for the return parameters of the [`getDeployments(string,uint64)`](getDeploymentsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDeploymentsReturn {
        pub deployedAddresses: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeploymentsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDeploymentsCall) -> Self {
                    (value.contractName, value.chainId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeploymentsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { contractName: tuple.0, chainId: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDeploymentsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDeploymentsReturn) -> Self {
                    (value.deployedAddresses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDeploymentsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { deployedAddresses: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDeploymentsCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getDeploymentsReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeployments(string,uint64)";
            const SELECTOR: [u8; 4] = [116u8, 225u8, 51u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.contractName,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.chainId,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getFoundryVersion()` and selector `0xea991bb5`.
    ```solidity
    function getFoundryVersion() external view returns (string memory version);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFoundryVersionCall {}
    ///Container type for the return parameters of the [`getFoundryVersion()`](getFoundryVersionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getFoundryVersionReturn {
        pub version: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFoundryVersionCall> for UnderlyingRustTuple<'_> {
                fn from(value: getFoundryVersionCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getFoundryVersionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getFoundryVersionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getFoundryVersionReturn) -> Self {
                    (value.version,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getFoundryVersionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { version: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getFoundryVersionCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getFoundryVersionReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getFoundryVersion()";
            const SELECTOR: [u8; 4] = [234u8, 153u8, 27u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getLabel(address)` and selector `0x28a249b0`.
    ```solidity
    function getLabel(address account) external view returns (string memory currentLabel);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLabelCall {
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getLabel(address)`](getLabelCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLabelReturn {
        pub currentLabel: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLabelCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLabelCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLabelCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLabelReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLabelReturn) -> Self {
                    (value.currentLabel,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLabelReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { currentLabel: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLabelCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLabelReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLabel(address)";
            const SELECTOR: [u8; 4] = [40u8, 162u8, 73u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.account,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getMappingKeyAndParentOf(address,bytes32)` and selector `0x876e24e6`.
    ```solidity
    function getMappingKeyAndParentOf(address target, bytes32 elementSlot) external returns (bool found, bytes32 key, bytes32 parent);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingKeyAndParentOfCall {
        pub target: alloy::sol_types::private::Address,
        pub elementSlot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getMappingKeyAndParentOf(address,bytes32)`](getMappingKeyAndParentOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingKeyAndParentOfReturn {
        pub found: bool,
        pub key: alloy::sol_types::private::FixedBytes<32>,
        pub parent: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingKeyAndParentOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingKeyAndParentOfCall) -> Self {
                    (value.target, value.elementSlot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingKeyAndParentOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0, elementSlot: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingKeyAndParentOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingKeyAndParentOfReturn) -> Self {
                    (value.found, value.key, value.parent)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingKeyAndParentOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { found: tuple.0, key: tuple.1, parent: tuple.2 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getMappingKeyAndParentOfCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getMappingKeyAndParentOfReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getMappingKeyAndParentOf(address,bytes32)";
            const SELECTOR: [u8; 4] = [135u8, 110u8, 36u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.elementSlot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getMappingLength(address,bytes32)` and selector `0x2f2fd63f`.
    ```solidity
    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingLengthCall {
        pub target: alloy::sol_types::private::Address,
        pub mappingSlot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getMappingLength(address,bytes32)`](getMappingLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingLengthReturn {
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingLengthCall) -> Self {
                    (value.target, value.mappingSlot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0, mappingSlot: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingLengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingLengthReturn) -> Self {
                    (value.length,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { length: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getMappingLengthCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getMappingLengthReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getMappingLength(address,bytes32)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 214u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mappingSlot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getMappingSlotAt(address,bytes32,uint256)` and selector `0xebc73ab4`.
    ```solidity
    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingSlotAtCall {
        pub target: alloy::sol_types::private::Address,
        pub mappingSlot: alloy::sol_types::private::FixedBytes<32>,
        pub idx: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getMappingSlotAt(address,bytes32,uint256)`](getMappingSlotAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getMappingSlotAtReturn {
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingSlotAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingSlotAtCall) -> Self {
                    (value.target, value.mappingSlot, value.idx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingSlotAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0, mappingSlot: tuple.1, idx: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getMappingSlotAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getMappingSlotAtReturn) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getMappingSlotAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getMappingSlotAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getMappingSlotAtReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getMappingSlotAt(address,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [235u8, 199u8, 58u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.mappingSlot),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.idx),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getNonce(address)` and selector `0x2d0335ab`.
    ```solidity
    function getNonce(address account) external view returns (uint64 nonce);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNonce_0Call {
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getNonce(address)`](getNonce_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNonce_0Return {
        pub nonce: u64,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNonce_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: getNonce_0Call) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNonce_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNonce_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: getNonce_0Return) -> Self {
                    (value.nonce,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNonce_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nonce: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNonce_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNonce_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNonce(address)";
            const SELECTOR: [u8; 4] = [45u8, 3u8, 53u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.account,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getNonce((address,uint256,uint256,uint256))` and selector `0xa5748aad`.
    ```solidity
    function getNonce(Wallet memory wallet) external returns (uint64 nonce);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNonce_1Call {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`getNonce((address,uint256,uint256,uint256))`](getNonce_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getNonce_1Return {
        pub nonce: u64,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Wallet as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNonce_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: getNonce_1Call) -> Self {
                    (value.wallet,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNonce_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getNonce_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: getNonce_1Return) -> Self {
                    (value.nonce,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getNonce_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nonce: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getNonce_1Call {
            type Parameters<'a> = (Wallet,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getNonce_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getNonce((address,uint256,uint256,uint256))";
            const SELECTOR: [u8; 4] = [165u8, 116u8, 138u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Wallet as alloy_sol_types::SolType>::tokenize(&self.wallet),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getRecordedLogs()` and selector `0x191553a4`.
    ```solidity
    function getRecordedLogs() external returns (Log[] memory logs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRecordedLogsCall {}
    ///Container type for the return parameters of the [`getRecordedLogs()`](getRecordedLogsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRecordedLogsReturn {
        pub logs: alloy::sol_types::private::Vec<<Log as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRecordedLogsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRecordedLogsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRecordedLogsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<Log>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<<Log as alloy::sol_types::SolType>::RustType>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRecordedLogsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRecordedLogsReturn) -> Self {
                    (value.logs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRecordedLogsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { logs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRecordedLogsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRecordedLogsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<Log>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRecordedLogs()";
            const SELECTOR: [u8; 4] = [25u8, 21u8, 83u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getStateDiff()` and selector `0x80df01cc`.
    ```solidity
    function getStateDiff() external view returns (string memory diff);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStateDiffCall {}
    ///Container type for the return parameters of the [`getStateDiff()`](getStateDiffCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStateDiffReturn {
        pub diff: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStateDiffCall> for UnderlyingRustTuple<'_> {
                fn from(value: getStateDiffCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStateDiffCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStateDiffReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getStateDiffReturn) -> Self {
                    (value.diff,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStateDiffReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { diff: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getStateDiffCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getStateDiffReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getStateDiff()";
            const SELECTOR: [u8; 4] = [128u8, 223u8, 1u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getStateDiffJson()` and selector `0xf54fe009`.
    ```solidity
    function getStateDiffJson() external view returns (string memory diff);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStateDiffJsonCall {}
    ///Container type for the return parameters of the [`getStateDiffJson()`](getStateDiffJsonCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getStateDiffJsonReturn {
        pub diff: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStateDiffJsonCall> for UnderlyingRustTuple<'_> {
                fn from(value: getStateDiffJsonCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStateDiffJsonCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getStateDiffJsonReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getStateDiffJsonReturn) -> Self {
                    (value.diff,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getStateDiffJsonReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { diff: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getStateDiffJsonCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getStateDiffJsonReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getStateDiffJson()";
            const SELECTOR: [u8; 4] = [245u8, 79u8, 224u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getWallets()` and selector `0xdb7a4605`.
    ```solidity
    function getWallets() external returns (address[] memory wallets);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWalletsCall {}
    ///Container type for the return parameters of the [`getWallets()`](getWalletsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getWalletsReturn {
        pub wallets: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWalletsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getWalletsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getWalletsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getWalletsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getWalletsReturn) -> Self {
                    (value.wallets,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getWalletsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallets: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getWalletsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getWalletsReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getWallets()";
            const SELECTOR: [u8; 4] = [219u8, 122u8, 70u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `indexOf(string,string)` and selector `0x8a0807b7`.
    ```solidity
    function indexOf(string memory input, string memory key) external pure returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct indexOfCall {
        pub input: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`indexOf(string,string)`](indexOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct indexOfReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<indexOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: indexOfCall) -> Self {
                    (value.input, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for indexOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<indexOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: indexOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for indexOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for indexOfCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = indexOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "indexOf(string,string)";
            const SELECTOR: [u8; 4] = [138u8, 8u8, 7u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.input,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `isContext(uint8)` and selector `0x64af255d`.
    ```solidity
    function isContext(ForgeContext context) external view returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isContextCall {
        pub context: <ForgeContext as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`isContext(uint8)`](isContextCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isContextReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (ForgeContext,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<ForgeContext as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isContextCall> for UnderlyingRustTuple<'_> {
                fn from(value: isContextCall) -> Self {
                    (value.context,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isContextCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { context: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isContextReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isContextReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isContextReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isContextCall {
            type Parameters<'a> = (ForgeContext,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isContextReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isContext(uint8)";
            const SELECTOR: [u8; 4] = [100u8, 175u8, 37u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<ForgeContext as alloy_sol_types::SolType>::tokenize(&self.context),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `isDir(string)` and selector `0x7d15d019`.
    ```solidity
    function isDir(string memory path) external view returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isDirCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`isDir(string)`](isDirCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isDirReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isDirCall> for UnderlyingRustTuple<'_> {
                fn from(value: isDirCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isDirCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isDirReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isDirReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isDirReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isDirCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isDirReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isDir(string)";
            const SELECTOR: [u8; 4] = [125u8, 21u8, 208u8, 25u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `isFile(string)` and selector `0xe0eb04d4`.
    ```solidity
    function isFile(string memory path) external view returns (bool result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isFileCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`isFile(string)`](isFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isFileReturn {
        pub result: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: isFileCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isFileReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isFileCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isFileReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isFile(string)";
            const SELECTOR: [u8; 4] = [224u8, 235u8, 4u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `keyExists(string,string)` and selector `0x528a683c`.
    ```solidity
    function keyExists(string memory json, string memory key) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`keyExists(string,string)`](keyExistsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsCall> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for keyExistsCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = keyExistsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "keyExists(string,string)";
            const SELECTOR: [u8; 4] = [82u8, 138u8, 104u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `keyExistsJson(string,string)` and selector `0xdb4235f6`.
    ```solidity
    function keyExistsJson(string memory json, string memory key) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsJsonCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`keyExistsJson(string,string)`](keyExistsJsonCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsJsonReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsJsonCall> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsJsonCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsJsonCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsJsonReturn> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsJsonReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsJsonReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for keyExistsJsonCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = keyExistsJsonReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "keyExistsJson(string,string)";
            const SELECTOR: [u8; 4] = [219u8, 66u8, 53u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `keyExistsToml(string,string)` and selector `0x600903ad`.
    ```solidity
    function keyExistsToml(string memory toml, string memory key) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsTomlCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`keyExistsToml(string,string)`](keyExistsTomlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct keyExistsTomlReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsTomlCall> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsTomlCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsTomlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<keyExistsTomlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: keyExistsTomlReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for keyExistsTomlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for keyExistsTomlCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = keyExistsTomlReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "keyExistsToml(string,string)";
            const SELECTOR: [u8; 4] = [96u8, 9u8, 3u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `label(address,string)` and selector `0xc657c718`.
    ```solidity
    function label(address account, string memory newLabel) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct labelCall {
        pub account: alloy::sol_types::private::Address,
        pub newLabel: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`label(address,string)`](labelCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct labelReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<labelCall> for UnderlyingRustTuple<'_> {
                fn from(value: labelCall) -> Self {
                    (value.account, value.newLabel)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for labelCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0, newLabel: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<labelReturn> for UnderlyingRustTuple<'_> {
                fn from(value: labelReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for labelReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for labelCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = labelReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "label(address,string)";
            const SELECTOR: [u8; 4] = [198u8, 87u8, 199u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.newLabel,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `lastCallGas()` and selector `0x2b589b28`.
    ```solidity
    function lastCallGas() external view returns (Gas memory gas);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastCallGasCall {}
    ///Container type for the return parameters of the [`lastCallGas()`](lastCallGasCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastCallGasReturn {
        pub gas: <Gas as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastCallGasCall> for UnderlyingRustTuple<'_> {
                fn from(value: lastCallGasCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lastCallGasCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Gas,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Gas as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastCallGasReturn> for UnderlyingRustTuple<'_> {
                fn from(value: lastCallGasReturn) -> Self {
                    (value.gas,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lastCallGasReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { gas: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastCallGasCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = lastCallGasReturn;
            type ReturnTuple<'a> = (Gas,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastCallGas()";
            const SELECTOR: [u8; 4] = [43u8, 88u8, 155u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `load(address,bytes32)` and selector `0x667f9d70`.
    ```solidity
    function load(address target, bytes32 slot) external view returns (bytes32 data);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct loadCall {
        pub target: alloy::sol_types::private::Address,
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`load(address,bytes32)`](loadCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct loadReturn {
        pub data: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<loadCall> for UnderlyingRustTuple<'_> {
                fn from(value: loadCall) -> Self {
                    (value.target, value.slot)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for loadCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0, slot: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<loadReturn> for UnderlyingRustTuple<'_> {
                fn from(value: loadReturn) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for loadReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for loadCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = loadReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "load(address,bytes32)";
            const SELECTOR: [u8; 4] = [102u8, 127u8, 157u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseAddress(string)` and selector `0xc6ce059d`.
    ```solidity
    function parseAddress(string memory stringifiedValue) external pure returns (address parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseAddressCall {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseAddress(string)`](parseAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseAddressReturn {
        pub parsedValue: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseAddressCall) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseAddressReturn) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseAddress(string)";
            const SELECTOR: [u8; 4] = [198u8, 206u8, 5u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseBool(string)` and selector `0x974ef924`.
    ```solidity
    function parseBool(string memory stringifiedValue) external pure returns (bool parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBoolCall {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseBool(string)`](parseBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBoolReturn {
        pub parsedValue: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseBoolCall) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseBoolReturn) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseBoolCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseBool(string)";
            const SELECTOR: [u8; 4] = [151u8, 78u8, 249u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseBytes(string)` and selector `0x8f5d232d`.
    ```solidity
    function parseBytes(string memory stringifiedValue) external pure returns (bytes memory parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBytesCall {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseBytes(string)`](parseBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBytesReturn {
        pub parsedValue: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBytesCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseBytesCall) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBytesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseBytesReturn) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseBytesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseBytesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseBytes(string)";
            const SELECTOR: [u8; 4] = [143u8, 93u8, 35u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseBytes32(string)` and selector `0x087e6e81`.
    ```solidity
    function parseBytes32(string memory stringifiedValue) external pure returns (bytes32 parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBytes32Call {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseBytes32(string)`](parseBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseBytes32Return {
        pub parsedValue: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseBytes32Call) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseBytes32Return) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseBytes32Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseBytes32(string)";
            const SELECTOR: [u8; 4] = [8u8, 126u8, 110u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseInt(string)` and selector `0x42346c5e`.
    ```solidity
    function parseInt(string memory stringifiedValue) external pure returns (int256 parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseIntCall {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseInt(string)`](parseIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseIntReturn {
        pub parsedValue: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseIntCall) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseIntReturn) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseIntCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseInt(string)";
            const SELECTOR: [u8; 4] = [66u8, 52u8, 108u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJson(string)` and selector `0x6a82600a`.
    ```solidity
    function parseJson(string memory json) external pure returns (bytes memory abiEncodedData);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJson_0Call {
        pub json: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJson(string)`](parseJson_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJson_0Return {
        pub abiEncodedData: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJson_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseJson_0Call) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJson_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJson_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseJson_0Return) -> Self {
                    (value.abiEncodedData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJson_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { abiEncodedData: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJson_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJson_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJson(string)";
            const SELECTOR: [u8; 4] = [106u8, 130u8, 96u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.json,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJson(string,string)` and selector `0x85940ef1`.
    ```solidity
    function parseJson(string memory json, string memory key) external pure returns (bytes memory abiEncodedData);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJson_1Call {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJson(string,string)`](parseJson_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJson_1Return {
        pub abiEncodedData: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJson_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseJson_1Call) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJson_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJson_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseJson_1Return) -> Self {
                    (value.abiEncodedData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJson_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { abiEncodedData: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJson_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJson_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJson(string,string)";
            const SELECTOR: [u8; 4] = [133u8, 148u8, 14u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonAddress(string,string)` and selector `0x1e19e657`.
    ```solidity
    function parseJsonAddress(string memory json, string memory key) external pure returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonAddressCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonAddress(string,string)`](parseJsonAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonAddressCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonAddressCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonAddress(string,string)";
            const SELECTOR: [u8; 4] = [30u8, 25u8, 230u8, 87u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonAddressArray(string,string)` and selector `0x2fce7883`.
    ```solidity
    function parseJsonAddressArray(string memory json, string memory key) external pure returns (address[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonAddressArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonAddressArray(string,string)`](parseJsonAddressArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonAddressArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonAddressArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonAddressArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonAddressArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonAddressArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonAddressArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonAddressArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonAddressArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonAddressArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonAddressArray(string,string)";
            const SELECTOR: [u8; 4] = [47u8, 206u8, 120u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBool(string,string)` and selector `0x9f86dc91`.
    ```solidity
    function parseJsonBool(string memory json, string memory key) external pure returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBoolCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBool(string,string)`](parseJsonBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBoolReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBoolCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBoolCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBool(string,string)";
            const SELECTOR: [u8; 4] = [159u8, 134u8, 220u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBoolArray(string,string)` and selector `0x91f3b94f`.
    ```solidity
    function parseJsonBoolArray(string memory json, string memory key) external pure returns (bool[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBoolArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBoolArray(string,string)`](parseJsonBoolArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBoolArrayReturn {
        pub _0: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBoolArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBoolArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBoolArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<bool>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBoolArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBoolArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBoolArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBoolArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBoolArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBoolArray(string,string)";
            const SELECTOR: [u8; 4] = [145u8, 243u8, 185u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBytes(string,string)` and selector `0xfd921be8`.
    ```solidity
    function parseJsonBytes(string memory json, string memory key) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytesCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBytes(string,string)`](parseJsonBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytesReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytesCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytesCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBytesCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBytesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBytes(string,string)";
            const SELECTOR: [u8; 4] = [253u8, 146u8, 27u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBytes32(string,string)` and selector `0x1777e59d`.
    ```solidity
    function parseJsonBytes32(string memory json, string memory key) external pure returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytes32Call {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBytes32(string,string)`](parseJsonBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytes32Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytes32Call) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytes32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBytes32Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBytes32(string,string)";
            const SELECTOR: [u8; 4] = [23u8, 119u8, 229u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBytes32Array(string,string)` and selector `0x91c75bc3`.
    ```solidity
    function parseJsonBytes32Array(string memory json, string memory key) external pure returns (bytes32[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytes32ArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBytes32Array(string,string)`](parseJsonBytes32ArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytes32ArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytes32ArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytes32ArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytes32ArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytes32ArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytes32ArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytes32ArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBytes32ArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBytes32ArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBytes32Array(string,string)";
            const SELECTOR: [u8; 4] = [145u8, 199u8, 91u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonBytesArray(string,string)` and selector `0x6631aa99`.
    ```solidity
    function parseJsonBytesArray(string memory json, string memory key) external pure returns (bytes[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytesArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonBytesArray(string,string)`](parseJsonBytesArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonBytesArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytesArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytesArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytesArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonBytesArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonBytesArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonBytesArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonBytesArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonBytesArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonBytesArray(string,string)";
            const SELECTOR: [u8; 4] = [102u8, 49u8, 170u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonInt(string,string)` and selector `0x7b048ccd`.
    ```solidity
    function parseJsonInt(string memory json, string memory key) external pure returns (int256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonIntCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonInt(string,string)`](parseJsonIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonIntCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonIntCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonInt(string,string)";
            const SELECTOR: [u8; 4] = [123u8, 4u8, 140u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonIntArray(string,string)` and selector `0x9983c28a`.
    ```solidity
    function parseJsonIntArray(string memory json, string memory key) external pure returns (int256[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonIntArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonIntArray(string,string)`](parseJsonIntArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonIntArrayReturn {
        pub _0:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonIntArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonIntArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonIntArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonIntArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonIntArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonIntArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonIntArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonIntArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonIntArray(string,string)";
            const SELECTOR: [u8; 4] = [153u8, 131u8, 194u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonKeys(string,string)` and selector `0x213e4198`.
    ```solidity
    function parseJsonKeys(string memory json, string memory key) external pure returns (string[] memory keys);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonKeysCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonKeys(string,string)`](parseJsonKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonKeysReturn {
        pub keys: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonKeysCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonKeysReturn) -> Self {
                    (value.keys,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keys: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonKeysCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonKeysReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonKeys(string,string)";
            const SELECTOR: [u8; 4] = [33u8, 62u8, 65u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonString(string,string)` and selector `0x49c4fac8`.
    ```solidity
    function parseJsonString(string memory json, string memory key) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonStringCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonString(string,string)`](parseJsonStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonStringCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonStringCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonString(string,string)";
            const SELECTOR: [u8; 4] = [73u8, 196u8, 250u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonStringArray(string,string)` and selector `0x498fdcf4`.
    ```solidity
    function parseJsonStringArray(string memory json, string memory key) external pure returns (string[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonStringArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonStringArray(string,string)`](parseJsonStringArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonStringArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonStringArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonStringArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonStringArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonStringArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonStringArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonStringArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonStringArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonStringArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonStringArray(string,string)";
            const SELECTOR: [u8; 4] = [73u8, 143u8, 220u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonType(string,string)` and selector `0xa9da313b`.
    ```solidity
    function parseJsonType(string memory json, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonType_0Call {
        pub json: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonType(string,string)`](parseJsonType_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonType_0Return {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonType_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonType_0Call) -> Self {
                    (value.json, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonType_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, typeDescription: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonType_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonType_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonType_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonType_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonType_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonType(string,string)";
            const SELECTOR: [u8; 4] = [169u8, 218u8, 49u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonType(string,string,string)` and selector `0xe3f5ae33`.
    ```solidity
    function parseJsonType(string memory json, string memory key, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonType_1Call {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonType(string,string,string)`](parseJsonType_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonType_1Return {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonType_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonType_1Call) -> Self {
                    (value.json, value.key, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonType_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1, typeDescription: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonType_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonType_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonType_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonType_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonType_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonType(string,string,string)";
            const SELECTOR: [u8; 4] = [227u8, 245u8, 174u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonTypeArray(string,string,string)` and selector `0x0175d535`.
    ```solidity
    function parseJsonTypeArray(string memory json, string memory key, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonTypeArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonTypeArray(string,string,string)`](parseJsonTypeArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonTypeArrayReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonTypeArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonTypeArrayCall) -> Self {
                    (value.json, value.key, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonTypeArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1, typeDescription: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonTypeArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonTypeArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonTypeArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonTypeArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonTypeArrayReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonTypeArray(string,string,string)";
            const SELECTOR: [u8; 4] = [1u8, 117u8, 213u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonUint(string,string)` and selector `0xaddde2b6`.
    ```solidity
    function parseJsonUint(string memory json, string memory key) external pure returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonUintCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonUint(string,string)`](parseJsonUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonUintCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonUintCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonUint(string,string)";
            const SELECTOR: [u8; 4] = [173u8, 221u8, 226u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseJsonUintArray(string,string)` and selector `0x522074ab`.
    ```solidity
    function parseJsonUintArray(string memory json, string memory key) external pure returns (uint256[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonUintArrayCall {
        pub json: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseJsonUintArray(string,string)`](parseJsonUintArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseJsonUintArrayReturn {
        pub _0:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonUintArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonUintArrayCall) -> Self {
                    (value.json, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonUintArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseJsonUintArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseJsonUintArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseJsonUintArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseJsonUintArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseJsonUintArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseJsonUintArray(string,string)";
            const SELECTOR: [u8; 4] = [82u8, 32u8, 116u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseToml(string,string)` and selector `0x37736e08`.
    ```solidity
    function parseToml(string memory toml, string memory key) external pure returns (bytes memory abiEncodedData);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseToml_0Call {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseToml(string,string)`](parseToml_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseToml_0Return {
        pub abiEncodedData: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseToml_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseToml_0Call) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseToml_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseToml_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseToml_0Return) -> Self {
                    (value.abiEncodedData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseToml_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { abiEncodedData: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseToml_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseToml_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseToml(string,string)";
            const SELECTOR: [u8; 4] = [55u8, 115u8, 110u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseToml(string)` and selector `0x592151f0`.
    ```solidity
    function parseToml(string memory toml) external pure returns (bytes memory abiEncodedData);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseToml_1Call {
        pub toml: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseToml(string)`](parseToml_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseToml_1Return {
        pub abiEncodedData: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseToml_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseToml_1Call) -> Self {
                    (value.toml,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseToml_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseToml_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseToml_1Return) -> Self {
                    (value.abiEncodedData,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseToml_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { abiEncodedData: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseToml_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseToml_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseToml(string)";
            const SELECTOR: [u8; 4] = [89u8, 33u8, 81u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.toml,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlAddress(string,string)` and selector `0x65e7c844`.
    ```solidity
    function parseTomlAddress(string memory toml, string memory key) external pure returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlAddressCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlAddress(string,string)`](parseTomlAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlAddressCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlAddressCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlAddress(string,string)";
            const SELECTOR: [u8; 4] = [101u8, 231u8, 200u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlAddressArray(string,string)` and selector `0x65c428e7`.
    ```solidity
    function parseTomlAddressArray(string memory toml, string memory key) external pure returns (address[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlAddressArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlAddressArray(string,string)`](parseTomlAddressArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlAddressArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlAddressArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlAddressArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlAddressArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlAddressArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlAddressArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlAddressArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlAddressArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlAddressArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlAddressArray(string,string)";
            const SELECTOR: [u8; 4] = [101u8, 196u8, 40u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBool(string,string)` and selector `0xd30dced6`.
    ```solidity
    function parseTomlBool(string memory toml, string memory key) external pure returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBoolCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBool(string,string)`](parseTomlBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBoolReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBoolCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBoolCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBool(string,string)";
            const SELECTOR: [u8; 4] = [211u8, 13u8, 206u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBoolArray(string,string)` and selector `0x127cfe9a`.
    ```solidity
    function parseTomlBoolArray(string memory toml, string memory key) external pure returns (bool[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBoolArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBoolArray(string,string)`](parseTomlBoolArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBoolArrayReturn {
        pub _0: alloy::sol_types::private::Vec<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBoolArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBoolArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBoolArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<bool>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBoolArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBoolArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBoolArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBoolArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBoolArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBoolArray(string,string)";
            const SELECTOR: [u8; 4] = [18u8, 124u8, 254u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBytes(string,string)` and selector `0xd77bfdb9`.
    ```solidity
    function parseTomlBytes(string memory toml, string memory key) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytesCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBytes(string,string)`](parseTomlBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytesReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytesCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytesCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBytesCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBytesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBytes(string,string)";
            const SELECTOR: [u8; 4] = [215u8, 123u8, 253u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBytes32(string,string)` and selector `0x8e214810`.
    ```solidity
    function parseTomlBytes32(string memory toml, string memory key) external pure returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytes32Call {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBytes32(string,string)`](parseTomlBytes32Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytes32Return {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytes32Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytes32Call) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytes32Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytes32Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytes32Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytes32Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBytes32Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBytes32Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBytes32(string,string)";
            const SELECTOR: [u8; 4] = [142u8, 33u8, 72u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBytes32Array(string,string)` and selector `0x3e716f81`.
    ```solidity
    function parseTomlBytes32Array(string memory toml, string memory key) external pure returns (bytes32[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytes32ArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBytes32Array(string,string)`](parseTomlBytes32ArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytes32ArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytes32ArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytes32ArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytes32ArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytes32ArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytes32ArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytes32ArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBytes32ArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBytes32ArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBytes32Array(string,string)";
            const SELECTOR: [u8; 4] = [62u8, 113u8, 111u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlBytesArray(string,string)` and selector `0xb197c247`.
    ```solidity
    function parseTomlBytesArray(string memory toml, string memory key) external pure returns (bytes[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytesArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlBytesArray(string,string)`](parseTomlBytesArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlBytesArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytesArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytesArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytesArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlBytesArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlBytesArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlBytesArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlBytesArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlBytesArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlBytesArray(string,string)";
            const SELECTOR: [u8; 4] = [177u8, 151u8, 194u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlInt(string,string)` and selector `0xc1350739`.
    ```solidity
    function parseTomlInt(string memory toml, string memory key) external pure returns (int256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlIntCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlInt(string,string)`](parseTomlIntCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlIntReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlIntCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlIntCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlIntCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlIntReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlIntReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlIntReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlIntCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlIntReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlInt(string,string)";
            const SELECTOR: [u8; 4] = [193u8, 53u8, 7u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlIntArray(string,string)` and selector `0xd3522ae6`.
    ```solidity
    function parseTomlIntArray(string memory toml, string memory key) external pure returns (int256[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlIntArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlIntArray(string,string)`](parseTomlIntArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlIntArrayReturn {
        pub _0:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlIntArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlIntArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlIntArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlIntArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlIntArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlIntArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlIntArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlIntArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlIntArray(string,string)";
            const SELECTOR: [u8; 4] = [211u8, 82u8, 42u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlKeys(string,string)` and selector `0x812a44b2`.
    ```solidity
    function parseTomlKeys(string memory toml, string memory key) external pure returns (string[] memory keys);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlKeysCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlKeys(string,string)`](parseTomlKeysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlKeysReturn {
        pub keys: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlKeysCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlKeysCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlKeysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlKeysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlKeysReturn) -> Self {
                    (value.keys,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlKeysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keys: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlKeysCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlKeysReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlKeys(string,string)";
            const SELECTOR: [u8; 4] = [129u8, 42u8, 68u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlString(string,string)` and selector `0x8bb8dd43`.
    ```solidity
    function parseTomlString(string memory toml, string memory key) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlStringCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlString(string,string)`](parseTomlStringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlStringReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlStringCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlStringCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlStringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlStringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlStringReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlStringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlStringCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlStringReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlString(string,string)";
            const SELECTOR: [u8; 4] = [139u8, 184u8, 221u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlStringArray(string,string)` and selector `0x9f629281`.
    ```solidity
    function parseTomlStringArray(string memory toml, string memory key) external pure returns (string[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlStringArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlStringArray(string,string)`](parseTomlStringArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlStringArrayReturn {
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlStringArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlStringArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlStringArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlStringArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlStringArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlStringArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlStringArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlStringArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlStringArray(string,string)";
            const SELECTOR: [u8; 4] = [159u8, 98u8, 146u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlType(string,string)` and selector `0x47fa5e11`.
    ```solidity
    function parseTomlType(string memory toml, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlType_0Call {
        pub toml: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlType(string,string)`](parseTomlType_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlType_0Return {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlType_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlType_0Call) -> Self {
                    (value.toml, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlType_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, typeDescription: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlType_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlType_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlType_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlType_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlType_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlType(string,string)";
            const SELECTOR: [u8; 4] = [71u8, 250u8, 94u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlType(string,string,string)` and selector `0xf9fa5cdb`.
    ```solidity
    function parseTomlType(string memory toml, string memory key, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlType_1Call {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlType(string,string,string)`](parseTomlType_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlType_1Return {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlType_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlType_1Call) -> Self {
                    (value.toml, value.key, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlType_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1, typeDescription: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlType_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlType_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlType_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlType_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlType_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlType(string,string,string)";
            const SELECTOR: [u8; 4] = [249u8, 250u8, 92u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlTypeArray(string,string,string)` and selector `0x49be3743`.
    ```solidity
    function parseTomlTypeArray(string memory toml, string memory key, string memory typeDescription) external pure returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlTypeArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlTypeArray(string,string,string)`](parseTomlTypeArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlTypeArrayReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlTypeArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlTypeArrayCall) -> Self {
                    (value.toml, value.key, value.typeDescription)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlTypeArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1, typeDescription: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlTypeArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlTypeArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlTypeArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlTypeArrayCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlTypeArrayReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlTypeArray(string,string,string)";
            const SELECTOR: [u8; 4] = [73u8, 190u8, 55u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlUint(string,string)` and selector `0xcc7b0487`.
    ```solidity
    function parseTomlUint(string memory toml, string memory key) external pure returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlUintCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlUint(string,string)`](parseTomlUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlUintCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlUintCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlUint(string,string)";
            const SELECTOR: [u8; 4] = [204u8, 123u8, 4u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseTomlUintArray(string,string)` and selector `0xb5df27c8`.
    ```solidity
    function parseTomlUintArray(string memory toml, string memory key) external pure returns (uint256[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlUintArrayCall {
        pub toml: alloy::sol_types::private::String,
        pub key: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseTomlUintArray(string,string)`](parseTomlUintArrayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseTomlUintArrayReturn {
        pub _0:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlUintArrayCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlUintArrayCall) -> Self {
                    (value.toml, value.key)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlUintArrayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { toml: tuple.0, key: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseTomlUintArrayReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseTomlUintArrayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseTomlUintArrayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseTomlUintArrayCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseTomlUintArrayReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseTomlUintArray(string,string)";
            const SELECTOR: [u8; 4] = [181u8, 223u8, 39u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.toml,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.key,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `parseUint(string)` and selector `0xfa91454d`.
    ```solidity
    function parseUint(string memory stringifiedValue) external pure returns (uint256 parsedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseUintCall {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`parseUint(string)`](parseUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct parseUintReturn {
        pub parsedValue: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: parseUintCall) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<parseUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: parseUintReturn) -> Self {
                    (value.parsedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for parseUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parsedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for parseUintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = parseUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "parseUint(string)";
            const SELECTOR: [u8; 4] = [250u8, 145u8, 69u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.stringifiedValue,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseGasMetering()` and selector `0xd1a5b36f`.
    ```solidity
    function pauseGasMetering() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseGasMeteringCall {}
    ///Container type for the return parameters of the [`pauseGasMetering()`](pauseGasMeteringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseGasMeteringReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseGasMeteringCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseGasMeteringCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseGasMeteringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseGasMeteringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseGasMeteringReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseGasMeteringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseGasMeteringCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseGasMeteringReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseGasMetering()";
            const SELECTOR: [u8; 4] = [209u8, 165u8, 179u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `pauseTracing()` and selector `0xc94d1f90`.
    ```solidity
    function pauseTracing() external view;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseTracingCall {}
    ///Container type for the return parameters of the [`pauseTracing()`](pauseTracingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseTracingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseTracingCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseTracingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseTracingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseTracingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseTracingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseTracingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseTracingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseTracingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseTracing()";
            const SELECTOR: [u8; 4] = [201u8, 77u8, 31u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `projectRoot()` and selector `0xd930a0e6`.
    ```solidity
    function projectRoot() external view returns (string memory path);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct projectRootCall {}
    ///Container type for the return parameters of the [`projectRoot()`](projectRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct projectRootReturn {
        pub path: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<projectRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: projectRootCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for projectRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<projectRootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: projectRootReturn) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for projectRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for projectRootCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = projectRootReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "projectRoot()";
            const SELECTOR: [u8; 4] = [217u8, 48u8, 160u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `prompt(string)` and selector `0x47eaf474`.
    ```solidity
    function prompt(string memory promptText) external returns (string memory input);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptCall {
        pub promptText: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`prompt(string)`](promptCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptReturn {
        pub input: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptCall> for UnderlyingRustTuple<'_> {
                fn from(value: promptCall) -> Self {
                    (value.promptText,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { promptText: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptReturn> for UnderlyingRustTuple<'_> {
                fn from(value: promptReturn) -> Self {
                    (value.input,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for promptCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = promptReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "prompt(string)";
            const SELECTOR: [u8; 4] = [71u8, 234u8, 244u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.promptText,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `promptAddress(string)` and selector `0x62ee05f4`.
    ```solidity
    function promptAddress(string memory promptText) external returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptAddressCall {
        pub promptText: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`promptAddress(string)`](promptAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: promptAddressCall) -> Self {
                    (value.promptText,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { promptText: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: promptAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for promptAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = promptAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "promptAddress(string)";
            const SELECTOR: [u8; 4] = [98u8, 238u8, 5u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.promptText,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `promptSecret(string)` and selector `0x1e279d41`.
    ```solidity
    function promptSecret(string memory promptText) external returns (string memory input);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptSecretCall {
        pub promptText: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`promptSecret(string)`](promptSecretCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptSecretReturn {
        pub input: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptSecretCall> for UnderlyingRustTuple<'_> {
                fn from(value: promptSecretCall) -> Self {
                    (value.promptText,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptSecretCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { promptText: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptSecretReturn> for UnderlyingRustTuple<'_> {
                fn from(value: promptSecretReturn) -> Self {
                    (value.input,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptSecretReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for promptSecretCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = promptSecretReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "promptSecret(string)";
            const SELECTOR: [u8; 4] = [30u8, 39u8, 157u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.promptText,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `promptSecretUint(string)` and selector `0x69ca02b7`.
    ```solidity
    function promptSecretUint(string memory promptText) external returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptSecretUintCall {
        pub promptText: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`promptSecretUint(string)`](promptSecretUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptSecretUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptSecretUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: promptSecretUintCall) -> Self {
                    (value.promptText,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptSecretUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { promptText: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptSecretUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: promptSecretUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptSecretUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for promptSecretUintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = promptSecretUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "promptSecretUint(string)";
            const SELECTOR: [u8; 4] = [105u8, 202u8, 2u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.promptText,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `promptUint(string)` and selector `0x652fd489`.
    ```solidity
    function promptUint(string memory promptText) external returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptUintCall {
        pub promptText: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`promptUint(string)`](promptUintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct promptUintReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptUintCall> for UnderlyingRustTuple<'_> {
                fn from(value: promptUintCall) -> Self {
                    (value.promptText,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptUintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { promptText: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<promptUintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: promptUintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for promptUintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for promptUintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = promptUintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "promptUint(string)";
            const SELECTOR: [u8; 4] = [101u8, 47u8, 212u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.promptText,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `publicKeyP256(uint256)` and selector `0xc453949e`.
    ```solidity
    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct publicKeyP256Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`publicKeyP256(uint256)`](publicKeyP256Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct publicKeyP256Return {
        pub publicKeyX: alloy::sol_types::private::primitives::aliases::U256,
        pub publicKeyY: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<publicKeyP256Call> for UnderlyingRustTuple<'_> {
                fn from(value: publicKeyP256Call) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for publicKeyP256Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<publicKeyP256Return> for UnderlyingRustTuple<'_> {
                fn from(value: publicKeyP256Return) -> Self {
                    (value.publicKeyX, value.publicKeyY)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for publicKeyP256Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { publicKeyX: tuple.0, publicKeyY: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for publicKeyP256Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = publicKeyP256Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "publicKeyP256(uint256)";
            const SELECTOR: [u8; 4] = [196u8, 83u8, 148u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomAddress()` and selector `0xd5bee9f5`.
    ```solidity
    function randomAddress() external returns (address);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomAddressCall {}
    ///Container type for the return parameters of the [`randomAddress()`](randomAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomAddressReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomAddressCall> for UnderlyingRustTuple<'_> {
                fn from(value: randomAddressCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomAddressReturn> for UnderlyingRustTuple<'_> {
                fn from(value: randomAddressReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomAddressCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomAddressReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomAddress()";
            const SELECTOR: [u8; 4] = [213u8, 190u8, 233u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomBool()` and selector `0xcdc126bd`.
    ```solidity
    function randomBool() external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBoolCall {}
    ///Container type for the return parameters of the [`randomBool()`](randomBoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBoolReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBoolCall> for UnderlyingRustTuple<'_> {
                fn from(value: randomBoolCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBoolReturn> for UnderlyingRustTuple<'_> {
                fn from(value: randomBoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomBoolCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomBoolReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomBool()";
            const SELECTOR: [u8; 4] = [205u8, 193u8, 38u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomBytes(uint256)` and selector `0x6c5d32a9`.
    ```solidity
    function randomBytes(uint256 len) external view returns (bytes memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytesCall {
        pub len: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomBytes(uint256)`](randomBytesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytesReturn {
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytesCall> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytesCall) -> Self {
                    (value.len,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { len: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomBytesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomBytesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomBytes(uint256)";
            const SELECTOR: [u8; 4] = [108u8, 93u8, 50u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.len,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomBytes4()` and selector `0x9b7cd579`.
    ```solidity
    function randomBytes4() external view returns (bytes4);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytes4Call {}
    ///Container type for the return parameters of the [`randomBytes4()`](randomBytes4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytes4Return {
        pub _0: alloy::sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytes4Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytes4Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytes4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytes4Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytes4Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytes4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomBytes4Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomBytes4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomBytes4()";
            const SELECTOR: [u8; 4] = [155u8, 124u8, 213u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomBytes8()` and selector `0x0497b0a5`.
    ```solidity
    function randomBytes8() external view returns (bytes8);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytes8Call {}
    ///Container type for the return parameters of the [`randomBytes8()`](randomBytes8Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomBytes8Return {
        pub _0: alloy::sol_types::private::FixedBytes<8>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytes8Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytes8Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytes8Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<8>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomBytes8Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomBytes8Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomBytes8Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomBytes8Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomBytes8Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomBytes8()";
            const SELECTOR: [u8; 4] = [4u8, 151u8, 176u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomInt()` and selector `0x111f1202`.
    ```solidity
    function randomInt() external view returns (int256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomInt_0Call {}
    ///Container type for the return parameters of the [`randomInt()`](randomInt_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomInt_0Return {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomInt_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomInt_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomInt_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomInt_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomInt_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomInt_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomInt_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomInt_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomInt()";
            const SELECTOR: [u8; 4] = [17u8, 31u8, 18u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomInt(uint256)` and selector `0x12845966`.
    ```solidity
    function randomInt(uint256 bits) external view returns (int256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomInt_1Call {
        pub bits: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomInt(uint256)`](randomInt_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomInt_1Return {
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomInt_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomInt_1Call) -> Self {
                    (value.bits,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomInt_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bits: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomInt_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomInt_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomInt_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomInt_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomInt_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomInt(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 132u8, 89u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.bits,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomUint()` and selector `0x25124730`.
    ```solidity
    function randomUint() external returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_0Call {}
    ///Container type for the return parameters of the [`randomUint()`](randomUint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_0Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomUint_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomUint_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomUint()";
            const SELECTOR: [u8; 4] = [37u8, 18u8, 71u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomUint(uint256)` and selector `0xcf81e69c`.
    ```solidity
    function randomUint(uint256 bits) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_1Call {
        pub bits: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomUint(uint256)`](randomUint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_1Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_1Call) -> Self {
                    (value.bits,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bits: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomUint_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomUint_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomUint(uint256)";
            const SELECTOR: [u8; 4] = [207u8, 129u8, 230u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.bits,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `randomUint(uint256,uint256)` and selector `0xd61b051b`.
    ```solidity
    function randomUint(uint256 min, uint256 max) external returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_2Call {
        pub min: alloy::sol_types::private::primitives::aliases::U256,
        pub max: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`randomUint(uint256,uint256)`](randomUint_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct randomUint_2Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_2Call) -> Self {
                    (value.min, value.max)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { min: tuple.0, max: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<randomUint_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: randomUint_2Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for randomUint_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for randomUint_2Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = randomUint_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "randomUint(uint256,uint256)";
            const SELECTOR: [u8; 4] = [214u8, 27u8, 5u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.min,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.max,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readDir(string,uint64)` and selector `0x1497876c`.
    ```solidity
    function readDir(string memory path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_0Call {
        pub path: alloy::sol_types::private::String,
        pub maxDepth: u64,
    }
    ///Container type for the return parameters of the [`readDir(string,uint64)`](readDir_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_0Return {
        pub entries:
            alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_0Call) -> Self {
                    (value.path, value.maxDepth)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, maxDepth: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_0Return) -> Self {
                    (value.entries,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { entries: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readDir_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Uint<64>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readDir_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readDir(string,uint64)";
            const SELECTOR: [u8; 4] = [20u8, 151u8, 135u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDepth,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readDir(string,uint64,bool)` and selector `0x8102d70d`.
    ```solidity
    function readDir(string memory path, uint64 maxDepth, bool followLinks) external view returns (DirEntry[] memory entries);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_1Call {
        pub path: alloy::sol_types::private::String,
        pub maxDepth: u64,
        pub followLinks: bool,
    }
    ///Container type for the return parameters of the [`readDir(string,uint64,bool)`](readDir_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_1Return {
        pub entries:
            alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, u64, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_1Call) -> Self {
                    (value.path, value.maxDepth, value.followLinks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, maxDepth: tuple.1, followLinks: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_1Return) -> Self {
                    (value.entries,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { entries: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readDir_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readDir_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readDir(string,uint64,bool)";
            const SELECTOR: [u8; 4] = [129u8, 2u8, 215u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Uint<64> as alloy_sol_types::SolType>::tokenize(
                        &self.maxDepth,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.followLinks,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readDir(string)` and selector `0xc4bc59e0`.
    ```solidity
    function readDir(string memory path) external view returns (DirEntry[] memory entries);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_2Call {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`readDir(string)`](readDir_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readDir_2Return {
        pub entries:
            alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_2Call) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<<DirEntry as alloy::sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readDir_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: readDir_2Return) -> Self {
                    (value.entries,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readDir_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { entries: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readDir_2Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readDir_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<DirEntry>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readDir(string)";
            const SELECTOR: [u8; 4] = [196u8, 188u8, 89u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readFile(string)` and selector `0x60f9bb11`.
    ```solidity
    function readFile(string memory path) external view returns (string memory data);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readFileCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`readFile(string)`](readFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readFileReturn {
        pub data: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: readFileCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readFileReturn) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readFileCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readFileReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readFile(string)";
            const SELECTOR: [u8; 4] = [96u8, 249u8, 187u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readFileBinary(string)` and selector `0x16ed7bc4`.
    ```solidity
    function readFileBinary(string memory path) external view returns (bytes memory data);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readFileBinaryCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`readFileBinary(string)`](readFileBinaryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readFileBinaryReturn {
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readFileBinaryCall> for UnderlyingRustTuple<'_> {
                fn from(value: readFileBinaryCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readFileBinaryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readFileBinaryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readFileBinaryReturn) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readFileBinaryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readFileBinaryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readFileBinaryReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readFileBinary(string)";
            const SELECTOR: [u8; 4] = [22u8, 237u8, 123u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readLine(string)` and selector `0x70f55728`.
    ```solidity
    function readLine(string memory path) external view returns (string memory line);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readLineCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`readLine(string)`](readLineCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readLineReturn {
        pub line: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readLineCall> for UnderlyingRustTuple<'_> {
                fn from(value: readLineCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readLineCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readLineReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readLineReturn) -> Self {
                    (value.line,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readLineReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { line: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readLineCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readLineReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readLine(string)";
            const SELECTOR: [u8; 4] = [112u8, 245u8, 87u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `readLink(string)` and selector `0x9f5684a2`.
    ```solidity
    function readLink(string memory linkPath) external view returns (string memory targetPath);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readLinkCall {
        pub linkPath: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`readLink(string)`](readLinkCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readLinkReturn {
        pub targetPath: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readLinkCall> for UnderlyingRustTuple<'_> {
                fn from(value: readLinkCall) -> Self {
                    (value.linkPath,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readLinkCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { linkPath: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readLinkReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readLinkReturn) -> Self {
                    (value.targetPath,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readLinkReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { targetPath: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readLinkCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = readLinkReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "readLink(string)";
            const SELECTOR: [u8; 4] = [159u8, 86u8, 132u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.linkPath,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `record()` and selector `0x266cf109`.
    ```solidity
    function record() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recordCall {}
    ///Container type for the return parameters of the [`record()`](recordCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recordReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recordCall> for UnderlyingRustTuple<'_> {
                fn from(value: recordCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recordCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recordReturn> for UnderlyingRustTuple<'_> {
                fn from(value: recordReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recordReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recordCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = recordReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "record()";
            const SELECTOR: [u8; 4] = [38u8, 108u8, 241u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `recordLogs()` and selector `0x41af2f52`.
    ```solidity
    function recordLogs() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recordLogsCall {}
    ///Container type for the return parameters of the [`recordLogs()`](recordLogsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recordLogsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recordLogsCall> for UnderlyingRustTuple<'_> {
                fn from(value: recordLogsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recordLogsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recordLogsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: recordLogsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for recordLogsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recordLogsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = recordLogsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recordLogs()";
            const SELECTOR: [u8; 4] = [65u8, 175u8, 47u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rememberKey(uint256)` and selector `0x22100064`.
    ```solidity
    function rememberKey(uint256 privateKey) external returns (address keyAddr);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeyCall {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`rememberKey(uint256)`](rememberKeyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeyReturn {
        pub keyAddr: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeyCall) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeyReturn) -> Self {
                    (value.keyAddr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyAddr: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rememberKeyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rememberKeyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rememberKey(uint256)";
            const SELECTOR: [u8; 4] = [34u8, 16u8, 0u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rememberKeys(string,string,uint32)` and selector `0x97cb9189`.
    ```solidity
    function rememberKeys(string memory mnemonic, string memory derivationPath, uint32 count) external returns (address[] memory keyAddrs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeys_0Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub derivationPath: alloy::sol_types::private::String,
        pub count: u32,
    }
    ///Container type for the return parameters of the [`rememberKeys(string,string,uint32)`](rememberKeys_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeys_0Return {
        pub keyAddrs: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeys_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeys_0Call) -> Self {
                    (value.mnemonic, value.derivationPath, value.count)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeys_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { mnemonic: tuple.0, derivationPath: tuple.1, count: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeys_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeys_0Return) -> Self {
                    (value.keyAddrs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeys_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyAddrs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rememberKeys_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rememberKeys_0Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rememberKeys(string,string,uint32)";
            const SELECTOR: [u8; 4] = [151u8, 203u8, 145u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.derivationPath,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.count,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rememberKeys(string,string,string,uint32)` and selector `0xf8d58eaf`.
    ```solidity
    function rememberKeys(string memory mnemonic, string memory derivationPath, string memory language, uint32 count) external returns (address[] memory keyAddrs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeys_1Call {
        pub mnemonic: alloy::sol_types::private::String,
        pub derivationPath: alloy::sol_types::private::String,
        pub language: alloy::sol_types::private::String,
        pub count: u32,
    }
    ///Container type for the return parameters of the [`rememberKeys(string,string,string,uint32)`](rememberKeys_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rememberKeys_1Return {
        pub keyAddrs: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeys_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeys_1Call) -> Self {
                    (value.mnemonic, value.derivationPath, value.language, value.count)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeys_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        mnemonic: tuple.0,
                        derivationPath: tuple.1,
                        language: tuple.2,
                        count: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rememberKeys_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: rememberKeys_1Return) -> Self {
                    (value.keyAddrs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rememberKeys_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { keyAddrs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rememberKeys_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rememberKeys_1Return;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rememberKeys(string,string,string,uint32)";
            const SELECTOR: [u8; 4] = [248u8, 213u8, 142u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.mnemonic,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.derivationPath,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.language,
                    ),
                    <alloy::sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.count,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `removeDir(string,bool)` and selector `0x45c62011`.
    ```solidity
    function removeDir(string memory path, bool recursive) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeDirCall {
        pub path: alloy::sol_types::private::String,
        pub recursive: bool,
    }
    ///Container type for the return parameters of the [`removeDir(string,bool)`](removeDirCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeDirReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeDirCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeDirCall) -> Self {
                    (value.path, value.recursive)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeDirCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, recursive: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeDirReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeDirReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeDirReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeDirCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeDirReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeDir(string,bool)";
            const SELECTOR: [u8; 4] = [69u8, 198u8, 32u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.recursive,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `removeFile(string)` and selector `0xf1afe04d`.
    ```solidity
    function removeFile(string memory path) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeFileCall {
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`removeFile(string)`](removeFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeFileReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeFileCall) -> Self {
                    (value.path,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeFileReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeFileCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeFileReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeFile(string)";
            const SELECTOR: [u8; 4] = [241u8, 175u8, 224u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.path,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `replace(string,string,string)` and selector `0xe00ad03e`.
    ```solidity
    function replace(string memory input, string memory from, string memory to) external pure returns (string memory output);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct replaceCall {
        pub input: alloy::sol_types::private::String,
        pub from: alloy::sol_types::private::String,
        pub to: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`replace(string,string,string)`](replaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct replaceReturn {
        pub output: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<replaceCall> for UnderlyingRustTuple<'_> {
                fn from(value: replaceCall) -> Self {
                    (value.input, value.from, value.to)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for replaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0, from: tuple.1, to: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<replaceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: replaceReturn) -> Self {
                    (value.output,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for replaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { output: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for replaceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = replaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "replace(string,string,string)";
            const SELECTOR: [u8; 4] = [224u8, 10u8, 208u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.input,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `resetGasMetering()` and selector `0xbe367dd3`.
    ```solidity
    function resetGasMetering() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resetGasMeteringCall {}
    ///Container type for the return parameters of the [`resetGasMetering()`](resetGasMeteringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resetGasMeteringReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resetGasMeteringCall> for UnderlyingRustTuple<'_> {
                fn from(value: resetGasMeteringCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resetGasMeteringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resetGasMeteringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resetGasMeteringReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resetGasMeteringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resetGasMeteringCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = resetGasMeteringReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resetGasMetering()";
            const SELECTOR: [u8; 4] = [190u8, 54u8, 125u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeGasMetering()` and selector `0x2bcd50e0`.
    ```solidity
    function resumeGasMetering() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeGasMeteringCall {}
    ///Container type for the return parameters of the [`resumeGasMetering()`](resumeGasMeteringCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeGasMeteringReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeGasMeteringCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeGasMeteringCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeGasMeteringCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeGasMeteringReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resumeGasMeteringReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeGasMeteringReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeGasMeteringCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeGasMeteringReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeGasMetering()";
            const SELECTOR: [u8; 4] = [43u8, 205u8, 80u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `resumeTracing()` and selector `0x72a09ccb`.
    ```solidity
    function resumeTracing() external view;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeTracingCall {}
    ///Container type for the return parameters of the [`resumeTracing()`](resumeTracingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct resumeTracingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeTracingCall> for UnderlyingRustTuple<'_> {
                fn from(value: resumeTracingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeTracingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<resumeTracingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: resumeTracingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for resumeTracingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for resumeTracingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = resumeTracingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "resumeTracing()";
            const SELECTOR: [u8; 4] = [114u8, 160u8, 156u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rpc(string,string,string)` and selector `0x0199a220`.
    ```solidity
    function rpc(string memory urlOrAlias, string memory method, string memory params) external returns (bytes memory data);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpc_0Call {
        pub urlOrAlias: alloy::sol_types::private::String,
        pub method: alloy::sol_types::private::String,
        pub params: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`rpc(string,string,string)`](rpc_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpc_0Return {
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpc_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: rpc_0Call) -> Self {
                    (value.urlOrAlias, value.method, value.params)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpc_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { urlOrAlias: tuple.0, method: tuple.1, params: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpc_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: rpc_0Return) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpc_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rpc_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rpc_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rpc(string,string,string)";
            const SELECTOR: [u8; 4] = [1u8, 153u8, 162u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.urlOrAlias,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.method,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rpc(string,string)` and selector `0x1206c8a8`.
    ```solidity
    function rpc(string memory method, string memory params) external returns (bytes memory data);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpc_1Call {
        pub method: alloy::sol_types::private::String,
        pub params: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`rpc(string,string)`](rpc_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpc_1Return {
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpc_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: rpc_1Call) -> Self {
                    (value.method, value.params)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpc_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { method: tuple.0, params: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpc_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: rpc_1Return) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpc_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rpc_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rpc_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rpc(string,string)";
            const SELECTOR: [u8; 4] = [18u8, 6u8, 200u8, 168u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.method,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.params,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rpcUrl(string)` and selector `0x975a6ce9`.
    ```solidity
    function rpcUrl(string memory rpcAlias) external view returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlCall {
        pub rpcAlias: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`rpcUrl(string)`](rpcUrlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlReturn {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlCall> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlCall) -> Self {
                    (value.rpcAlias,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { rpcAlias: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlReturn) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rpcUrlCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rpcUrlReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rpcUrl(string)";
            const SELECTOR: [u8; 4] = [151u8, 90u8, 108u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.rpcAlias,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rpcUrlStructs()` and selector `0x9d2ad72a`.
    ```solidity
    function rpcUrlStructs() external view returns (Rpc[] memory urls);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlStructsCall {}
    ///Container type for the return parameters of the [`rpcUrlStructs()`](rpcUrlStructsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlStructsReturn {
        pub urls: alloy::sol_types::private::Vec<<Rpc as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlStructsCall> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlStructsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlStructsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<Rpc>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<<Rpc as alloy::sol_types::SolType>::RustType>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlStructsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlStructsReturn) -> Self {
                    (value.urls,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlStructsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { urls: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rpcUrlStructsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rpcUrlStructsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<Rpc>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rpcUrlStructs()";
            const SELECTOR: [u8; 4] = [157u8, 42u8, 215u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `rpcUrls()` and selector `0xa85a8418`.
    ```solidity
    function rpcUrls() external view returns (string[2][] memory urls);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlsCall {}
    ///Container type for the return parameters of the [`rpcUrls()`](rpcUrlsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rpcUrlsReturn {
        pub urls: alloy::sol_types::private::Vec<[alloy::sol_types::private::String; 2usize]>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlsCall> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::String,
                        2usize,
                    >,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<[alloy::sol_types::private::String; 2usize]>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rpcUrlsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rpcUrlsReturn) -> Self {
                    (value.urls,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rpcUrlsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { urls: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rpcUrlsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = rpcUrlsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::String,
                        2usize,
                    >,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rpcUrls()";
            const SELECTOR: [u8; 4] = [168u8, 90u8, 132u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeAddress(string,string,address[])` and selector `0x1e356e1a`.
    ```solidity
    function serializeAddress(string memory objectKey, string memory valueKey, address[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeAddress_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    ///Container type for the return parameters of the [`serializeAddress(string,string,address[])`](serializeAddress_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeAddress_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeAddress_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeAddress_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeAddress_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeAddress_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeAddress_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeAddress_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeAddress_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeAddress_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeAddress(string,string,address[])";
            const SELECTOR: [u8; 4] = [30u8, 53u8, 110u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeAddress(string,string,address)` and selector `0x972c6062`.
    ```solidity
    function serializeAddress(string memory objectKey, string memory valueKey, address value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeAddress_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`serializeAddress(string,string,address)`](serializeAddress_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeAddress_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeAddress_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeAddress_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeAddress_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeAddress_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeAddress_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeAddress_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeAddress_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeAddress_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeAddress(string,string,address)";
            const SELECTOR: [u8; 4] = [151u8, 44u8, 96u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBool(string,string,bool[])` and selector `0x92925aa1`.
    ```solidity
    function serializeBool(string memory objectKey, string memory valueKey, bool[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBool_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values: alloy::sol_types::private::Vec<bool>,
    }
    ///Container type for the return parameters of the [`serializeBool(string,string,bool[])`](serializeBool_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBool_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<bool>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBool_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBool_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBool_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBool_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBool_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBool_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBool_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bool>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBool_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBool(string,string,bool[])";
            const SELECTOR: [u8; 4] = [146u8, 146u8, 90u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bool,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBool(string,string,bool)` and selector `0xac22e971`.
    ```solidity
    function serializeBool(string memory objectKey, string memory valueKey, bool value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBool_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: bool,
    }
    ///Container type for the return parameters of the [`serializeBool(string,string,bool)`](serializeBool_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBool_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBool_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBool_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBool_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBool_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBool_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBool_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBool_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBool_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBool(string,string,bool)";
            const SELECTOR: [u8; 4] = [172u8, 34u8, 233u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBytes(string,string,bytes[])` and selector `0x9884b232`.
    ```solidity
    function serializeBytes(string memory objectKey, string memory valueKey, bytes[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    ///Container type for the return parameters of the [`serializeBytes(string,string,bytes[])`](serializeBytes_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBytes_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBytes_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBytes(string,string,bytes[])";
            const SELECTOR: [u8; 4] = [152u8, 132u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBytes(string,string,bytes)` and selector `0xf21d52c7`.
    ```solidity
    function serializeBytes(string memory objectKey, string memory valueKey, bytes memory value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`serializeBytes(string,string,bytes)`](serializeBytes_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBytes_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBytes_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBytes(string,string,bytes)";
            const SELECTOR: [u8; 4] = [242u8, 29u8, 82u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBytes32(string,string,bytes32[])` and selector `0x201e43e2`.
    ```solidity
    function serializeBytes32(string memory objectKey, string memory valueKey, bytes32[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes32_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
    }
    ///Container type for the return parameters of the [`serializeBytes32(string,string,bytes32[])`](serializeBytes32_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes32_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes32_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes32_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes32_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes32_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes32_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes32_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBytes32_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBytes32_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBytes32(string,string,bytes32[])";
            const SELECTOR: [u8; 4] = [32u8, 30u8, 67u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeBytes32(string,string,bytes32)` and selector `0x2d812b44`.
    ```solidity
    function serializeBytes32(string memory objectKey, string memory valueKey, bytes32 value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes32_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`serializeBytes32(string,string,bytes32)`](serializeBytes32_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeBytes32_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes32_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes32_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes32_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeBytes32_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeBytes32_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeBytes32_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeBytes32_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeBytes32_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeBytes32(string,string,bytes32)";
            const SELECTOR: [u8; 4] = [45u8, 129u8, 43u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeInt(string,string,int256)` and selector `0x3f33db60`.
    ```solidity
    function serializeInt(string memory objectKey, string memory valueKey, int256 value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeInt_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`serializeInt(string,string,int256)`](serializeInt_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeInt_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Int<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeInt_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeInt_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeInt_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeInt_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeInt_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeInt_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeInt_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Int<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeInt_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeInt(string,string,int256)";
            const SELECTOR: [u8; 4] = [63u8, 51u8, 219u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeInt(string,string,int256[])` and selector `0x7676e127`.
    ```solidity
    function serializeInt(string memory objectKey, string memory valueKey, int256[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeInt_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::I256>,
    }
    ///Container type for the return parameters of the [`serializeInt(string,string,int256[])`](serializeInt_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeInt_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::I256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeInt_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeInt_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeInt_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeInt_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeInt_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeInt_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeInt_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Int<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeInt_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeInt(string,string,int256[])";
            const SELECTOR: [u8; 4] = [118u8, 118u8, 225u8, 39u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Int<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeJson(string,string)` and selector `0x9b3358b0`.
    ```solidity
    function serializeJson(string memory objectKey, string memory value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonCall {
        pub objectKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`serializeJson(string,string)`](serializeJsonCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonReturn {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonCall> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonCall) -> Self {
                    (value.objectKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, value: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonReturn> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonReturn) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeJsonCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeJsonReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeJson(string,string)";
            const SELECTOR: [u8; 4] = [155u8, 51u8, 88u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeJsonType(string,bytes)` and selector `0x6d4f96a6`.
    ```solidity
    function serializeJsonType(string memory typeDescription, bytes memory value) external pure returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonType_0Call {
        pub typeDescription: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`serializeJsonType(string,bytes)`](serializeJsonType_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonType_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonType_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonType_0Call) -> Self {
                    (value.typeDescription, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonType_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { typeDescription: tuple.0, value: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonType_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonType_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonType_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeJsonType_0Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeJsonType_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeJsonType(string,bytes)";
            const SELECTOR: [u8; 4] = [109u8, 79u8, 150u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeJsonType(string,string,string,bytes)` and selector `0x6f93bccb`.
    ```solidity
    function serializeJsonType(string memory objectKey, string memory valueKey, string memory typeDescription, bytes memory value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonType_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub typeDescription: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`serializeJsonType(string,string,string,bytes)`](serializeJsonType_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeJsonType_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonType_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonType_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.typeDescription, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonType_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        objectKey: tuple.0,
                        valueKey: tuple.1,
                        typeDescription: tuple.2,
                        value: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeJsonType_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeJsonType_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeJsonType_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeJsonType_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeJsonType_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeJsonType(string,string,string,bytes)";
            const SELECTOR: [u8; 4] = [111u8, 147u8, 188u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.typeDescription,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeString(string,string,string[])` and selector `0x561cd6f3`.
    ```solidity
    function serializeString(string memory objectKey, string memory valueKey, string[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeString_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`serializeString(string,string,string[])`](serializeString_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeString_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeString_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeString_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeString_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeString_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeString_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeString_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeString_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeString_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeString(string,string,string[])";
            const SELECTOR: [u8; 4] = [86u8, 28u8, 214u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeString(string,string,string)` and selector `0x88da6d35`.
    ```solidity
    function serializeString(string memory objectKey, string memory valueKey, string memory value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeString_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`serializeString(string,string,string)`](serializeString_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeString_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeString_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeString_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeString_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeString_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeString_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeString_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeString_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeString_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeString(string,string,string)";
            const SELECTOR: [u8; 4] = [136u8, 218u8, 109u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeUint(string,string,uint256)` and selector `0x129e9002`.
    ```solidity
    function serializeUint(string memory objectKey, string memory valueKey, uint256 value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUint_0Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`serializeUint(string,string,uint256)`](serializeUint_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUint_0Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUint_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUint_0Call) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUint_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUint_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUint_0Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUint_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeUint_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeUint_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeUint(string,string,uint256)";
            const SELECTOR: [u8; 4] = [18u8, 158u8, 144u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeUint(string,string,uint256[])` and selector `0xfee9a469`.
    ```solidity
    function serializeUint(string memory objectKey, string memory valueKey, uint256[] memory values) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUint_1Call {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub values:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`serializeUint(string,string,uint256[])`](serializeUint_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUint_1Return {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUint_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUint_1Call) -> Self {
                    (value.objectKey, value.valueKey, value.values)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUint_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, values: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUint_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUint_1Return) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUint_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeUint_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeUint_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeUint(string,string,uint256[])";
            const SELECTOR: [u8; 4] = [254u8, 233u8, 164u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `serializeUintToHex(string,string,uint256)` and selector `0xae5a2ae8`.
    ```solidity
    function serializeUintToHex(string memory objectKey, string memory valueKey, uint256 value) external returns (string memory json);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUintToHexCall {
        pub objectKey: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`serializeUintToHex(string,string,uint256)`](serializeUintToHexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serializeUintToHexReturn {
        pub json: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUintToHexCall> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUintToHexCall) -> Self {
                    (value.objectKey, value.valueKey, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUintToHexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { objectKey: tuple.0, valueKey: tuple.1, value: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serializeUintToHexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: serializeUintToHexReturn) -> Self {
                    (value.json,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serializeUintToHexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serializeUintToHexCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serializeUintToHexReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serializeUintToHex(string,string,uint256)";
            const SELECTOR: [u8; 4] = [174u8, 90u8, 42u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.objectKey,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setArbitraryStorage(address)` and selector `0xe1631837`.
    ```solidity
    function setArbitraryStorage(address target) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setArbitraryStorageCall {
        pub target: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setArbitraryStorage(address)`](setArbitraryStorageCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setArbitraryStorageReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setArbitraryStorageCall> for UnderlyingRustTuple<'_> {
                fn from(value: setArbitraryStorageCall) -> Self {
                    (value.target,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setArbitraryStorageCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { target: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setArbitraryStorageReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setArbitraryStorageReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setArbitraryStorageReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setArbitraryStorageCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setArbitraryStorageReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setArbitraryStorage(address)";
            const SELECTOR: [u8; 4] = [225u8, 99u8, 24u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.target,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setEnv(string,string)` and selector `0x3d5923ee`.
    ```solidity
    function setEnv(string memory name, string memory value) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setEnvCall {
        pub name: alloy::sol_types::private::String,
        pub value: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`setEnv(string,string)`](setEnvCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setEnvReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEnvCall> for UnderlyingRustTuple<'_> {
                fn from(value: setEnvCall) -> Self {
                    (value.name, value.value)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setEnvCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { name: tuple.0, value: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEnvReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setEnvReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setEnvReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setEnvCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setEnvReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setEnv(string,string)";
            const SELECTOR: [u8; 4] = [61u8, 89u8, 35u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sign(bytes32)` and selector `0x799cd333`.
    ```solidity
    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_0Call {
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`sign(bytes32)`](sign_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_0Return {
        pub v: u8,
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: sign_0Call) -> Self {
                    (value.digest,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { digest: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: sign_0Return) -> Self {
                    (value.v, value.r, value.s)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { v: tuple.0, r: tuple.1, s: tuple.2 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sign_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = sign_0Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sign(bytes32)";
            const SELECTOR: [u8; 4] = [121u8, 156u8, 211u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sign(address,bytes32)` and selector `0x8c1aa205`.
    ```solidity
    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_1Call {
        pub signer: alloy::sol_types::private::Address,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`sign(address,bytes32)`](sign_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_1Return {
        pub v: u8,
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: sign_1Call) -> Self {
                    (value.signer, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signer: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: sign_1Return) -> Self {
                    (value.v, value.r, value.s)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { v: tuple.0, r: tuple.1, s: tuple.2 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sign_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = sign_1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sign(address,bytes32)";
            const SELECTOR: [u8; 4] = [140u8, 26u8, 162u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sign((address,uint256,uint256,uint256),bytes32)` and selector `0xb25c5a25`.
    ```solidity
    function sign(Wallet memory wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_2Call {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`sign((address,uint256,uint256,uint256),bytes32)`](sign_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_2Return {
        pub v: u8,
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Wallet as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: sign_2Call) -> Self {
                    (value.wallet, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: sign_2Return) -> Self {
                    (value.v, value.r, value.s)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { v: tuple.0, r: tuple.1, s: tuple.2 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sign_2Call {
            type Parameters<'a> = (Wallet, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = sign_2Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sign((address,uint256,uint256,uint256),bytes32)";
            const SELECTOR: [u8; 4] = [178u8, 92u8, 90u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Wallet as alloy_sol_types::SolType>::tokenize(&self.wallet),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sign(uint256,bytes32)` and selector `0xe341eaa4`.
    ```solidity
    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_3Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`sign(uint256,bytes32)`](sign_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sign_3Return {
        pub v: u8,
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: sign_3Call) -> Self {
                    (value.privateKey, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sign_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: sign_3Return) -> Self {
                    (value.v, value.r, value.s)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sign_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { v: tuple.0, r: tuple.1, s: tuple.2 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sign_3Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = sign_3Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sign(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [227u8, 65u8, 234u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.privateKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signAndAttachDelegation(address,uint256)` and selector `0xc7fa7288`.
    ```solidity
    function signAndAttachDelegation(address implementation, uint256 privateKey) external returns (SignedDelegation memory signedDelegation);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signAndAttachDelegationCall {
        pub implementation: alloy::sol_types::private::Address,
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`signAndAttachDelegation(address,uint256)`](signAndAttachDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signAndAttachDelegationReturn {
        pub signedDelegation: <SignedDelegation as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signAndAttachDelegationCall> for UnderlyingRustTuple<'_> {
                fn from(value: signAndAttachDelegationCall) -> Self {
                    (value.implementation, value.privateKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signAndAttachDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0, privateKey: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SignedDelegation,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<SignedDelegation as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signAndAttachDelegationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: signAndAttachDelegationReturn) -> Self {
                    (value.signedDelegation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signAndAttachDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signedDelegation: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signAndAttachDelegationCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signAndAttachDelegationReturn;
            type ReturnTuple<'a> = (SignedDelegation,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signAndAttachDelegation(address,uint256)";
            const SELECTOR: [u8; 4] = [199u8, 250u8, 114u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.privateKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signCompact((address,uint256,uint256,uint256),bytes32)` and selector `0x3d0e292f`.
    ```solidity
    function signCompact(Wallet memory wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_0Call {
        pub wallet: <Wallet as alloy::sol_types::SolType>::RustType,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`signCompact((address,uint256,uint256,uint256),bytes32)`](signCompact_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_0Return {
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub vs: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Wallet, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Wallet as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_0Call) -> Self {
                    (value.wallet, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { wallet: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_0Return) -> Self {
                    (value.r, value.vs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r: tuple.0, vs: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signCompact_0Call {
            type Parameters<'a> = (Wallet, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signCompact_0Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "signCompact((address,uint256,uint256,uint256),bytes32)";
            const SELECTOR: [u8; 4] = [61u8, 14u8, 41u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Wallet as alloy_sol_types::SolType>::tokenize(&self.wallet),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signCompact(address,bytes32)` and selector `0x8e2f97bf`.
    ```solidity
    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_1Call {
        pub signer: alloy::sol_types::private::Address,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`signCompact(address,bytes32)`](signCompact_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_1Return {
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub vs: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_1Call) -> Self {
                    (value.signer, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signer: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_1Return) -> Self {
                    (value.r, value.vs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r: tuple.0, vs: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signCompact_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signCompact_1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signCompact(address,bytes32)";
            const SELECTOR: [u8; 4] = [142u8, 47u8, 151u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.signer,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signCompact(bytes32)` and selector `0xa282dc4b`.
    ```solidity
    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_2Call {
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`signCompact(bytes32)`](signCompact_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_2Return {
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub vs: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_2Call) -> Self {
                    (value.digest,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { digest: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_2Return) -> Self {
                    (value.r, value.vs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r: tuple.0, vs: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signCompact_2Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signCompact_2Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signCompact(bytes32)";
            const SELECTOR: [u8; 4] = [162u8, 130u8, 220u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signCompact(uint256,bytes32)` and selector `0xcc2a781f`.
    ```solidity
    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_3Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`signCompact(uint256,bytes32)`](signCompact_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signCompact_3Return {
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub vs: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_3Call) -> Self {
                    (value.privateKey, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signCompact_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: signCompact_3Return) -> Self {
                    (value.r, value.vs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signCompact_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r: tuple.0, vs: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signCompact_3Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signCompact_3Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signCompact(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [204u8, 42u8, 120u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.privateKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signDelegation(address,uint256)` and selector `0x5b593c7b`.
    ```solidity
    function signDelegation(address implementation, uint256 privateKey) external returns (SignedDelegation memory signedDelegation);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signDelegationCall {
        pub implementation: alloy::sol_types::private::Address,
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`signDelegation(address,uint256)`](signDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signDelegationReturn {
        pub signedDelegation: <SignedDelegation as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signDelegationCall> for UnderlyingRustTuple<'_> {
                fn from(value: signDelegationCall) -> Self {
                    (value.implementation, value.privateKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { implementation: tuple.0, privateKey: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SignedDelegation,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<SignedDelegation as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signDelegationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: signDelegationReturn) -> Self {
                    (value.signedDelegation,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signedDelegation: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signDelegationCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signDelegationReturn;
            type ReturnTuple<'a> = (SignedDelegation,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signDelegation(address,uint256)";
            const SELECTOR: [u8; 4] = [91u8, 89u8, 60u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.privateKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `signP256(uint256,bytes32)` and selector `0x83211b40`.
    ```solidity
    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signP256Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
        pub digest: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`signP256(uint256,bytes32)`](signP256Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct signP256Return {
        pub r: alloy::sol_types::private::FixedBytes<32>,
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signP256Call> for UnderlyingRustTuple<'_> {
                fn from(value: signP256Call) -> Self {
                    (value.privateKey, value.digest)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signP256Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0, digest: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<signP256Return> for UnderlyingRustTuple<'_> {
                fn from(value: signP256Return) -> Self {
                    (value.r, value.s)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for signP256Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { r: tuple.0, s: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for signP256Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = signP256Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "signP256(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [131u8, 33u8, 27u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.privateKey),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `sleep(uint256)` and selector `0xfa9d8713`.
    ```solidity
    function sleep(uint256 duration) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sleepCall {
        pub duration: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`sleep(uint256)`](sleepCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct sleepReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sleepCall> for UnderlyingRustTuple<'_> {
                fn from(value: sleepCall) -> Self {
                    (value.duration,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sleepCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { duration: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<sleepReturn> for UnderlyingRustTuple<'_> {
                fn from(value: sleepReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for sleepReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for sleepCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = sleepReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "sleep(uint256)";
            const SELECTOR: [u8; 4] = [250u8, 157u8, 135u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.duration,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `split(string,string)` and selector `0x8bb75533`.
    ```solidity
    function split(string memory input, string memory delimiter) external pure returns (string[] memory outputs);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitCall {
        pub input: alloy::sol_types::private::String,
        pub delimiter: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`split(string,string)`](splitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitReturn {
        pub outputs: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitCall> for UnderlyingRustTuple<'_> {
                fn from(value: splitCall) -> Self {
                    (value.input, value.delimiter)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0, delimiter: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: splitReturn) -> Self {
                    (value.outputs,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { outputs: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for splitCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = splitReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "split(string,string)";
            const SELECTOR: [u8; 4] = [139u8, 183u8, 85u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.input,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.delimiter,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startBroadcast()` and selector `0x7fb5297f`.
    ```solidity
    function startBroadcast() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_0Call {}
    ///Container type for the return parameters of the [`startBroadcast()`](startBroadcast_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startBroadcast_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startBroadcast_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startBroadcast()";
            const SELECTOR: [u8; 4] = [127u8, 181u8, 41u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startBroadcast(address)` and selector `0x7fec2a8d`.
    ```solidity
    function startBroadcast(address signer) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_1Call {
        pub signer: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`startBroadcast(address)`](startBroadcast_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_1Call) -> Self {
                    (value.signer,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { signer: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startBroadcast_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startBroadcast_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startBroadcast(address)";
            const SELECTOR: [u8; 4] = [127u8, 236u8, 42u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.signer,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startBroadcast(uint256)` and selector `0xce817d47`.
    ```solidity
    function startBroadcast(uint256 privateKey) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_2Call {
        pub privateKey: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`startBroadcast(uint256)`](startBroadcast_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startBroadcast_2Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_2Call) -> Self {
                    (value.privateKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { privateKey: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startBroadcast_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: startBroadcast_2Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startBroadcast_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startBroadcast_2Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startBroadcast_2Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startBroadcast(uint256)";
            const SELECTOR: [u8; 4] = [206u8, 129u8, 125u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.privateKey,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startDebugTraceRecording()` and selector `0x419c8832`.
    ```solidity
    function startDebugTraceRecording() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startDebugTraceRecordingCall {}
    ///Container type for the return parameters of the [`startDebugTraceRecording()`](startDebugTraceRecordingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startDebugTraceRecordingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startDebugTraceRecordingCall> for UnderlyingRustTuple<'_> {
                fn from(value: startDebugTraceRecordingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startDebugTraceRecordingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startDebugTraceRecordingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: startDebugTraceRecordingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startDebugTraceRecordingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startDebugTraceRecordingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startDebugTraceRecordingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startDebugTraceRecording()";
            const SELECTOR: [u8; 4] = [65u8, 156u8, 136u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startMappingRecording()` and selector `0x3e9705c0`.
    ```solidity
    function startMappingRecording() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMappingRecordingCall {}
    ///Container type for the return parameters of the [`startMappingRecording()`](startMappingRecordingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startMappingRecordingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMappingRecordingCall> for UnderlyingRustTuple<'_> {
                fn from(value: startMappingRecordingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startMappingRecordingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startMappingRecordingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: startMappingRecordingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startMappingRecordingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startMappingRecordingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startMappingRecordingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startMappingRecording()";
            const SELECTOR: [u8; 4] = [62u8, 151u8, 5u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `startStateDiffRecording()` and selector `0xcf22e3c9`.
    ```solidity
    function startStateDiffRecording() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startStateDiffRecordingCall {}
    ///Container type for the return parameters of the [`startStateDiffRecording()`](startStateDiffRecordingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startStateDiffRecordingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startStateDiffRecordingCall> for UnderlyingRustTuple<'_> {
                fn from(value: startStateDiffRecordingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startStateDiffRecordingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startStateDiffRecordingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: startStateDiffRecordingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startStateDiffRecordingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startStateDiffRecordingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = startStateDiffRecordingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startStateDiffRecording()";
            const SELECTOR: [u8; 4] = [207u8, 34u8, 227u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `stopAndReturnDebugTraceRecording()` and selector `0xced398a2`.
    ```solidity
    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopAndReturnDebugTraceRecordingCall {}
    ///Container type for the return parameters of the [`stopAndReturnDebugTraceRecording()`](stopAndReturnDebugTraceRecordingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopAndReturnDebugTraceRecordingReturn {
        pub step:
            alloy::sol_types::private::Vec<<DebugStep as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopAndReturnDebugTraceRecordingCall> for UnderlyingRustTuple<'_> {
                fn from(value: stopAndReturnDebugTraceRecordingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopAndReturnDebugTraceRecordingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<DebugStep>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<<DebugStep as alloy::sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopAndReturnDebugTraceRecordingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stopAndReturnDebugTraceRecordingReturn) -> Self {
                    (value.step,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopAndReturnDebugTraceRecordingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { step: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stopAndReturnDebugTraceRecordingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stopAndReturnDebugTraceRecordingReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<DebugStep>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stopAndReturnDebugTraceRecording()";
            const SELECTOR: [u8; 4] = [206u8, 211u8, 152u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `stopAndReturnStateDiff()` and selector `0xaa5cf90e`.
    ```solidity
    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopAndReturnStateDiffCall {}
    ///Container type for the return parameters of the [`stopAndReturnStateDiff()`](stopAndReturnStateDiffCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopAndReturnStateDiffReturn {
        pub accountAccesses:
            alloy::sol_types::private::Vec<<AccountAccess as alloy::sol_types::SolType>::RustType>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopAndReturnStateDiffCall> for UnderlyingRustTuple<'_> {
                fn from(value: stopAndReturnStateDiffCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopAndReturnStateDiffCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Array<AccountAccess>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <AccountAccess as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopAndReturnStateDiffReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stopAndReturnStateDiffReturn) -> Self {
                    (value.accountAccesses,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopAndReturnStateDiffReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { accountAccesses: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stopAndReturnStateDiffCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stopAndReturnStateDiffReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<AccountAccess>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stopAndReturnStateDiff()";
            const SELECTOR: [u8; 4] = [170u8, 92u8, 249u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `stopBroadcast()` and selector `0x76eadd36`.
    ```solidity
    function stopBroadcast() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopBroadcastCall {}
    ///Container type for the return parameters of the [`stopBroadcast()`](stopBroadcastCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopBroadcastReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopBroadcastCall> for UnderlyingRustTuple<'_> {
                fn from(value: stopBroadcastCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopBroadcastCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopBroadcastReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stopBroadcastReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopBroadcastReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stopBroadcastCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stopBroadcastReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stopBroadcast()";
            const SELECTOR: [u8; 4] = [118u8, 234u8, 221u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `stopMappingRecording()` and selector `0x0d4aae9b`.
    ```solidity
    function stopMappingRecording() external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopMappingRecordingCall {}
    ///Container type for the return parameters of the [`stopMappingRecording()`](stopMappingRecordingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct stopMappingRecordingReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopMappingRecordingCall> for UnderlyingRustTuple<'_> {
                fn from(value: stopMappingRecordingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopMappingRecordingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stopMappingRecordingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stopMappingRecordingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stopMappingRecordingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stopMappingRecordingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stopMappingRecordingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stopMappingRecording()";
            const SELECTOR: [u8; 4] = [13u8, 74u8, 174u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toBase64(string)` and selector `0x3f8be2c8`.
    ```solidity
    function toBase64(string memory data) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64_0Call {
        pub data: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`toBase64(string)`](toBase64_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64_0Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64_0Call) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toBase64_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toBase64_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toBase64(string)";
            const SELECTOR: [u8; 4] = [63u8, 139u8, 226u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.data,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toBase64(bytes)` and selector `0xa5cbfe65`.
    ```solidity
    function toBase64(bytes memory data) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64_1Call {
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`toBase64(bytes)`](toBase64_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64_1Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64_1Call) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toBase64_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toBase64_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toBase64(bytes)";
            const SELECTOR: [u8; 4] = [165u8, 203u8, 254u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.data,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toBase64URL(string)` and selector `0xae3165b3`.
    ```solidity
    function toBase64URL(string memory data) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64URL_0Call {
        pub data: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`toBase64URL(string)`](toBase64URL_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64URL_0Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64URL_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64URL_0Call) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64URL_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64URL_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64URL_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64URL_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toBase64URL_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toBase64URL_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toBase64URL(string)";
            const SELECTOR: [u8; 4] = [174u8, 49u8, 101u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.data,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toBase64URL(bytes)` and selector `0xc8bd0e4a`.
    ```solidity
    function toBase64URL(bytes memory data) external pure returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64URL_1Call {
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`toBase64URL(bytes)`](toBase64URL_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toBase64URL_1Return {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64URL_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64URL_1Call) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64URL_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toBase64URL_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: toBase64URL_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toBase64URL_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toBase64URL_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toBase64URL_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toBase64URL(bytes)";
            const SELECTOR: [u8; 4] = [200u8, 189u8, 14u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.data,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toLowercase(string)` and selector `0x50bb0884`.
    ```solidity
    function toLowercase(string memory input) external pure returns (string memory output);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toLowercaseCall {
        pub input: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`toLowercase(string)`](toLowercaseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toLowercaseReturn {
        pub output: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toLowercaseCall> for UnderlyingRustTuple<'_> {
                fn from(value: toLowercaseCall) -> Self {
                    (value.input,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toLowercaseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toLowercaseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: toLowercaseReturn) -> Self {
                    (value.output,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toLowercaseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { output: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toLowercaseCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toLowercaseReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toLowercase(string)";
            const SELECTOR: [u8; 4] = [80u8, 187u8, 8u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.input,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(address)` and selector `0x56ca623e`.
    ```solidity
    function toString(address value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_0Call {
        pub value: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`toString(address)`](toString_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_0Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_0Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_0Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(address)";
            const SELECTOR: [u8; 4] = [86u8, 202u8, 98u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(uint256)` and selector `0x6900a3ae`.
    ```solidity
    function toString(uint256 value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_1Call {
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`toString(uint256)`](toString_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_1Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_1Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_1Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(uint256)";
            const SELECTOR: [u8; 4] = [105u8, 0u8, 163u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(bytes)` and selector `0x71aad10d`.
    ```solidity
    function toString(bytes memory value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_2Call {
        pub value: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`toString(bytes)`](toString_2Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_2Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_2Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_2Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_2Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_2Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_2Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_2Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_2Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_2Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(bytes)";
            const SELECTOR: [u8; 4] = [113u8, 170u8, 209u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(bool)` and selector `0x71dce7da`.
    ```solidity
    function toString(bool value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_3Call {
        pub value: bool,
    }
    ///Container type for the return parameters of the [`toString(bool)`](toString_3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_3Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_3Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_3Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_3Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_3Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_3Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_3Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(bool)";
            const SELECTOR: [u8; 4] = [113u8, 220u8, 231u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(int256)` and selector `0xa322c40e`.
    ```solidity
    function toString(int256 value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_4Call {
        pub value: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`toString(int256)`](toString_4Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_4Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::I256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_4Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_4Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_4Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_4Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_4Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_4Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_4Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_4Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(int256)";
            const SELECTOR: [u8; 4] = [163u8, 34u8, 196u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Int<256> as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toString(bytes32)` and selector `0xb11a19e8`.
    ```solidity
    function toString(bytes32 value) external pure returns (string memory stringifiedValue);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_5Call {
        pub value: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`toString(bytes32)`](toString_5Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toString_5Return {
        pub stringifiedValue: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_5Call> for UnderlyingRustTuple<'_> {
                fn from(value: toString_5Call) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_5Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toString_5Return> for UnderlyingRustTuple<'_> {
                fn from(value: toString_5Return) -> Self {
                    (value.stringifiedValue,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toString_5Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { stringifiedValue: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toString_5Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toString_5Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toString(bytes32)";
            const SELECTOR: [u8; 4] = [177u8, 26u8, 25u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `toUppercase(string)` and selector `0x074ae3d7`.
    ```solidity
    function toUppercase(string memory input) external pure returns (string memory output);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toUppercaseCall {
        pub input: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`toUppercase(string)`](toUppercaseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct toUppercaseReturn {
        pub output: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toUppercaseCall> for UnderlyingRustTuple<'_> {
                fn from(value: toUppercaseCall) -> Self {
                    (value.input,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toUppercaseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<toUppercaseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: toUppercaseReturn) -> Self {
                    (value.output,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for toUppercaseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { output: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for toUppercaseCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = toUppercaseReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "toUppercase(string)";
            const SELECTOR: [u8; 4] = [7u8, 74u8, 227u8, 215u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.input,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `trim(string)` and selector `0xb2dad155`.
    ```solidity
    function trim(string memory input) external pure returns (string memory output);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trimCall {
        pub input: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`trim(string)`](trimCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct trimReturn {
        pub output: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trimCall> for UnderlyingRustTuple<'_> {
                fn from(value: trimCall) -> Self {
                    (value.input,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trimCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { input: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trimReturn> for UnderlyingRustTuple<'_> {
                fn from(value: trimReturn) -> Self {
                    (value.output,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trimReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { output: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for trimCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = trimReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "trim(string)";
            const SELECTOR: [u8; 4] = [178u8, 218u8, 209u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.input,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `tryFfi(string[])` and selector `0xf45c1ce7`.
    ```solidity
    function tryFfi(string[] memory commandInput) external returns (FfiResult memory result);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tryFfiCall {
        pub commandInput: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
    }
    ///Container type for the return parameters of the [`tryFfi(string[])`](tryFfiCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tryFfiReturn {
        pub result: <FfiResult as alloy::sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Vec<alloy::sol_types::private::String>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tryFfiCall> for UnderlyingRustTuple<'_> {
                fn from(value: tryFfiCall) -> Self {
                    (value.commandInput,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tryFfiCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { commandInput: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (FfiResult,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<FfiResult as alloy::sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tryFfiReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tryFfiReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tryFfiReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tryFfiCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::String>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = tryFfiReturn;
            type ReturnTuple<'a> = (FfiResult,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tryFfi(string[])";
            const SELECTOR: [u8; 4] = [244u8, 92u8, 28u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::String,
                    > as alloy_sol_types::SolType>::tokenize(&self.commandInput),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `unixTime()` and selector `0x625387dc`.
    ```solidity
    function unixTime() external view returns (uint256 milliseconds);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unixTimeCall {}
    ///Container type for the return parameters of the [`unixTime()`](unixTimeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unixTimeReturn {
        pub milliseconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unixTimeCall> for UnderlyingRustTuple<'_> {
                fn from(value: unixTimeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unixTimeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unixTimeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unixTimeReturn) -> Self {
                    (value.milliseconds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unixTimeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { milliseconds: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unixTimeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = unixTimeReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unixTime()";
            const SELECTOR: [u8; 4] = [98u8, 83u8, 135u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeFile(string,string)` and selector `0x897e0a97`.
    ```solidity
    function writeFile(string memory path, string memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeFileCall {
        pub path: alloy::sol_types::private::String,
        pub data: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeFile(string,string)`](writeFileCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeFileReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeFileCall> for UnderlyingRustTuple<'_> {
                fn from(value: writeFileCall) -> Self {
                    (value.path, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeFileCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, data: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeFileReturn> for UnderlyingRustTuple<'_> {
                fn from(value: writeFileReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeFileReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeFileCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeFileReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeFile(string,string)";
            const SELECTOR: [u8; 4] = [137u8, 126u8, 10u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeFileBinary(string,bytes)` and selector `0x1f21fc80`.
    ```solidity
    function writeFileBinary(string memory path, bytes memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeFileBinaryCall {
        pub path: alloy::sol_types::private::String,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`writeFileBinary(string,bytes)`](writeFileBinaryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeFileBinaryReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeFileBinaryCall> for UnderlyingRustTuple<'_> {
                fn from(value: writeFileBinaryCall) -> Self {
                    (value.path, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeFileBinaryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, data: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeFileBinaryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: writeFileBinaryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeFileBinaryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeFileBinaryCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::Bytes);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeFileBinaryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeFileBinary(string,bytes)";
            const SELECTOR: [u8; 4] = [31u8, 33u8, 252u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeJson(string,string,string)` and selector `0x35d6ad46`.
    ```solidity
    function writeJson(string memory json, string memory path, string memory valueKey) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeJson_0Call {
        pub json: alloy::sol_types::private::String,
        pub path: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeJson(string,string,string)`](writeJson_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeJson_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeJson_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: writeJson_0Call) -> Self {
                    (value.json, value.path, value.valueKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeJson_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, path: tuple.1, valueKey: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeJson_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: writeJson_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeJson_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeJson_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeJson_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeJson(string,string,string)";
            const SELECTOR: [u8; 4] = [53u8, 214u8, 173u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeJson(string,string)` and selector `0xe23cd19f`.
    ```solidity
    function writeJson(string memory json, string memory path) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeJson_1Call {
        pub json: alloy::sol_types::private::String,
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeJson(string,string)`](writeJson_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeJson_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeJson_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: writeJson_1Call) -> Self {
                    (value.json, value.path)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeJson_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, path: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeJson_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: writeJson_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeJson_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeJson_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeJson_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeJson(string,string)";
            const SELECTOR: [u8; 4] = [226u8, 60u8, 209u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeLine(string,string)` and selector `0x619d897f`.
    ```solidity
    function writeLine(string memory path, string memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeLineCall {
        pub path: alloy::sol_types::private::String,
        pub data: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeLine(string,string)`](writeLineCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeLineReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeLineCall> for UnderlyingRustTuple<'_> {
                fn from(value: writeLineCall) -> Self {
                    (value.path, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeLineCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { path: tuple.0, data: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeLineReturn> for UnderlyingRustTuple<'_> {
                fn from(value: writeLineReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeLineReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeLineCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeLineReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeLine(string,string)";
            const SELECTOR: [u8; 4] = [97u8, 157u8, 137u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeToml(string,string,string)` and selector `0x51ac6a33`.
    ```solidity
    function writeToml(string memory json, string memory path, string memory valueKey) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeToml_0Call {
        pub json: alloy::sol_types::private::String,
        pub path: alloy::sol_types::private::String,
        pub valueKey: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeToml(string,string,string)`](writeToml_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeToml_0Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeToml_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: writeToml_0Call) -> Self {
                    (value.json, value.path, value.valueKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeToml_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, path: tuple.1, valueKey: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeToml_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: writeToml_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeToml_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeToml_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeToml_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeToml(string,string,string)";
            const SELECTOR: [u8; 4] = [81u8, 172u8, 106u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.valueKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `writeToml(string,string)` and selector `0xc0865ba7`.
    ```solidity
    function writeToml(string memory json, string memory path) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeToml_1Call {
        pub json: alloy::sol_types::private::String,
        pub path: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`writeToml(string,string)`](writeToml_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct writeToml_1Return {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::String, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeToml_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: writeToml_1Call) -> Self {
                    (value.json, value.path)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeToml_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { json: tuple.0, path: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<writeToml_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: writeToml_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for writeToml_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for writeToml_1Call {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::String, alloy::sol_types::sol_data::String);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = writeToml_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "writeToml(string,string)";
            const SELECTOR: [u8; 4] = [192u8, 134u8, 91u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.json,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.path,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`VmSafe`](self) function calls.
    pub enum VmSafeCalls {
        accesses(accessesCall),
        addr(addrCall),
        assertApproxEqAbs_0(assertApproxEqAbs_0Call),
        assertApproxEqAbs_1(assertApproxEqAbs_1Call),
        assertApproxEqAbs_2(assertApproxEqAbs_2Call),
        assertApproxEqAbs_3(assertApproxEqAbs_3Call),
        assertApproxEqAbsDecimal_0(assertApproxEqAbsDecimal_0Call),
        assertApproxEqAbsDecimal_1(assertApproxEqAbsDecimal_1Call),
        assertApproxEqAbsDecimal_2(assertApproxEqAbsDecimal_2Call),
        assertApproxEqAbsDecimal_3(assertApproxEqAbsDecimal_3Call),
        assertApproxEqRel_0(assertApproxEqRel_0Call),
        assertApproxEqRel_1(assertApproxEqRel_1Call),
        assertApproxEqRel_2(assertApproxEqRel_2Call),
        assertApproxEqRel_3(assertApproxEqRel_3Call),
        assertApproxEqRelDecimal_0(assertApproxEqRelDecimal_0Call),
        assertApproxEqRelDecimal_1(assertApproxEqRelDecimal_1Call),
        assertApproxEqRelDecimal_2(assertApproxEqRelDecimal_2Call),
        assertApproxEqRelDecimal_3(assertApproxEqRelDecimal_3Call),
        assertEq_0(assertEq_0Call),
        assertEq_1(assertEq_1Call),
        assertEq_2(assertEq_2Call),
        assertEq_3(assertEq_3Call),
        assertEq_4(assertEq_4Call),
        assertEq_5(assertEq_5Call),
        assertEq_6(assertEq_6Call),
        assertEq_7(assertEq_7Call),
        assertEq_8(assertEq_8Call),
        assertEq_9(assertEq_9Call),
        assertEq_10(assertEq_10Call),
        assertEq_11(assertEq_11Call),
        assertEq_12(assertEq_12Call),
        assertEq_13(assertEq_13Call),
        assertEq_14(assertEq_14Call),
        assertEq_15(assertEq_15Call),
        assertEq_16(assertEq_16Call),
        assertEq_17(assertEq_17Call),
        assertEq_18(assertEq_18Call),
        assertEq_19(assertEq_19Call),
        assertEq_20(assertEq_20Call),
        assertEq_21(assertEq_21Call),
        assertEq_22(assertEq_22Call),
        assertEq_23(assertEq_23Call),
        assertEq_24(assertEq_24Call),
        assertEq_25(assertEq_25Call),
        assertEq_26(assertEq_26Call),
        assertEq_27(assertEq_27Call),
        assertEqDecimal_0(assertEqDecimal_0Call),
        assertEqDecimal_1(assertEqDecimal_1Call),
        assertEqDecimal_2(assertEqDecimal_2Call),
        assertEqDecimal_3(assertEqDecimal_3Call),
        assertFalse_0(assertFalse_0Call),
        assertFalse_1(assertFalse_1Call),
        assertGe_0(assertGe_0Call),
        assertGe_1(assertGe_1Call),
        assertGe_2(assertGe_2Call),
        assertGe_3(assertGe_3Call),
        assertGeDecimal_0(assertGeDecimal_0Call),
        assertGeDecimal_1(assertGeDecimal_1Call),
        assertGeDecimal_2(assertGeDecimal_2Call),
        assertGeDecimal_3(assertGeDecimal_3Call),
        assertGt_0(assertGt_0Call),
        assertGt_1(assertGt_1Call),
        assertGt_2(assertGt_2Call),
        assertGt_3(assertGt_3Call),
        assertGtDecimal_0(assertGtDecimal_0Call),
        assertGtDecimal_1(assertGtDecimal_1Call),
        assertGtDecimal_2(assertGtDecimal_2Call),
        assertGtDecimal_3(assertGtDecimal_3Call),
        assertLe_0(assertLe_0Call),
        assertLe_1(assertLe_1Call),
        assertLe_2(assertLe_2Call),
        assertLe_3(assertLe_3Call),
        assertLeDecimal_0(assertLeDecimal_0Call),
        assertLeDecimal_1(assertLeDecimal_1Call),
        assertLeDecimal_2(assertLeDecimal_2Call),
        assertLeDecimal_3(assertLeDecimal_3Call),
        assertLt_0(assertLt_0Call),
        assertLt_1(assertLt_1Call),
        assertLt_2(assertLt_2Call),
        assertLt_3(assertLt_3Call),
        assertLtDecimal_0(assertLtDecimal_0Call),
        assertLtDecimal_1(assertLtDecimal_1Call),
        assertLtDecimal_2(assertLtDecimal_2Call),
        assertLtDecimal_3(assertLtDecimal_3Call),
        assertNotEq_0(assertNotEq_0Call),
        assertNotEq_1(assertNotEq_1Call),
        assertNotEq_2(assertNotEq_2Call),
        assertNotEq_3(assertNotEq_3Call),
        assertNotEq_4(assertNotEq_4Call),
        assertNotEq_5(assertNotEq_5Call),
        assertNotEq_6(assertNotEq_6Call),
        assertNotEq_7(assertNotEq_7Call),
        assertNotEq_8(assertNotEq_8Call),
        assertNotEq_9(assertNotEq_9Call),
        assertNotEq_10(assertNotEq_10Call),
        assertNotEq_11(assertNotEq_11Call),
        assertNotEq_12(assertNotEq_12Call),
        assertNotEq_13(assertNotEq_13Call),
        assertNotEq_14(assertNotEq_14Call),
        assertNotEq_15(assertNotEq_15Call),
        assertNotEq_16(assertNotEq_16Call),
        assertNotEq_17(assertNotEq_17Call),
        assertNotEq_18(assertNotEq_18Call),
        assertNotEq_19(assertNotEq_19Call),
        assertNotEq_20(assertNotEq_20Call),
        assertNotEq_21(assertNotEq_21Call),
        assertNotEq_22(assertNotEq_22Call),
        assertNotEq_23(assertNotEq_23Call),
        assertNotEq_24(assertNotEq_24Call),
        assertNotEq_25(assertNotEq_25Call),
        assertNotEq_26(assertNotEq_26Call),
        assertNotEq_27(assertNotEq_27Call),
        assertNotEqDecimal_0(assertNotEqDecimal_0Call),
        assertNotEqDecimal_1(assertNotEqDecimal_1Call),
        assertNotEqDecimal_2(assertNotEqDecimal_2Call),
        assertNotEqDecimal_3(assertNotEqDecimal_3Call),
        assertTrue_0(assertTrue_0Call),
        assertTrue_1(assertTrue_1Call),
        assume(assumeCall),
        assumeNoRevert(assumeNoRevertCall),
        attachDelegation(attachDelegationCall),
        breakpoint_0(breakpoint_0Call),
        breakpoint_1(breakpoint_1Call),
        broadcast_0(broadcast_0Call),
        broadcast_1(broadcast_1Call),
        broadcast_2(broadcast_2Call),
        broadcastRawTransaction(broadcastRawTransactionCall),
        closeFile(closeFileCall),
        computeCreate2Address_0(computeCreate2Address_0Call),
        computeCreate2Address_1(computeCreate2Address_1Call),
        computeCreateAddress(computeCreateAddressCall),
        contains(containsCall),
        copyFile(copyFileCall),
        copyStorage(copyStorageCall),
        createDir(createDirCall),
        createWallet_0(createWallet_0Call),
        createWallet_1(createWallet_1Call),
        createWallet_2(createWallet_2Call),
        deployCode_0(deployCode_0Call),
        deployCode_1(deployCode_1Call),
        deriveKey_0(deriveKey_0Call),
        deriveKey_1(deriveKey_1Call),
        deriveKey_2(deriveKey_2Call),
        deriveKey_3(deriveKey_3Call),
        ensNamehash(ensNamehashCall),
        envAddress_0(envAddress_0Call),
        envAddress_1(envAddress_1Call),
        envBool_0(envBool_0Call),
        envBool_1(envBool_1Call),
        envBytes_0(envBytes_0Call),
        envBytes_1(envBytes_1Call),
        envBytes32_0(envBytes32_0Call),
        envBytes32_1(envBytes32_1Call),
        envExists(envExistsCall),
        envInt_0(envInt_0Call),
        envInt_1(envInt_1Call),
        envOr_0(envOr_0Call),
        envOr_1(envOr_1Call),
        envOr_2(envOr_2Call),
        envOr_3(envOr_3Call),
        envOr_4(envOr_4Call),
        envOr_5(envOr_5Call),
        envOr_6(envOr_6Call),
        envOr_7(envOr_7Call),
        envOr_8(envOr_8Call),
        envOr_9(envOr_9Call),
        envOr_10(envOr_10Call),
        envOr_11(envOr_11Call),
        envOr_12(envOr_12Call),
        envOr_13(envOr_13Call),
        envString_0(envString_0Call),
        envString_1(envString_1Call),
        envUint_0(envUint_0Call),
        envUint_1(envUint_1Call),
        eth_getLogs(eth_getLogsCall),
        exists(existsCall),
        ffi(ffiCall),
        fsMetadata(fsMetadataCall),
        getArtifactPathByCode(getArtifactPathByCodeCall),
        getArtifactPathByDeployedCode(getArtifactPathByDeployedCodeCall),
        getBlobBaseFee(getBlobBaseFeeCall),
        getBlockNumber(getBlockNumberCall),
        getBlockTimestamp(getBlockTimestampCall),
        getBroadcast(getBroadcastCall),
        getBroadcasts_0(getBroadcasts_0Call),
        getBroadcasts_1(getBroadcasts_1Call),
        getCode(getCodeCall),
        getDeployedCode(getDeployedCodeCall),
        getDeployment_0(getDeployment_0Call),
        getDeployment_1(getDeployment_1Call),
        getDeployments(getDeploymentsCall),
        getFoundryVersion(getFoundryVersionCall),
        getLabel(getLabelCall),
        getMappingKeyAndParentOf(getMappingKeyAndParentOfCall),
        getMappingLength(getMappingLengthCall),
        getMappingSlotAt(getMappingSlotAtCall),
        getNonce_0(getNonce_0Call),
        getNonce_1(getNonce_1Call),
        getRecordedLogs(getRecordedLogsCall),
        getStateDiff(getStateDiffCall),
        getStateDiffJson(getStateDiffJsonCall),
        getWallets(getWalletsCall),
        indexOf(indexOfCall),
        isContext(isContextCall),
        isDir(isDirCall),
        isFile(isFileCall),
        keyExists(keyExistsCall),
        keyExistsJson(keyExistsJsonCall),
        keyExistsToml(keyExistsTomlCall),
        label(labelCall),
        lastCallGas(lastCallGasCall),
        load(loadCall),
        parseAddress(parseAddressCall),
        parseBool(parseBoolCall),
        parseBytes(parseBytesCall),
        parseBytes32(parseBytes32Call),
        parseInt(parseIntCall),
        parseJson_0(parseJson_0Call),
        parseJson_1(parseJson_1Call),
        parseJsonAddress(parseJsonAddressCall),
        parseJsonAddressArray(parseJsonAddressArrayCall),
        parseJsonBool(parseJsonBoolCall),
        parseJsonBoolArray(parseJsonBoolArrayCall),
        parseJsonBytes(parseJsonBytesCall),
        parseJsonBytes32(parseJsonBytes32Call),
        parseJsonBytes32Array(parseJsonBytes32ArrayCall),
        parseJsonBytesArray(parseJsonBytesArrayCall),
        parseJsonInt(parseJsonIntCall),
        parseJsonIntArray(parseJsonIntArrayCall),
        parseJsonKeys(parseJsonKeysCall),
        parseJsonString(parseJsonStringCall),
        parseJsonStringArray(parseJsonStringArrayCall),
        parseJsonType_0(parseJsonType_0Call),
        parseJsonType_1(parseJsonType_1Call),
        parseJsonTypeArray(parseJsonTypeArrayCall),
        parseJsonUint(parseJsonUintCall),
        parseJsonUintArray(parseJsonUintArrayCall),
        parseToml_0(parseToml_0Call),
        parseToml_1(parseToml_1Call),
        parseTomlAddress(parseTomlAddressCall),
        parseTomlAddressArray(parseTomlAddressArrayCall),
        parseTomlBool(parseTomlBoolCall),
        parseTomlBoolArray(parseTomlBoolArrayCall),
        parseTomlBytes(parseTomlBytesCall),
        parseTomlBytes32(parseTomlBytes32Call),
        parseTomlBytes32Array(parseTomlBytes32ArrayCall),
        parseTomlBytesArray(parseTomlBytesArrayCall),
        parseTomlInt(parseTomlIntCall),
        parseTomlIntArray(parseTomlIntArrayCall),
        parseTomlKeys(parseTomlKeysCall),
        parseTomlString(parseTomlStringCall),
        parseTomlStringArray(parseTomlStringArrayCall),
        parseTomlType_0(parseTomlType_0Call),
        parseTomlType_1(parseTomlType_1Call),
        parseTomlTypeArray(parseTomlTypeArrayCall),
        parseTomlUint(parseTomlUintCall),
        parseTomlUintArray(parseTomlUintArrayCall),
        parseUint(parseUintCall),
        pauseGasMetering(pauseGasMeteringCall),
        pauseTracing(pauseTracingCall),
        projectRoot(projectRootCall),
        prompt(promptCall),
        promptAddress(promptAddressCall),
        promptSecret(promptSecretCall),
        promptSecretUint(promptSecretUintCall),
        promptUint(promptUintCall),
        publicKeyP256(publicKeyP256Call),
        randomAddress(randomAddressCall),
        randomBool(randomBoolCall),
        randomBytes(randomBytesCall),
        randomBytes4(randomBytes4Call),
        randomBytes8(randomBytes8Call),
        randomInt_0(randomInt_0Call),
        randomInt_1(randomInt_1Call),
        randomUint_0(randomUint_0Call),
        randomUint_1(randomUint_1Call),
        randomUint_2(randomUint_2Call),
        readDir_0(readDir_0Call),
        readDir_1(readDir_1Call),
        readDir_2(readDir_2Call),
        readFile(readFileCall),
        readFileBinary(readFileBinaryCall),
        readLine(readLineCall),
        readLink(readLinkCall),
        record(recordCall),
        recordLogs(recordLogsCall),
        rememberKey(rememberKeyCall),
        rememberKeys_0(rememberKeys_0Call),
        rememberKeys_1(rememberKeys_1Call),
        removeDir(removeDirCall),
        removeFile(removeFileCall),
        replace(replaceCall),
        resetGasMetering(resetGasMeteringCall),
        resumeGasMetering(resumeGasMeteringCall),
        resumeTracing(resumeTracingCall),
        rpc_0(rpc_0Call),
        rpc_1(rpc_1Call),
        rpcUrl(rpcUrlCall),
        rpcUrlStructs(rpcUrlStructsCall),
        rpcUrls(rpcUrlsCall),
        serializeAddress_0(serializeAddress_0Call),
        serializeAddress_1(serializeAddress_1Call),
        serializeBool_0(serializeBool_0Call),
        serializeBool_1(serializeBool_1Call),
        serializeBytes_0(serializeBytes_0Call),
        serializeBytes_1(serializeBytes_1Call),
        serializeBytes32_0(serializeBytes32_0Call),
        serializeBytes32_1(serializeBytes32_1Call),
        serializeInt_0(serializeInt_0Call),
        serializeInt_1(serializeInt_1Call),
        serializeJson(serializeJsonCall),
        serializeJsonType_0(serializeJsonType_0Call),
        serializeJsonType_1(serializeJsonType_1Call),
        serializeString_0(serializeString_0Call),
        serializeString_1(serializeString_1Call),
        serializeUint_0(serializeUint_0Call),
        serializeUint_1(serializeUint_1Call),
        serializeUintToHex(serializeUintToHexCall),
        setArbitraryStorage(setArbitraryStorageCall),
        setEnv(setEnvCall),
        sign_0(sign_0Call),
        sign_1(sign_1Call),
        sign_2(sign_2Call),
        sign_3(sign_3Call),
        signAndAttachDelegation(signAndAttachDelegationCall),
        signCompact_0(signCompact_0Call),
        signCompact_1(signCompact_1Call),
        signCompact_2(signCompact_2Call),
        signCompact_3(signCompact_3Call),
        signDelegation(signDelegationCall),
        signP256(signP256Call),
        sleep(sleepCall),
        split(splitCall),
        startBroadcast_0(startBroadcast_0Call),
        startBroadcast_1(startBroadcast_1Call),
        startBroadcast_2(startBroadcast_2Call),
        startDebugTraceRecording(startDebugTraceRecordingCall),
        startMappingRecording(startMappingRecordingCall),
        startStateDiffRecording(startStateDiffRecordingCall),
        stopAndReturnDebugTraceRecording(stopAndReturnDebugTraceRecordingCall),
        stopAndReturnStateDiff(stopAndReturnStateDiffCall),
        stopBroadcast(stopBroadcastCall),
        stopMappingRecording(stopMappingRecordingCall),
        toBase64_0(toBase64_0Call),
        toBase64_1(toBase64_1Call),
        toBase64URL_0(toBase64URL_0Call),
        toBase64URL_1(toBase64URL_1Call),
        toLowercase(toLowercaseCall),
        toString_0(toString_0Call),
        toString_1(toString_1Call),
        toString_2(toString_2Call),
        toString_3(toString_3Call),
        toString_4(toString_4Call),
        toString_5(toString_5Call),
        toUppercase(toUppercaseCall),
        trim(trimCall),
        tryFfi(tryFfiCall),
        unixTime(unixTimeCall),
        writeFile(writeFileCall),
        writeFileBinary(writeFileBinaryCall),
        writeJson_0(writeJson_0Call),
        writeJson_1(writeJson_1Call),
        writeLine(writeLineCall),
        writeToml_0(writeToml_0Call),
        writeToml_1(writeToml_1Call),
    }
    #[automatically_derived]
    impl VmSafeCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 117u8, 213u8, 53u8],
            [1u8, 153u8, 162u8, 32u8],
            [4u8, 92u8, 85u8, 206u8],
            [4u8, 151u8, 176u8, 165u8],
            [4u8, 165u8, 199u8, 171u8],
            [6u8, 3u8, 234u8, 104u8],
            [7u8, 74u8, 227u8, 215u8],
            [8u8, 126u8, 110u8, 129u8],
            [10u8, 48u8, 183u8, 113u8],
            [11u8, 114u8, 244u8, 239u8],
            [12u8, 159u8, 213u8, 129u8],
            [12u8, 201u8, 238u8, 132u8],
            [13u8, 74u8, 174u8, 155u8],
            [13u8, 235u8, 213u8, 214u8],
            [16u8, 145u8, 162u8, 97u8],
            [17u8, 31u8, 18u8, 2u8],
            [17u8, 209u8, 54u8, 74u8],
            [18u8, 6u8, 200u8, 168u8],
            [18u8, 124u8, 254u8, 154u8],
            [18u8, 132u8, 89u8, 102u8],
            [18u8, 158u8, 144u8, 2u8],
            [20u8, 151u8, 135u8, 108u8],
            [20u8, 174u8, 53u8, 25u8],
            [20u8, 176u8, 43u8, 201u8],
            [20u8, 231u8, 86u8, 128u8],
            [22u8, 139u8, 100u8, 211u8],
            [22u8, 210u8, 7u8, 198u8],
            [22u8, 237u8, 123u8, 196u8],
            [23u8, 119u8, 229u8, 157u8],
            [25u8, 21u8, 83u8, 164u8],
            [25u8, 31u8, 27u8, 48u8],
            [29u8, 205u8, 31u8, 104u8],
            [30u8, 25u8, 230u8, 87u8],
            [30u8, 39u8, 157u8, 65u8],
            [30u8, 53u8, 110u8, 26u8],
            [30u8, 203u8, 125u8, 51u8],
            [31u8, 33u8, 252u8, 128u8],
            [31u8, 109u8, 110u8, 247u8],
            [32u8, 30u8, 67u8, 226u8],
            [32u8, 61u8, 172u8, 13u8],
            [32u8, 119u8, 51u8, 126u8],
            [33u8, 62u8, 65u8, 152u8],
            [33u8, 237u8, 41u8, 119u8],
            [34u8, 16u8, 0u8, 100u8],
            [34u8, 129u8, 243u8, 103u8],
            [35u8, 110u8, 77u8, 102u8],
            [36u8, 15u8, 131u8, 157u8],
            [37u8, 18u8, 71u8, 48u8],
            [38u8, 26u8, 50u8, 62u8],
            [38u8, 108u8, 241u8, 9u8],
            [39u8, 175u8, 125u8, 156u8],
            [40u8, 91u8, 54u8, 106u8],
            [40u8, 111u8, 175u8, 234u8],
            [40u8, 162u8, 73u8, 176u8],
            [41u8, 35u8, 59u8, 31u8],
            [41u8, 206u8, 157u8, 222u8],
            [43u8, 88u8, 155u8, 40u8],
            [43u8, 205u8, 80u8, 224u8],
            [45u8, 3u8, 53u8, 171u8],
            [45u8, 129u8, 43u8, 68u8],
            [47u8, 39u8, 105u8, 209u8],
            [47u8, 47u8, 214u8, 63u8],
            [47u8, 206u8, 120u8, 131u8],
            [50u8, 200u8, 23u8, 109u8],
            [51u8, 148u8, 159u8, 11u8],
            [53u8, 13u8, 86u8, 191u8],
            [53u8, 214u8, 173u8, 70u8],
            [53u8, 225u8, 52u8, 155u8],
            [54u8, 246u8, 86u8, 216u8],
            [55u8, 115u8, 110u8, 8u8],
            [56u8, 104u8, 172u8, 52u8],
            [60u8, 247u8, 142u8, 40u8],
            [61u8, 14u8, 41u8, 47u8],
            [61u8, 31u8, 224u8, 138u8],
            [61u8, 89u8, 35u8, 238u8],
            [61u8, 91u8, 200u8, 188u8],
            [61u8, 201u8, 12u8, 179u8],
            [62u8, 113u8, 111u8, 129u8],
            [62u8, 145u8, 64u8, 128u8],
            [62u8, 145u8, 115u8, 197u8],
            [62u8, 151u8, 5u8, 192u8],
            [62u8, 191u8, 115u8, 180u8],
            [63u8, 51u8, 219u8, 96u8],
            [63u8, 139u8, 226u8, 200u8],
            [63u8, 177u8, 138u8, 236u8],
            [64u8, 240u8, 180u8, 224u8],
            [65u8, 156u8, 136u8, 50u8],
            [65u8, 175u8, 47u8, 82u8],
            [66u8, 24u8, 17u8, 80u8],
            [66u8, 52u8, 108u8, 94u8],
            [66u8, 203u8, 177u8, 92u8],
            [69u8, 198u8, 32u8, 17u8],
            [70u8, 208u8, 178u8, 82u8],
            [71u8, 0u8, 215u8, 75u8],
            [71u8, 36u8, 197u8, 185u8],
            [71u8, 119u8, 243u8, 207u8],
            [71u8, 234u8, 244u8, 116u8],
            [71u8, 250u8, 94u8, 17u8],
            [72u8, 1u8, 108u8, 4u8],
            [72u8, 195u8, 36u8, 31u8],
            [73u8, 143u8, 220u8, 244u8],
            [73u8, 190u8, 55u8, 67u8],
            [73u8, 196u8, 250u8, 200u8],
            [76u8, 99u8, 229u8, 98u8],
            [77u8, 123u8, 175u8, 6u8],
            [77u8, 177u8, 158u8, 126u8],
            [77u8, 254u8, 105u8, 44u8],
            [80u8, 187u8, 8u8, 132u8],
            [81u8, 83u8, 97u8, 246u8],
            [81u8, 172u8, 106u8, 51u8],
            [82u8, 32u8, 116u8, 171u8],
            [82u8, 138u8, 104u8, 60u8],
            [86u8, 28u8, 214u8, 243u8],
            [86u8, 31u8, 229u8, 64u8],
            [86u8, 202u8, 98u8, 62u8],
            [86u8, 242u8, 156u8, 186u8],
            [89u8, 33u8, 81u8, 240u8],
            [90u8, 54u8, 45u8, 69u8],
            [90u8, 242u8, 49u8, 193u8],
            [91u8, 89u8, 60u8, 123u8],
            [93u8, 24u8, 199u8, 58u8],
            [93u8, 249u8, 60u8, 155u8],
            [94u8, 151u8, 52u8, 143u8],
            [96u8, 9u8, 3u8, 173u8],
            [96u8, 66u8, 158u8, 178u8],
            [96u8, 249u8, 187u8, 17u8],
            [97u8, 157u8, 137u8, 127u8],
            [98u8, 41u8, 73u8, 139u8],
            [98u8, 83u8, 135u8, 220u8],
            [98u8, 198u8, 249u8, 251u8],
            [98u8, 238u8, 5u8, 244u8],
            [100u8, 148u8, 154u8, 141u8],
            [100u8, 175u8, 37u8, 93u8],
            [100u8, 188u8, 62u8, 100u8],
            [101u8, 47u8, 212u8, 137u8],
            [101u8, 188u8, 148u8, 129u8],
            [101u8, 196u8, 40u8, 231u8],
            [101u8, 213u8, 193u8, 53u8],
            [101u8, 231u8, 200u8, 68u8],
            [102u8, 49u8, 170u8, 153u8],
            [102u8, 127u8, 157u8, 112u8],
            [102u8, 158u8, 252u8, 167u8],
            [105u8, 0u8, 163u8, 174u8],
            [105u8, 202u8, 2u8, 183u8],
            [106u8, 80u8, 102u8, 212u8],
            [106u8, 130u8, 55u8, 179u8],
            [106u8, 130u8, 96u8, 10u8],
            [107u8, 203u8, 44u8, 27u8],
            [108u8, 93u8, 50u8, 169u8],
            [109u8, 79u8, 150u8, 166u8],
            [109u8, 133u8, 59u8, 165u8],
            [111u8, 147u8, 188u8, 203u8],
            [112u8, 125u8, 247u8, 133u8],
            [112u8, 245u8, 87u8, 40u8],
            [113u8, 16u8, 67u8, 172u8],
            [113u8, 74u8, 47u8, 19u8],
            [113u8, 170u8, 209u8, 13u8],
            [113u8, 220u8, 231u8, 218u8],
            [114u8, 160u8, 156u8, 203u8],
            [114u8, 199u8, 224u8, 181u8],
            [116u8, 4u8, 241u8, 210u8],
            [116u8, 49u8, 133u8, 40u8],
            [116u8, 99u8, 122u8, 122u8],
            [116u8, 225u8, 51u8, 221u8],
            [118u8, 118u8, 225u8, 39u8],
            [118u8, 234u8, 221u8, 54u8],
            [120u8, 97u8, 31u8, 14u8],
            [120u8, 189u8, 206u8, 167u8],
            [121u8, 107u8, 137u8, 185u8],
            [121u8, 156u8, 211u8, 51u8],
            [122u8, 103u8, 91u8, 182u8],
            [123u8, 4u8, 140u8, 205u8],
            [123u8, 160u8, 72u8, 9u8],
            [124u8, 132u8, 198u8, 155u8],
            [125u8, 21u8, 208u8, 25u8],
            [126u8, 119u8, 176u8, 197u8],
            [126u8, 209u8, 236u8, 125u8],
            [127u8, 181u8, 41u8, 127u8],
            [127u8, 236u8, 42u8, 141u8],
            [127u8, 239u8, 187u8, 224u8],
            [128u8, 223u8, 1u8, 204u8],
            [129u8, 2u8, 215u8, 13u8],
            [129u8, 42u8, 68u8, 178u8],
            [130u8, 137u8, 230u8, 33u8],
            [130u8, 214u8, 200u8, 253u8],
            [131u8, 33u8, 27u8, 64u8],
            [132u8, 102u8, 244u8, 21u8],
            [133u8, 146u8, 22u8, 188u8],
            [133u8, 148u8, 14u8, 241u8],
            [135u8, 110u8, 36u8, 230u8],
            [135u8, 117u8, 165u8, 145u8],
            [136u8, 180u8, 76u8, 133u8],
            [136u8, 218u8, 109u8, 53u8],
            [137u8, 12u8, 40u8, 59u8],
            [137u8, 22u8, 4u8, 103u8],
            [137u8, 42u8, 12u8, 97u8],
            [137u8, 126u8, 10u8, 151u8],
            [137u8, 142u8, 131u8, 252u8],
            [138u8, 8u8, 7u8, 183u8],
            [139u8, 183u8, 85u8, 51u8],
            [139u8, 184u8, 221u8, 67u8],
            [139u8, 255u8, 145u8, 51u8],
            [140u8, 12u8, 114u8, 224u8],
            [140u8, 26u8, 162u8, 5u8],
            [140u8, 55u8, 76u8, 101u8],
            [140u8, 242u8, 94u8, 244u8],
            [141u8, 28u8, 201u8, 37u8],
            [142u8, 33u8, 72u8, 16u8],
            [142u8, 47u8, 151u8, 191u8],
            [143u8, 93u8, 35u8, 45u8],
            [145u8, 199u8, 91u8, 195u8],
            [145u8, 243u8, 185u8, 79u8],
            [146u8, 146u8, 90u8, 161u8],
            [149u8, 7u8, 84u8, 14u8],
            [149u8, 253u8, 21u8, 78u8],
            [151u8, 44u8, 96u8, 98u8],
            [151u8, 78u8, 249u8, 36u8],
            [151u8, 90u8, 108u8, 233u8],
            [151u8, 93u8, 90u8, 18u8],
            [151u8, 98u8, 70u8, 49u8],
            [151u8, 148u8, 144u8, 66u8],
            [151u8, 203u8, 145u8, 137u8],
            [152u8, 41u8, 108u8, 84u8],
            [152u8, 132u8, 178u8, 50u8],
            [152u8, 249u8, 189u8, 189u8],
            [153u8, 131u8, 194u8, 138u8],
            [154u8, 127u8, 189u8, 143u8],
            [154u8, 131u8, 37u8, 160u8],
            [155u8, 51u8, 88u8, 176u8],
            [155u8, 124u8, 213u8, 121u8],
            [157u8, 42u8, 215u8, 42u8],
            [159u8, 86u8, 132u8, 162u8],
            [159u8, 98u8, 146u8, 129u8],
            [159u8, 134u8, 220u8, 145u8],
            [159u8, 245u8, 49u8, 227u8],
            [162u8, 130u8, 220u8, 75u8],
            [163u8, 34u8, 196u8, 14u8],
            [163u8, 78u8, 220u8, 3u8],
            [165u8, 74u8, 135u8, 216u8],
            [165u8, 116u8, 138u8, 173u8],
            [165u8, 152u8, 40u8, 133u8],
            [165u8, 203u8, 254u8, 101u8],
            [168u8, 9u8, 29u8, 151u8],
            [168u8, 67u8, 40u8, 221u8],
            [168u8, 90u8, 132u8, 24u8],
            [168u8, 212u8, 209u8, 217u8],
            [169u8, 114u8, 208u8, 55u8],
            [169u8, 218u8, 49u8, 59u8],
            [170u8, 92u8, 247u8, 136u8],
            [170u8, 92u8, 249u8, 14u8],
            [170u8, 173u8, 222u8, 175u8],
            [171u8, 191u8, 33u8, 204u8],
            [172u8, 34u8, 233u8, 113u8],
            [173u8, 49u8, 185u8, 250u8],
            [173u8, 221u8, 226u8, 182u8],
            [174u8, 49u8, 101u8, 179u8],
            [174u8, 90u8, 42u8, 232u8],
            [175u8, 54u8, 138u8, 8u8],
            [175u8, 201u8, 128u8, 64u8],
            [177u8, 26u8, 25u8, 232u8],
            [177u8, 46u8, 22u8, 148u8],
            [177u8, 47u8, 192u8, 5u8],
            [177u8, 151u8, 194u8, 71u8],
            [178u8, 51u8, 47u8, 81u8],
            [178u8, 92u8, 90u8, 37u8],
            [178u8, 218u8, 209u8, 85u8],
            [179u8, 228u8, 119u8, 5u8],
            [180u8, 168u8, 88u8, 146u8],
            [181u8, 223u8, 39u8, 200u8],
            [182u8, 113u8, 135u8, 243u8],
            [183u8, 144u8, 147u8, 32u8],
            [184u8, 115u8, 99u8, 76u8],
            [187u8, 203u8, 113u8, 62u8],
            [189u8, 250u8, 203u8, 232u8],
            [190u8, 54u8, 125u8, 211u8],
            [192u8, 134u8, 91u8, 167u8],
            [193u8, 53u8, 7u8, 57u8],
            [193u8, 151u8, 141u8, 31u8],
            [193u8, 250u8, 30u8, 208u8],
            [195u8, 4u8, 170u8, 183u8],
            [196u8, 83u8, 148u8, 158u8],
            [196u8, 188u8, 89u8, 224u8],
            [198u8, 87u8, 199u8, 24u8],
            [198u8, 206u8, 5u8, 157u8],
            [199u8, 78u8, 157u8, 235u8],
            [199u8, 250u8, 114u8, 136u8],
            [200u8, 189u8, 14u8, 74u8],
            [201u8, 77u8, 31u8, 144u8],
            [204u8, 42u8, 120u8, 31u8],
            [204u8, 123u8, 4u8, 135u8],
            [205u8, 193u8, 38u8, 189u8],
            [206u8, 129u8, 125u8, 71u8],
            [206u8, 131u8, 101u8, 249u8],
            [206u8, 211u8, 152u8, 162u8],
            [207u8, 28u8, 4u8, 156u8],
            [207u8, 34u8, 227u8, 201u8],
            [207u8, 129u8, 230u8, 156u8],
            [208u8, 203u8, 189u8, 239u8],
            [209u8, 69u8, 115u8, 108u8],
            [209u8, 125u8, 75u8, 13u8],
            [209u8, 165u8, 179u8, 111u8],
            [211u8, 13u8, 206u8, 214u8],
            [211u8, 35u8, 130u8, 106u8],
            [211u8, 82u8, 42u8, 230u8],
            [211u8, 151u8, 115u8, 34u8],
            [213u8, 190u8, 233u8, 245u8],
            [214u8, 27u8, 5u8, 27u8],
            [215u8, 123u8, 253u8, 185u8],
            [217u8, 48u8, 160u8, 230u8],
            [217u8, 163u8, 196u8, 210u8],
            [219u8, 7u8, 252u8, 210u8],
            [219u8, 66u8, 53u8, 246u8],
            [219u8, 122u8, 70u8, 5u8],
            [219u8, 232u8, 216u8, 139u8],
            [220u8, 40u8, 192u8, 241u8],
            [221u8, 194u8, 101u8, 27u8],
            [224u8, 10u8, 208u8, 62u8],
            [224u8, 62u8, 145u8, 119u8],
            [224u8, 235u8, 4u8, 212u8],
            [225u8, 99u8, 24u8, 55u8],
            [226u8, 60u8, 209u8, 159u8],
            [226u8, 79u8, 237u8, 0u8],
            [226u8, 82u8, 66u8, 192u8],
            [227u8, 65u8, 234u8, 164u8],
            [227u8, 245u8, 174u8, 51u8],
            [228u8, 138u8, 143u8, 141u8],
            [229u8, 251u8, 155u8, 74u8],
            [230u8, 150u8, 44u8, 219u8],
            [234u8, 153u8, 27u8, 181u8],
            [235u8, 116u8, 132u8, 140u8],
            [235u8, 133u8, 232u8, 59u8],
            [235u8, 199u8, 58u8, 180u8],
            [236u8, 205u8, 36u8, 55u8],
            [237u8, 124u8, 84u8, 98u8],
            [237u8, 236u8, 208u8, 53u8],
            [239u8, 39u8, 125u8, 114u8],
            [239u8, 246u8, 178u8, 125u8],
            [240u8, 37u8, 158u8, 146u8],
            [241u8, 175u8, 224u8, 77u8],
            [242u8, 29u8, 82u8, 199u8],
            [242u8, 250u8, 74u8, 38u8],
            [243u8, 32u8, 217u8, 99u8],
            [243u8, 222u8, 192u8, 153u8],
            [244u8, 19u8, 240u8, 182u8],
            [244u8, 92u8, 28u8, 231u8],
            [244u8, 192u8, 4u8, 227u8],
            [245u8, 79u8, 224u8, 9u8],
            [245u8, 165u8, 85u8, 88u8],
            [246u8, 122u8, 150u8, 91u8],
            [247u8, 16u8, 176u8, 98u8],
            [247u8, 175u8, 233u8, 25u8],
            [247u8, 211u8, 154u8, 141u8],
            [247u8, 254u8, 52u8, 119u8],
            [248u8, 119u8, 203u8, 25u8],
            [248u8, 211u8, 59u8, 155u8],
            [248u8, 213u8, 142u8, 175u8],
            [249u8, 250u8, 92u8, 219u8],
            [250u8, 145u8, 69u8, 77u8],
            [250u8, 157u8, 135u8, 19u8],
            [252u8, 204u8, 17u8, 196u8],
            [253u8, 146u8, 27u8, 232u8],
            [254u8, 116u8, 240u8, 91u8],
            [254u8, 162u8, 209u8, 79u8],
            [254u8, 233u8, 164u8, 105u8],
            [255u8, 161u8, 134u8, 73u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for VmSafeCalls {
        const NAME: &'static str = "VmSafeCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 365usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::accesses(_) => <accessesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::addr(_) => <addrCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertApproxEqAbs_0(_) => {
                    <assertApproxEqAbs_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbs_1(_) => {
                    <assertApproxEqAbs_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbs_2(_) => {
                    <assertApproxEqAbs_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbs_3(_) => {
                    <assertApproxEqAbs_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbsDecimal_0(_) => {
                    <assertApproxEqAbsDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbsDecimal_1(_) => {
                    <assertApproxEqAbsDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbsDecimal_2(_) => {
                    <assertApproxEqAbsDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqAbsDecimal_3(_) => {
                    <assertApproxEqAbsDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRel_0(_) => {
                    <assertApproxEqRel_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRel_1(_) => {
                    <assertApproxEqRel_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRel_2(_) => {
                    <assertApproxEqRel_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRel_3(_) => {
                    <assertApproxEqRel_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRelDecimal_0(_) => {
                    <assertApproxEqRelDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRelDecimal_1(_) => {
                    <assertApproxEqRelDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRelDecimal_2(_) => {
                    <assertApproxEqRelDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertApproxEqRelDecimal_3(_) => {
                    <assertApproxEqRelDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertEq_0(_) => <assertEq_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_1(_) => <assertEq_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_2(_) => <assertEq_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_3(_) => <assertEq_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_4(_) => <assertEq_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_5(_) => <assertEq_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_6(_) => <assertEq_6Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_7(_) => <assertEq_7Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_8(_) => <assertEq_8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_9(_) => <assertEq_9Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_10(_) => <assertEq_10Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_11(_) => <assertEq_11Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_12(_) => <assertEq_12Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_13(_) => <assertEq_13Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_14(_) => <assertEq_14Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_15(_) => <assertEq_15Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_16(_) => <assertEq_16Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_17(_) => <assertEq_17Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_18(_) => <assertEq_18Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_19(_) => <assertEq_19Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_20(_) => <assertEq_20Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_21(_) => <assertEq_21Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_22(_) => <assertEq_22Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_23(_) => <assertEq_23Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_24(_) => <assertEq_24Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_25(_) => <assertEq_25Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_26(_) => <assertEq_26Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEq_27(_) => <assertEq_27Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertEqDecimal_0(_) => {
                    <assertEqDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertEqDecimal_1(_) => {
                    <assertEqDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertEqDecimal_2(_) => {
                    <assertEqDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertEqDecimal_3(_) => {
                    <assertEqDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertFalse_0(_) => <assertFalse_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertFalse_1(_) => <assertFalse_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGe_0(_) => <assertGe_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGe_1(_) => <assertGe_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGe_2(_) => <assertGe_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGe_3(_) => <assertGe_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGeDecimal_0(_) => {
                    <assertGeDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGeDecimal_1(_) => {
                    <assertGeDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGeDecimal_2(_) => {
                    <assertGeDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGeDecimal_3(_) => {
                    <assertGeDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGt_0(_) => <assertGt_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGt_1(_) => <assertGt_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGt_2(_) => <assertGt_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGt_3(_) => <assertGt_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertGtDecimal_0(_) => {
                    <assertGtDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGtDecimal_1(_) => {
                    <assertGtDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGtDecimal_2(_) => {
                    <assertGtDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertGtDecimal_3(_) => {
                    <assertGtDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLe_0(_) => <assertLe_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLe_1(_) => <assertLe_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLe_2(_) => <assertLe_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLe_3(_) => <assertLe_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLeDecimal_0(_) => {
                    <assertLeDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLeDecimal_1(_) => {
                    <assertLeDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLeDecimal_2(_) => {
                    <assertLeDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLeDecimal_3(_) => {
                    <assertLeDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLt_0(_) => <assertLt_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLt_1(_) => <assertLt_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLt_2(_) => <assertLt_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLt_3(_) => <assertLt_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertLtDecimal_0(_) => {
                    <assertLtDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLtDecimal_1(_) => {
                    <assertLtDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLtDecimal_2(_) => {
                    <assertLtDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertLtDecimal_3(_) => {
                    <assertLtDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_0(_) => <assertNotEq_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_1(_) => <assertNotEq_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_2(_) => <assertNotEq_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_3(_) => <assertNotEq_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_4(_) => <assertNotEq_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_5(_) => <assertNotEq_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_6(_) => <assertNotEq_6Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_7(_) => <assertNotEq_7Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_8(_) => <assertNotEq_8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_9(_) => <assertNotEq_9Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertNotEq_10(_) => {
                    <assertNotEq_10Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_11(_) => {
                    <assertNotEq_11Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_12(_) => {
                    <assertNotEq_12Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_13(_) => {
                    <assertNotEq_13Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_14(_) => {
                    <assertNotEq_14Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_15(_) => {
                    <assertNotEq_15Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_16(_) => {
                    <assertNotEq_16Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_17(_) => {
                    <assertNotEq_17Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_18(_) => {
                    <assertNotEq_18Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_19(_) => {
                    <assertNotEq_19Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_20(_) => {
                    <assertNotEq_20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_21(_) => {
                    <assertNotEq_21Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_22(_) => {
                    <assertNotEq_22Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_23(_) => {
                    <assertNotEq_23Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_24(_) => {
                    <assertNotEq_24Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_25(_) => {
                    <assertNotEq_25Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_26(_) => {
                    <assertNotEq_26Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEq_27(_) => {
                    <assertNotEq_27Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEqDecimal_0(_) => {
                    <assertNotEqDecimal_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEqDecimal_1(_) => {
                    <assertNotEqDecimal_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEqDecimal_2(_) => {
                    <assertNotEqDecimal_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertNotEqDecimal_3(_) => {
                    <assertNotEqDecimal_3Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::assertTrue_0(_) => <assertTrue_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assertTrue_1(_) => <assertTrue_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::assume(_) => <assumeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::assumeNoRevert(_) => {
                    <assumeNoRevertCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::attachDelegation(_) => {
                    <attachDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::breakpoint_0(_) => <breakpoint_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::breakpoint_1(_) => <breakpoint_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::broadcast_0(_) => <broadcast_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::broadcast_1(_) => <broadcast_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::broadcast_2(_) => <broadcast_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::broadcastRawTransaction(_) => {
                    <broadcastRawTransactionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeFile(_) => <closeFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::computeCreate2Address_0(_) => {
                    <computeCreate2Address_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeCreate2Address_1(_) => {
                    <computeCreate2Address_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::computeCreateAddress(_) => {
                    <computeCreateAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::contains(_) => <containsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::copyFile(_) => <copyFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::copyStorage(_) => <copyStorageCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::createDir(_) => <createDirCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::createWallet_0(_) => {
                    <createWallet_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createWallet_1(_) => {
                    <createWallet_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createWallet_2(_) => {
                    <createWallet_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deployCode_0(_) => <deployCode_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::deployCode_1(_) => <deployCode_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::deriveKey_0(_) => <deriveKey_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::deriveKey_1(_) => <deriveKey_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::deriveKey_2(_) => <deriveKey_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::deriveKey_3(_) => <deriveKey_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::ensNamehash(_) => <ensNamehashCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::envAddress_0(_) => <envAddress_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envAddress_1(_) => <envAddress_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBool_0(_) => <envBool_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBool_1(_) => <envBool_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBytes_0(_) => <envBytes_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBytes_1(_) => <envBytes_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBytes32_0(_) => <envBytes32_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envBytes32_1(_) => <envBytes32_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envExists(_) => <envExistsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::envInt_0(_) => <envInt_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envInt_1(_) => <envInt_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_0(_) => <envOr_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_1(_) => <envOr_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_2(_) => <envOr_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_3(_) => <envOr_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_4(_) => <envOr_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_5(_) => <envOr_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_6(_) => <envOr_6Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_7(_) => <envOr_7Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_8(_) => <envOr_8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_9(_) => <envOr_9Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_10(_) => <envOr_10Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_11(_) => <envOr_11Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_12(_) => <envOr_12Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envOr_13(_) => <envOr_13Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envString_0(_) => <envString_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envString_1(_) => <envString_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envUint_0(_) => <envUint_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::envUint_1(_) => <envUint_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::eth_getLogs(_) => <eth_getLogsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::exists(_) => <existsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ffi(_) => <ffiCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fsMetadata(_) => <fsMetadataCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getArtifactPathByCode(_) => {
                    <getArtifactPathByCodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getArtifactPathByDeployedCode(_) => {
                    <getArtifactPathByDeployedCodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlobBaseFee(_) => {
                    <getBlobBaseFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockNumber(_) => {
                    <getBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockTimestamp(_) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBroadcast(_) => <getBroadcastCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getBroadcasts_0(_) => {
                    <getBroadcasts_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBroadcasts_1(_) => {
                    <getBroadcasts_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCode(_) => <getCodeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getDeployedCode(_) => {
                    <getDeployedCodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDeployment_0(_) => {
                    <getDeployment_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDeployment_1(_) => {
                    <getDeployment_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDeployments(_) => {
                    <getDeploymentsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getFoundryVersion(_) => {
                    <getFoundryVersionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLabel(_) => <getLabelCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getMappingKeyAndParentOf(_) => {
                    <getMappingKeyAndParentOfCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getMappingLength(_) => {
                    <getMappingLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getMappingSlotAt(_) => {
                    <getMappingSlotAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getNonce_0(_) => <getNonce_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::getNonce_1(_) => <getNonce_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::getRecordedLogs(_) => {
                    <getRecordedLogsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getStateDiff(_) => <getStateDiffCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getStateDiffJson(_) => {
                    <getStateDiffJsonCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getWallets(_) => <getWalletsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::indexOf(_) => <indexOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isContext(_) => <isContextCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isDir(_) => <isDirCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isFile(_) => <isFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::keyExists(_) => <keyExistsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::keyExistsJson(_) => <keyExistsJsonCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::keyExistsToml(_) => <keyExistsTomlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::label(_) => <labelCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::lastCallGas(_) => <lastCallGasCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::load(_) => <loadCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseAddress(_) => <parseAddressCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseBool(_) => <parseBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseBytes(_) => <parseBytesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseBytes32(_) => <parseBytes32Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseInt(_) => <parseIntCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJson_0(_) => <parseJson_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJson_1(_) => <parseJson_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJsonAddress(_) => {
                    <parseJsonAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonAddressArray(_) => {
                    <parseJsonAddressArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonBool(_) => <parseJsonBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJsonBoolArray(_) => {
                    <parseJsonBoolArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonBytes(_) => {
                    <parseJsonBytesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonBytes32(_) => {
                    <parseJsonBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonBytes32Array(_) => {
                    <parseJsonBytes32ArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonBytesArray(_) => {
                    <parseJsonBytesArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonInt(_) => <parseJsonIntCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJsonIntArray(_) => {
                    <parseJsonIntArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonKeys(_) => <parseJsonKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJsonString(_) => {
                    <parseJsonStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonStringArray(_) => {
                    <parseJsonStringArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonType_0(_) => {
                    <parseJsonType_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonType_1(_) => {
                    <parseJsonType_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonTypeArray(_) => {
                    <parseJsonTypeArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseJsonUint(_) => <parseJsonUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseJsonUintArray(_) => {
                    <parseJsonUintArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseToml_0(_) => <parseToml_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseToml_1(_) => <parseToml_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseTomlAddress(_) => {
                    <parseTomlAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlAddressArray(_) => {
                    <parseTomlAddressArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlBool(_) => <parseTomlBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseTomlBoolArray(_) => {
                    <parseTomlBoolArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlBytes(_) => {
                    <parseTomlBytesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlBytes32(_) => {
                    <parseTomlBytes32Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlBytes32Array(_) => {
                    <parseTomlBytes32ArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlBytesArray(_) => {
                    <parseTomlBytesArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlInt(_) => <parseTomlIntCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseTomlIntArray(_) => {
                    <parseTomlIntArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlKeys(_) => <parseTomlKeysCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseTomlString(_) => {
                    <parseTomlStringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlStringArray(_) => {
                    <parseTomlStringArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlType_0(_) => {
                    <parseTomlType_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlType_1(_) => {
                    <parseTomlType_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlTypeArray(_) => {
                    <parseTomlTypeArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseTomlUint(_) => <parseTomlUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::parseTomlUintArray(_) => {
                    <parseTomlUintArrayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::parseUint(_) => <parseUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseGasMetering(_) => {
                    <pauseGasMeteringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pauseTracing(_) => <pauseTracingCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::projectRoot(_) => <projectRootCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::prompt(_) => <promptCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::promptAddress(_) => <promptAddressCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::promptSecret(_) => <promptSecretCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::promptSecretUint(_) => {
                    <promptSecretUintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::promptUint(_) => <promptUintCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::publicKeyP256(_) => <publicKeyP256Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomAddress(_) => <randomAddressCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomBool(_) => <randomBoolCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomBytes(_) => <randomBytesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomBytes4(_) => <randomBytes4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomBytes8(_) => <randomBytes8Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomInt_0(_) => <randomInt_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomInt_1(_) => <randomInt_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomUint_0(_) => <randomUint_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomUint_1(_) => <randomUint_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::randomUint_2(_) => <randomUint_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::readDir_0(_) => <readDir_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::readDir_1(_) => <readDir_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::readDir_2(_) => <readDir_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::readFile(_) => <readFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::readFileBinary(_) => {
                    <readFileBinaryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::readLine(_) => <readLineCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::readLink(_) => <readLinkCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::record(_) => <recordCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::recordLogs(_) => <recordLogsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rememberKey(_) => <rememberKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rememberKeys_0(_) => {
                    <rememberKeys_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rememberKeys_1(_) => {
                    <rememberKeys_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeDir(_) => <removeDirCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::removeFile(_) => <removeFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::replace(_) => <replaceCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::resetGasMetering(_) => {
                    <resetGasMeteringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeGasMetering(_) => {
                    <resumeGasMeteringCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::resumeTracing(_) => <resumeTracingCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rpc_0(_) => <rpc_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::rpc_1(_) => <rpc_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::rpcUrl(_) => <rpcUrlCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rpcUrlStructs(_) => <rpcUrlStructsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::rpcUrls(_) => <rpcUrlsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::serializeAddress_0(_) => {
                    <serializeAddress_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeAddress_1(_) => {
                    <serializeAddress_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBool_0(_) => {
                    <serializeBool_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBool_1(_) => {
                    <serializeBool_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBytes_0(_) => {
                    <serializeBytes_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBytes_1(_) => {
                    <serializeBytes_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBytes32_0(_) => {
                    <serializeBytes32_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeBytes32_1(_) => {
                    <serializeBytes32_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeInt_0(_) => {
                    <serializeInt_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeInt_1(_) => {
                    <serializeInt_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeJson(_) => <serializeJsonCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::serializeJsonType_0(_) => {
                    <serializeJsonType_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeJsonType_1(_) => {
                    <serializeJsonType_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeString_0(_) => {
                    <serializeString_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeString_1(_) => {
                    <serializeString_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeUint_0(_) => {
                    <serializeUint_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeUint_1(_) => {
                    <serializeUint_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serializeUintToHex(_) => {
                    <serializeUintToHexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setArbitraryStorage(_) => {
                    <setArbitraryStorageCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setEnv(_) => <setEnvCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::sign_0(_) => <sign_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::sign_1(_) => <sign_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::sign_2(_) => <sign_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::sign_3(_) => <sign_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::signAndAttachDelegation(_) => {
                    <signAndAttachDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::signCompact_0(_) => <signCompact_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::signCompact_1(_) => <signCompact_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::signCompact_2(_) => <signCompact_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::signCompact_3(_) => <signCompact_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::signDelegation(_) => {
                    <signDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::signP256(_) => <signP256Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::sleep(_) => <sleepCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::split(_) => <splitCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::startBroadcast_0(_) => {
                    <startBroadcast_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startBroadcast_1(_) => {
                    <startBroadcast_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startBroadcast_2(_) => {
                    <startBroadcast_2Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startDebugTraceRecording(_) => {
                    <startDebugTraceRecordingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startMappingRecording(_) => {
                    <startMappingRecordingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startStateDiffRecording(_) => {
                    <startStateDiffRecordingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stopAndReturnDebugTraceRecording(_) => {
                    <stopAndReturnDebugTraceRecordingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stopAndReturnStateDiff(_) => {
                    <stopAndReturnStateDiffCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stopBroadcast(_) => <stopBroadcastCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::stopMappingRecording(_) => {
                    <stopMappingRecordingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::toBase64_0(_) => <toBase64_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toBase64_1(_) => <toBase64_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toBase64URL_0(_) => <toBase64URL_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toBase64URL_1(_) => <toBase64URL_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toLowercase(_) => <toLowercaseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_0(_) => <toString_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_1(_) => <toString_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_2(_) => <toString_2Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_3(_) => <toString_3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_4(_) => <toString_4Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toString_5(_) => <toString_5Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::toUppercase(_) => <toUppercaseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::trim(_) => <trimCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::tryFfi(_) => <tryFfiCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unixTime(_) => <unixTimeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeFile(_) => <writeFileCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeFileBinary(_) => {
                    <writeFileBinaryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::writeJson_0(_) => <writeJson_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeJson_1(_) => <writeJson_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeLine(_) => <writeLineCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeToml_0(_) => <writeToml_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::writeToml_1(_) => <writeToml_1Call as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(&[u8], bool) -> alloy_sol_types::Result<VmSafeCalls>] = &[
                {
                    fn parseJsonTypeArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonTypeArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonTypeArray)
                    }
                    parseJsonTypeArray
                },
                {
                    fn rpc_0(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rpc_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::rpc_0)
                    }
                    rpc_0
                },
                {
                    fn assertApproxEqAbsDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbsDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqAbsDecimal_0)
                    }
                    assertApproxEqAbsDecimal_0
                },
                {
                    fn randomBytes8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomBytes8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomBytes8)
                    }
                    randomBytes8
                },
                {
                    fn assertGtDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGtDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGtDecimal_0)
                    }
                    assertGtDecimal_0
                },
                {
                    fn assertNotEq_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_0)
                    }
                    assertNotEq_0
                },
                {
                    fn toUppercase(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toUppercaseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::toUppercase)
                    }
                    toUppercase
                },
                {
                    fn parseBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseBytes32)
                    }
                    parseBytes32
                },
                {
                    fn assertGe_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGe_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGe_0)
                    }
                    assertGe_0
                },
                {
                    fn assertNotEq_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_1)
                    }
                    assertNotEq_1
                },
                {
                    fn assertTrue_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertTrue_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertTrue_0)
                    }
                    assertTrue_0
                },
                {
                    fn assertEq_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_0)
                    }
                    assertEq_0
                },
                {
                    fn stopMappingRecording(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <stopMappingRecordingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::stopMappingRecording)
                    }
                    stopMappingRecording
                },
                {
                    fn getDeployment_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getDeployment_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getDeployment_0)
                    }
                    getDeployment_0
                },
                {
                    fn assertNotEq_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_2)
                    }
                    assertNotEq_2
                },
                {
                    fn randomInt_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomInt_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomInt_0)
                    }
                    randomInt_0
                },
                {
                    fn assertLeDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLeDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLeDecimal_0)
                    }
                    assertLeDecimal_0
                },
                {
                    fn rpc_1(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rpc_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::rpc_1)
                    }
                    rpc_1
                },
                {
                    fn parseTomlBoolArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBoolArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBoolArray)
                    }
                    parseTomlBoolArray
                },
                {
                    fn randomInt_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomInt_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomInt_1)
                    }
                    randomInt_1
                },
                {
                    fn serializeUint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeUint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeUint_0)
                    }
                    serializeUint_0
                },
                {
                    fn readDir_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readDir_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readDir_0)
                    }
                    readDir_0
                },
                {
                    fn attachDelegation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <attachDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::attachDelegation)
                    }
                    attachDelegation
                },
                {
                    fn envString_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envString_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envString_0)
                    }
                    envString_0
                },
                {
                    fn assertNotEqDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEqDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEqDecimal_0)
                    }
                    assertNotEqDecimal_0
                },
                {
                    fn createDir(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <createDirCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::createDir)
                    }
                    createDir
                },
                {
                    fn assertApproxEqAbs_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbs_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqAbs_0)
                    }
                    assertApproxEqAbs_0
                },
                {
                    fn readFileBinary(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readFileBinaryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::readFileBinary)
                    }
                    readFileBinary
                },
                {
                    fn parseJsonBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBytes32)
                    }
                    parseJsonBytes32
                },
                {
                    fn getRecordedLogs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getRecordedLogsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getRecordedLogs)
                    }
                    getRecordedLogs
                },
                {
                    fn assertEq_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_1)
                    }
                    assertEq_1
                },
                {
                    fn assertNotEq_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_3)
                    }
                    assertNotEq_3
                },
                {
                    fn parseJsonAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonAddress)
                    }
                    parseJsonAddress
                },
                {
                    fn promptSecret(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <promptSecretCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::promptSecret)
                    }
                    promptSecret
                },
                {
                    fn serializeAddress_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeAddress_0)
                    }
                    serializeAddress_0
                },
                {
                    fn assertApproxEqRel_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRel_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqRel_0)
                    }
                    assertApproxEqRel_0
                },
                {
                    fn writeFileBinary(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeFileBinaryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::writeFileBinary)
                    }
                    writeFileBinary
                },
                {
                    fn getBlobBaseFee(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBlobBaseFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBlobBaseFee)
                    }
                    getBlobBaseFee
                },
                {
                    fn serializeBytes32_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBytes32_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBytes32_0)
                    }
                    serializeBytes32_0
                },
                {
                    fn copyStorage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <copyStorageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::copyStorage)
                    }
                    copyStorage
                },
                {
                    fn assertLtDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLtDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLtDecimal_0)
                    }
                    assertLtDecimal_0
                },
                {
                    fn parseJsonKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonKeys)
                    }
                    parseJsonKeys
                },
                {
                    fn assertApproxEqRelDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRelDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqRelDecimal_0)
                    }
                    assertApproxEqRelDecimal_0
                },
                {
                    fn rememberKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rememberKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::rememberKey)
                    }
                    rememberKey
                },
                {
                    fn envOr_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_0)
                    }
                    envOr_0
                },
                {
                    fn assertNotEq_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_4)
                    }
                    assertNotEq_4
                },
                {
                    fn assertApproxEqAbs_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbs_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqAbs_1)
                    }
                    assertApproxEqAbs_1
                },
                {
                    fn randomUint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomUint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomUint_0)
                    }
                    randomUint_0
                },
                {
                    fn exists(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <existsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::exists)
                    }
                    exists
                },
                {
                    fn record(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <recordCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::record)
                    }
                    record
                },
                {
                    fn assertEqDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEqDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEqDecimal_0)
                    }
                    assertEqDecimal_0
                },
                {
                    fn assumeNoRevert(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assumeNoRevertCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assumeNoRevert)
                    }
                    assumeNoRevert
                },
                {
                    fn assertNotEq_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_5Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_5)
                    }
                    assertNotEq_5
                },
                {
                    fn getLabel(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getLabelCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::getLabel)
                    }
                    getLabel
                },
                {
                    fn deriveKey_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deriveKey_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deriveKey_0)
                    }
                    deriveKey_0
                },
                {
                    fn deployCode_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deployCode_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deployCode_0)
                    }
                    deployCode_0
                },
                {
                    fn lastCallGas(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <lastCallGasCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::lastCallGas)
                    }
                    lastCallGas
                },
                {
                    fn resumeGasMetering(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <resumeGasMeteringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::resumeGasMetering)
                    }
                    resumeGasMetering
                },
                {
                    fn getNonce_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getNonce_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::getNonce_0)
                    }
                    getNonce_0
                },
                {
                    fn serializeBytes32_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBytes32_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBytes32_1)
                    }
                    serializeBytes32_1
                },
                {
                    fn assertEq_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_2)
                    }
                    assertEq_2
                },
                {
                    fn getMappingLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getMappingLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getMappingLength)
                    }
                    getMappingLength
                },
                {
                    fn parseJsonAddressArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonAddressArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonAddressArray)
                    }
                    parseJsonAddressArray
                },
                {
                    fn deriveKey_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deriveKey_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deriveKey_1)
                    }
                    deriveKey_1
                },
                {
                    fn assertNotEqDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEqDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEqDecimal_1)
                    }
                    assertNotEqDecimal_1
                },
                {
                    fn envAddress_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envAddress_0)
                    }
                    envAddress_0
                },
                {
                    fn writeJson_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeJson_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::writeJson_0)
                    }
                    writeJson_0
                },
                {
                    fn eth_getLogs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <eth_getLogsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::eth_getLogs)
                    }
                    eth_getLogs
                },
                {
                    fn assertEq_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_3)
                    }
                    assertEq_3
                },
                {
                    fn parseToml_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseToml_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseToml_0)
                    }
                    parseToml_0
                },
                {
                    fn assertEq_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_4Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_4)
                    }
                    assertEq_4
                },
                {
                    fn assertNotEq_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_6Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_6)
                    }
                    assertNotEq_6
                },
                {
                    fn signCompact_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signCompact_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signCompact_0)
                    }
                    signCompact_0
                },
                {
                    fn assertGeDecimal_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGeDecimal_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGeDecimal_0)
                    }
                    assertGeDecimal_0
                },
                {
                    fn setEnv(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <setEnvCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::setEnv)
                    }
                    setEnv
                },
                {
                    fn assertApproxEqAbsDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbsDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqAbsDecimal_1)
                    }
                    assertApproxEqAbsDecimal_1
                },
                {
                    fn getBroadcast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBroadcastCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBroadcast)
                    }
                    getBroadcast
                },
                {
                    fn parseTomlBytes32Array(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBytes32ArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBytes32Array)
                    }
                    parseTomlBytes32Array
                },
                {
                    fn assertLt_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLt_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLt_0)
                    }
                    assertLt_0
                },
                {
                    fn assertEq_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_5Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_5)
                    }
                    assertEq_5
                },
                {
                    fn startMappingRecording(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startMappingRecordingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startMappingRecording)
                    }
                    startMappingRecording
                },
                {
                    fn getDeployedCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getDeployedCodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getDeployedCode)
                    }
                    getDeployedCode
                },
                {
                    fn serializeInt_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeInt_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeInt_0)
                    }
                    serializeInt_0
                },
                {
                    fn toBase64_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toBase64_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toBase64_0)
                    }
                    toBase64_0
                },
                {
                    fn contains(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <containsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::contains)
                    }
                    contains
                },
                {
                    fn assertLtDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLtDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLtDecimal_1)
                    }
                    assertLtDecimal_1
                },
                {
                    fn startDebugTraceRecording(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startDebugTraceRecording)
                    }
                    startDebugTraceRecording
                },
                {
                    fn recordLogs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <recordLogsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::recordLogs)
                    }
                    recordLogs
                },
                {
                    fn envInt_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envInt_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envInt_0)
                    }
                    envInt_0
                },
                {
                    fn parseInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseIntCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::parseInt)
                    }
                    parseInt
                },
                {
                    fn getBlockNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBlockNumber)
                    }
                    getBlockNumber
                },
                {
                    fn removeDir(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <removeDirCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::removeDir)
                    }
                    removeDir
                },
                {
                    fn assertNotEq_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_7Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_7)
                    }
                    assertNotEq_7
                },
                {
                    fn envOr_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_1)
                    }
                    envOr_1
                },
                {
                    fn assertNotEq_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_8Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_8)
                    }
                    assertNotEq_8
                },
                {
                    fn envOr_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_2)
                    }
                    envOr_2
                },
                {
                    fn prompt(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <promptCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::prompt)
                    }
                    prompt
                },
                {
                    fn parseTomlType_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlType_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlType_0)
                    }
                    parseTomlType_0
                },
                {
                    fn assertEqDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEqDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEqDecimal_1)
                    }
                    assertEqDecimal_1
                },
                {
                    fn closeFile(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <closeFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::closeFile)
                    }
                    closeFile
                },
                {
                    fn parseJsonStringArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonStringArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonStringArray)
                    }
                    parseJsonStringArray
                },
                {
                    fn parseTomlTypeArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlTypeArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlTypeArray)
                    }
                    parseTomlTypeArray
                },
                {
                    fn parseJsonString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonString)
                    }
                    parseJsonString
                },
                {
                    fn assume(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assumeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assume)
                    }
                    assume
                },
                {
                    fn envBytes_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBytes_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envBytes_0)
                    }
                    envBytes_0
                },
                {
                    fn assertEq_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_6Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_6)
                    }
                    assertEq_6
                },
                {
                    fn assertLe_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLe_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLe_0)
                    }
                    assertLe_0
                },
                {
                    fn toLowercase(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toLowercaseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::toLowercase)
                    }
                    toLowercase
                },
                {
                    fn assertEq_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_7Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_7)
                    }
                    assertEq_7
                },
                {
                    fn writeToml_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeToml_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::writeToml_0)
                    }
                    writeToml_0
                },
                {
                    fn parseJsonUintArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonUintArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonUintArray)
                    }
                    parseJsonUintArray
                },
                {
                    fn keyExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <keyExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::keyExists)
                    }
                    keyExists
                },
                {
                    fn serializeString_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeString_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeString_0)
                    }
                    serializeString_0
                },
                {
                    fn envOr_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_3)
                    }
                    envOr_3
                },
                {
                    fn toString_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_0)
                    }
                    toString_0
                },
                {
                    fn assertNotEq_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_9Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_9)
                    }
                    assertNotEq_9
                },
                {
                    fn parseToml_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseToml_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseToml_1)
                    }
                    parseToml_1
                },
                {
                    fn assertGt_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGt_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGt_0)
                    }
                    assertGt_0
                },
                {
                    fn envBytes32_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBytes32_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envBytes32_0)
                    }
                    envBytes32_0
                },
                {
                    fn signDelegation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signDelegation)
                    }
                    signDelegation
                },
                {
                    fn assertEq_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_8Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_8)
                    }
                    assertEq_8
                },
                {
                    fn assertGeDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGeDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGeDecimal_1)
                    }
                    assertGeDecimal_1
                },
                {
                    fn envOr_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_4Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_4)
                    }
                    envOr_4
                },
                {
                    fn keyExistsToml(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <keyExistsTomlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::keyExistsToml)
                    }
                    keyExistsToml
                },
                {
                    fn assertApproxEqAbsDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbsDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqAbsDecimal_2)
                    }
                    assertApproxEqAbsDecimal_2
                },
                {
                    fn readFile(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readFile)
                    }
                    readFile
                },
                {
                    fn writeLine(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeLineCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::writeLine)
                    }
                    writeLine
                },
                {
                    fn deriveKey_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deriveKey_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deriveKey_2)
                    }
                    deriveKey_2
                },
                {
                    fn unixTime(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <unixTimeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::unixTime)
                    }
                    unixTime
                },
                {
                    fn assertNotEq_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_10)
                    }
                    assertNotEq_10
                },
                {
                    fn promptAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <promptAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::promptAddress)
                    }
                    promptAddress
                },
                {
                    fn assertGtDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGtDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGtDecimal_1)
                    }
                    assertGtDecimal_1
                },
                {
                    fn isContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <isContextCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::isContext)
                    }
                    isContext
                },
                {
                    fn envOr_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_5Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_5)
                    }
                    envOr_5
                },
                {
                    fn promptUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <promptUintCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::promptUint)
                    }
                    promptUint
                },
                {
                    fn accesses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <accessesCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::accesses)
                    }
                    accesses
                },
                {
                    fn parseTomlAddressArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlAddressArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlAddressArray)
                    }
                    parseTomlAddressArray
                },
                {
                    fn assertLt_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLt_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLt_1)
                    }
                    assertLt_1
                },
                {
                    fn parseTomlAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlAddress)
                    }
                    parseTomlAddress
                },
                {
                    fn parseJsonBytesArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBytesArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBytesArray)
                    }
                    parseJsonBytesArray
                },
                {
                    fn load(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <loadCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::load)
                    }
                    load
                },
                {
                    fn assertNotEqDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEqDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEqDecimal_2)
                    }
                    assertNotEqDecimal_2
                },
                {
                    fn toString_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_1)
                    }
                    toString_1
                },
                {
                    fn promptSecretUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <promptSecretUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::promptSecretUint)
                    }
                    promptSecretUint
                },
                {
                    fn assertApproxEqAbsDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbsDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqAbsDecimal_3)
                    }
                    assertApproxEqAbsDecimal_3
                },
                {
                    fn assertNotEq_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_11)
                    }
                    assertNotEq_11
                },
                {
                    fn parseJson_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJson_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJson_0)
                    }
                    parseJson_0
                },
                {
                    fn deriveKey_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deriveKey_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deriveKey_3)
                    }
                    deriveKey_3
                },
                {
                    fn randomBytes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomBytes)
                    }
                    randomBytes
                },
                {
                    fn serializeJsonType_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeJsonType_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeJsonType_0)
                    }
                    serializeJsonType_0
                },
                {
                    fn getArtifactPathByDeployedCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getArtifactPathByDeployedCodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::getArtifactPathByDeployedCode)
                    }
                    getArtifactPathByDeployedCode
                },
                {
                    fn serializeJsonType_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeJsonType_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeJsonType_1)
                    }
                    serializeJsonType_1
                },
                {
                    fn assertEq_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_9Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertEq_9)
                    }
                    assertEq_9
                },
                {
                    fn readLine(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readLineCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readLine)
                    }
                    readLine
                },
                {
                    fn assertEq_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_10Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_10)
                    }
                    assertEq_10
                },
                {
                    fn assertEq_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_11Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_11)
                    }
                    assertEq_11
                },
                {
                    fn toString_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_2)
                    }
                    toString_2
                },
                {
                    fn toString_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_3)
                    }
                    toString_3
                },
                {
                    fn resumeTracing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <resumeTracingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::resumeTracing)
                    }
                    resumeTracing
                },
                {
                    fn assertNotEq_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_12)
                    }
                    assertNotEq_12
                },
                {
                    fn createWallet_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <createWallet_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::createWallet_0)
                    }
                    createWallet_0
                },
                {
                    fn envOr_6(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_6Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_6)
                    }
                    envOr_6
                },
                {
                    fn computeCreateAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <computeCreateAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::computeCreateAddress)
                    }
                    computeCreateAddress
                },
                {
                    fn getDeployments(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getDeploymentsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getDeployments)
                    }
                    getDeployments
                },
                {
                    fn serializeInt_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeInt_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeInt_1)
                    }
                    serializeInt_1
                },
                {
                    fn stopBroadcast(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <stopBroadcastCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::stopBroadcast)
                    }
                    stopBroadcast
                },
                {
                    fn assertGtDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGtDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGtDecimal_2)
                    }
                    assertGtDecimal_2
                },
                {
                    fn assertNotEq_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_13)
                    }
                    assertNotEq_13
                },
                {
                    fn getBlockTimestamp(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBlockTimestamp)
                    }
                    getBlockTimestamp
                },
                {
                    fn sign_0(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <sign_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::sign_0)
                    }
                    sign_0
                },
                {
                    fn createWallet_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <createWallet_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::createWallet_1)
                    }
                    createWallet_1
                },
                {
                    fn parseJsonInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonInt)
                    }
                    parseJsonInt
                },
                {
                    fn assertFalse_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertFalse_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertFalse_0)
                    }
                    assertFalse_0
                },
                {
                    fn assertEq_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_12Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_12)
                    }
                    assertEq_12
                },
                {
                    fn isDir(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <isDirCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::isDir)
                    }
                    isDir
                },
                {
                    fn assertEqDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEqDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEqDecimal_2)
                    }
                    assertEqDecimal_2
                },
                {
                    fn envBool_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBool_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envBool_0)
                    }
                    envBool_0
                },
                {
                    fn startBroadcast_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startBroadcast_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startBroadcast_0)
                    }
                    startBroadcast_0
                },
                {
                    fn startBroadcast_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startBroadcast_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startBroadcast_1)
                    }
                    startBroadcast_1
                },
                {
                    fn assertLeDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLeDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLeDecimal_1)
                    }
                    assertLeDecimal_1
                },
                {
                    fn getStateDiff(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getStateDiffCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getStateDiff)
                    }
                    getStateDiff
                },
                {
                    fn readDir_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readDir_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readDir_1)
                    }
                    readDir_1
                },
                {
                    fn parseTomlKeys(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlKeysCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlKeys)
                    }
                    parseTomlKeys
                },
                {
                    fn assertApproxEqAbs_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbs_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqAbs_2)
                    }
                    assertApproxEqAbs_2
                },
                {
                    fn assertApproxEqRelDecimal_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRelDecimal_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqRelDecimal_1)
                    }
                    assertApproxEqRelDecimal_1
                },
                {
                    fn signP256(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signP256Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::signP256)
                    }
                    signP256
                },
                {
                    fn assertLe_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLe_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLe_1)
                    }
                    assertLe_1
                },
                {
                    fn envOr_7(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_7Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_7)
                    }
                    envOr_7
                },
                {
                    fn parseJson_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJson_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJson_1)
                    }
                    parseJson_1
                },
                {
                    fn getMappingKeyAndParentOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getMappingKeyAndParentOfCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getMappingKeyAndParentOf)
                    }
                    getMappingKeyAndParentOf
                },
                {
                    fn assertNotEq_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_14)
                    }
                    assertNotEq_14
                },
                {
                    fn assertEq_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_13Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_13)
                    }
                    assertEq_13
                },
                {
                    fn serializeString_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeString_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeString_1)
                    }
                    serializeString_1
                },
                {
                    fn computeCreate2Address_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <computeCreate2Address_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::computeCreate2Address_0)
                    }
                    computeCreate2Address_0
                },
                {
                    fn ffi(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <ffiCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::ffi)
                    }
                    ffi
                },
                {
                    fn envInt_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envInt_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envInt_1)
                    }
                    envInt_1
                },
                {
                    fn writeFile(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::writeFile)
                    }
                    writeFile
                },
                {
                    fn assertNotEq_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_15)
                    }
                    assertNotEq_15
                },
                {
                    fn indexOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <indexOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::indexOf)
                    }
                    indexOf
                },
                {
                    fn split(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <splitCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::split)
                    }
                    split
                },
                {
                    fn parseTomlString(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlStringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlString)
                    }
                    parseTomlString
                },
                {
                    fn assertGeDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGeDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGeDecimal_2)
                    }
                    assertGeDecimal_2
                },
                {
                    fn broadcastRawTransaction(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <broadcastRawTransactionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::broadcastRawTransaction)
                    }
                    broadcastRawTransaction
                },
                {
                    fn sign_1(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <sign_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::sign_1)
                    }
                    sign_1
                },
                {
                    fn ensNamehash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <ensNamehashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::ensNamehash)
                    }
                    ensNamehash
                },
                {
                    fn assertApproxEqRel_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRel_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqRel_1)
                    }
                    assertApproxEqRel_1
                },
                {
                    fn getCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getCodeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::getCode)
                    }
                    getCode
                },
                {
                    fn parseTomlBytes32(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBytes32Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBytes32)
                    }
                    parseTomlBytes32
                },
                {
                    fn signCompact_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signCompact_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signCompact_1)
                    }
                    signCompact_1
                },
                {
                    fn parseBytes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::parseBytes)
                    }
                    parseBytes
                },
                {
                    fn parseJsonBytes32Array(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBytes32ArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBytes32Array)
                    }
                    parseJsonBytes32Array
                },
                {
                    fn parseJsonBoolArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBoolArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBoolArray)
                    }
                    parseJsonBoolArray
                },
                {
                    fn serializeBool_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBool_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBool_0)
                    }
                    serializeBool_0
                },
                {
                    fn assertNotEq_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_16)
                    }
                    assertNotEq_16
                },
                {
                    fn assertLe_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLe_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLe_2)
                    }
                    assertLe_2
                },
                {
                    fn serializeAddress_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeAddress_1)
                    }
                    serializeAddress_1
                },
                {
                    fn parseBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::parseBool)
                    }
                    parseBool
                },
                {
                    fn rpcUrl(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rpcUrlCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::rpcUrl)
                    }
                    rpcUrl
                },
                {
                    fn assertEq_14(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_14Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_14)
                    }
                    assertEq_14
                },
                {
                    fn assertEq_15(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_15Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_15)
                    }
                    assertEq_15
                },
                {
                    fn envBytes32_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBytes32_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envBytes32_1)
                    }
                    envBytes32_1
                },
                {
                    fn rememberKeys_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rememberKeys_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::rememberKeys_0)
                    }
                    rememberKeys_0
                },
                {
                    fn assertEq_16(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_16Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_16)
                    }
                    assertEq_16
                },
                {
                    fn serializeBytes_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBytes_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBytes_0)
                    }
                    serializeBytes_0
                },
                {
                    fn assertNotEq_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_17)
                    }
                    assertNotEq_17
                },
                {
                    fn parseJsonIntArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonIntArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonIntArray)
                    }
                    parseJsonIntArray
                },
                {
                    fn assertNotEq_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_18)
                    }
                    assertNotEq_18
                },
                {
                    fn deployCode_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <deployCode_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::deployCode_1)
                    }
                    deployCode_1
                },
                {
                    fn serializeJson(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeJsonCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeJson)
                    }
                    serializeJson
                },
                {
                    fn randomBytes4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomBytes4Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomBytes4)
                    }
                    randomBytes4
                },
                {
                    fn rpcUrlStructs(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rpcUrlStructsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::rpcUrlStructs)
                    }
                    rpcUrlStructs
                },
                {
                    fn readLink(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readLinkCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readLink)
                    }
                    readLink
                },
                {
                    fn parseTomlStringArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlStringArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlStringArray)
                    }
                    parseTomlStringArray
                },
                {
                    fn parseJsonBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBool)
                    }
                    parseJsonBool
                },
                {
                    fn assertLt_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLt_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLt_2)
                    }
                    assertLt_2
                },
                {
                    fn signCompact_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signCompact_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signCompact_2)
                    }
                    signCompact_2
                },
                {
                    fn toString_4(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_4Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_4)
                    }
                    toString_4
                },
                {
                    fn assertTrue_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertTrue_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertTrue_1)
                    }
                    assertTrue_1
                },
                {
                    fn copyFile(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <copyFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::copyFile)
                    }
                    copyFile
                },
                {
                    fn getNonce_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getNonce_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::getNonce_1)
                    }
                    getNonce_1
                },
                {
                    fn assertFalse_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertFalse_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertFalse_1)
                    }
                    assertFalse_1
                },
                {
                    fn toBase64_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toBase64_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toBase64_1)
                    }
                    toBase64_1
                },
                {
                    fn getDeployment_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getDeployment_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getDeployment_1)
                    }
                    getDeployment_1
                },
                {
                    fn assertGe_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGe_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGe_1)
                    }
                    assertGe_1
                },
                {
                    fn rpcUrls(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rpcUrlsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::rpcUrls)
                    }
                    rpcUrls
                },
                {
                    fn assertGe_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGe_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGe_2)
                    }
                    assertGe_2
                },
                {
                    fn assertLtDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLtDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLtDecimal_2)
                    }
                    assertLtDecimal_2
                },
                {
                    fn parseJsonType_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonType_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonType_0)
                    }
                    parseJsonType_0
                },
                {
                    fn assertLeDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLeDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLeDecimal_2)
                    }
                    assertLeDecimal_2
                },
                {
                    fn stopAndReturnStateDiff(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <stopAndReturnStateDiffCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::stopAndReturnStateDiff)
                    }
                    stopAndReturnStateDiff
                },
                {
                    fn envBool_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBool_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envBool_1)
                    }
                    envBool_1
                },
                {
                    fn assertApproxEqRelDecimal_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRelDecimal_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqRelDecimal_2)
                    }
                    assertApproxEqRelDecimal_2
                },
                {
                    fn serializeBool_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBool_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBool_1)
                    }
                    serializeBool_1
                },
                {
                    fn envAddress_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envAddress_1)
                    }
                    envAddress_1
                },
                {
                    fn parseJsonUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonUint)
                    }
                    parseJsonUint
                },
                {
                    fn toBase64URL_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toBase64URL_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::toBase64URL_0)
                    }
                    toBase64URL_0
                },
                {
                    fn serializeUintToHex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeUintToHexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeUintToHex)
                    }
                    serializeUintToHex
                },
                {
                    fn fsMetadata(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <fsMetadataCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::fsMetadata)
                    }
                    fsMetadata
                },
                {
                    fn broadcast_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <broadcast_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::broadcast_0)
                    }
                    broadcast_0
                },
                {
                    fn toString_5(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toString_5Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::toString_5)
                    }
                    toString_5
                },
                {
                    fn assertNotEq_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_19)
                    }
                    assertNotEq_19
                },
                {
                    fn assertLt_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLt_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLt_3)
                    }
                    assertLt_3
                },
                {
                    fn parseTomlBytesArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBytesArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBytesArray)
                    }
                    parseTomlBytesArray
                },
                {
                    fn assertNotEq_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_20)
                    }
                    assertNotEq_20
                },
                {
                    fn sign_2(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <sign_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::sign_2)
                    }
                    sign_2
                },
                {
                    fn trim(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <trimCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::trim)
                    }
                    trim
                },
                {
                    fn envOr_8(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_8Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_8)
                    }
                    envOr_8
                },
                {
                    fn envOr_9(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_9Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_9)
                    }
                    envOr_9
                },
                {
                    fn parseTomlUintArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlUintArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlUintArray)
                    }
                    parseTomlUintArray
                },
                {
                    fn assertNotEq_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_21)
                    }
                    assertNotEq_21
                },
                {
                    fn assertNotEq_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_22)
                    }
                    assertNotEq_22
                },
                {
                    fn assertNotEq_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_23)
                    }
                    assertNotEq_23
                },
                {
                    fn envOr_10(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_10Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_10)
                    }
                    envOr_10
                },
                {
                    fn assertNotEq_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_24)
                    }
                    assertNotEq_24
                },
                {
                    fn resetGasMetering(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <resetGasMeteringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::resetGasMetering)
                    }
                    resetGasMetering
                },
                {
                    fn writeToml_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeToml_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::writeToml_1)
                    }
                    writeToml_1
                },
                {
                    fn parseTomlInt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlIntCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlInt)
                    }
                    parseTomlInt
                },
                {
                    fn envUint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envUint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envUint_0)
                    }
                    envUint_0
                },
                {
                    fn assertEq_17(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_17Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_17)
                    }
                    assertEq_17
                },
                {
                    fn assertLeDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLeDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLeDecimal_3)
                    }
                    assertLeDecimal_3
                },
                {
                    fn publicKeyP256(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <publicKeyP256Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::publicKeyP256)
                    }
                    publicKeyP256
                },
                {
                    fn readDir_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <readDir_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::readDir_2)
                    }
                    readDir_2
                },
                {
                    fn label(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <labelCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::label)
                    }
                    label
                },
                {
                    fn parseAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseAddress)
                    }
                    parseAddress
                },
                {
                    fn envOr_11(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_11Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_11)
                    }
                    envOr_11
                },
                {
                    fn signAndAttachDelegation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signAndAttachDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signAndAttachDelegation)
                    }
                    signAndAttachDelegation
                },
                {
                    fn toBase64URL_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <toBase64URL_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::toBase64URL_1)
                    }
                    toBase64URL_1
                },
                {
                    fn pauseTracing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <pauseTracingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::pauseTracing)
                    }
                    pauseTracing
                },
                {
                    fn signCompact_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <signCompact_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::signCompact_3)
                    }
                    signCompact_3
                },
                {
                    fn parseTomlUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlUintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlUint)
                    }
                    parseTomlUint
                },
                {
                    fn randomBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::randomBool)
                    }
                    randomBool
                },
                {
                    fn startBroadcast_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startBroadcast_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startBroadcast_2)
                    }
                    startBroadcast_2
                },
                {
                    fn envExists(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envExistsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envExists)
                    }
                    envExists
                },
                {
                    fn stopAndReturnDebugTraceRecording(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <stopAndReturnDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::stopAndReturnDebugTraceRecording)
                    }
                    stopAndReturnDebugTraceRecording
                },
                {
                    fn assertEq_18(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_18Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_18)
                    }
                    assertEq_18
                },
                {
                    fn startStateDiffRecording(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <startStateDiffRecordingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::startStateDiffRecording)
                    }
                    startStateDiffRecording
                },
                {
                    fn randomUint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomUint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomUint_1)
                    }
                    randomUint_1
                },
                {
                    fn assertEqDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEqDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEqDecimal_3)
                    }
                    assertEqDecimal_3
                },
                {
                    fn envOr_12(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_12Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_12)
                    }
                    envOr_12
                },
                {
                    fn assertLe_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLe_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertLe_3)
                    }
                    assertLe_3
                },
                {
                    fn pauseGasMetering(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <pauseGasMeteringCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::pauseGasMetering)
                    }
                    pauseGasMetering
                },
                {
                    fn parseTomlBool(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBool)
                    }
                    parseTomlBool
                },
                {
                    fn computeCreate2Address_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <computeCreate2Address_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::computeCreate2Address_1)
                    }
                    computeCreate2Address_1
                },
                {
                    fn parseTomlIntArray(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlIntArrayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlIntArray)
                    }
                    parseTomlIntArray
                },
                {
                    fn assertNotEq_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_25)
                    }
                    assertNotEq_25
                },
                {
                    fn randomAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomAddress)
                    }
                    randomAddress
                },
                {
                    fn randomUint_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <randomUint_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::randomUint_2)
                    }
                    randomUint_2
                },
                {
                    fn parseTomlBytes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlBytes)
                    }
                    parseTomlBytes
                },
                {
                    fn projectRoot(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <projectRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::projectRoot)
                    }
                    projectRoot
                },
                {
                    fn assertGt_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGt_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGt_1)
                    }
                    assertGt_1
                },
                {
                    fn assertGt_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGt_2Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGt_2)
                    }
                    assertGt_2
                },
                {
                    fn keyExistsJson(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <keyExistsJsonCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::keyExistsJson)
                    }
                    keyExistsJson
                },
                {
                    fn getWallets(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getWalletsCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::getWallets)
                    }
                    getWallets
                },
                {
                    fn assertLtDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertLtDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertLtDecimal_3)
                    }
                    assertLtDecimal_3
                },
                {
                    fn assertGeDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGeDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGeDecimal_3)
                    }
                    assertGeDecimal_3
                },
                {
                    fn envBytes_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envBytes_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envBytes_1)
                    }
                    envBytes_1
                },
                {
                    fn replace(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <replaceCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::replace)
                    }
                    replace
                },
                {
                    fn assertEq_19(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_19Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_19)
                    }
                    assertEq_19
                },
                {
                    fn isFile(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <isFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::isFile)
                    }
                    isFile
                },
                {
                    fn setArbitraryStorage(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <setArbitraryStorageCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::setArbitraryStorage)
                    }
                    setArbitraryStorage
                },
                {
                    fn writeJson_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <writeJson_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::writeJson_1)
                    }
                    writeJson_1
                },
                {
                    fn assertEq_20(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_20)
                    }
                    assertEq_20
                },
                {
                    fn assertGe_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGe_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGe_3)
                    }
                    assertGe_3
                },
                {
                    fn sign_3(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <sign_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::sign_3)
                    }
                    sign_3
                },
                {
                    fn parseJsonType_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonType_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonType_1)
                    }
                    parseJsonType_1
                },
                {
                    fn assertEq_21(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_21Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_21)
                    }
                    assertEq_21
                },
                {
                    fn assertEq_22(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_22Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_22)
                    }
                    assertEq_22
                },
                {
                    fn broadcast_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <broadcast_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::broadcast_1)
                    }
                    broadcast_1
                },
                {
                    fn getFoundryVersion(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getFoundryVersionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getFoundryVersion)
                    }
                    getFoundryVersion
                },
                {
                    fn getArtifactPathByCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getArtifactPathByCodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getArtifactPathByCode)
                    }
                    getArtifactPathByCode
                },
                {
                    fn envOr_13(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envOr_13Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envOr_13)
                    }
                    envOr_13
                },
                {
                    fn getMappingSlotAt(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getMappingSlotAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getMappingSlotAt)
                    }
                    getMappingSlotAt
                },
                {
                    fn assertGtDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGtDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertGtDecimal_3)
                    }
                    assertGtDecimal_3
                },
                {
                    fn createWallet_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <createWallet_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::createWallet_2)
                    }
                    createWallet_2
                },
                {
                    fn assertNotEq_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_26)
                    }
                    assertNotEq_26
                },
                {
                    fn assertApproxEqRel_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRel_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqRel_2)
                    }
                    assertApproxEqRel_2
                },
                {
                    fn assertEq_23(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_23Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_23)
                    }
                    assertEq_23
                },
                {
                    fn breakpoint_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <breakpoint_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::breakpoint_0)
                    }
                    breakpoint_0
                },
                {
                    fn removeFile(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <removeFileCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::removeFile)
                    }
                    removeFile
                },
                {
                    fn serializeBytes_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeBytes_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeBytes_1)
                    }
                    serializeBytes_1
                },
                {
                    fn getBroadcasts_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBroadcasts_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBroadcasts_0)
                    }
                    getBroadcasts_0
                },
                {
                    fn assertEq_24(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_24Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_24)
                    }
                    assertEq_24
                },
                {
                    fn envUint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envUint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::envUint_1)
                    }
                    envUint_1
                },
                {
                    fn assertEq_25(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_25Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_25)
                    }
                    assertEq_25
                },
                {
                    fn tryFfi(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <tryFfiCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::tryFfi)
                    }
                    tryFfi
                },
                {
                    fn assertNotEq_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEq_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEq_27)
                    }
                    assertNotEq_27
                },
                {
                    fn getStateDiffJson(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getStateDiffJsonCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getStateDiffJson)
                    }
                    getStateDiffJson
                },
                {
                    fn assertNotEqDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertNotEqDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertNotEqDecimal_3)
                    }
                    assertNotEqDecimal_3
                },
                {
                    fn broadcast_2(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <broadcast_2Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::broadcast_2)
                    }
                    broadcast_2
                },
                {
                    fn assertApproxEqAbs_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqAbs_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqAbs_3)
                    }
                    assertApproxEqAbs_3
                },
                {
                    fn getBroadcasts_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <getBroadcasts_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::getBroadcasts_1)
                    }
                    getBroadcasts_1
                },
                {
                    fn breakpoint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <breakpoint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::breakpoint_1)
                    }
                    breakpoint_1
                },
                {
                    fn assertEq_26(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_26Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_26)
                    }
                    assertEq_26
                },
                {
                    fn envString_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <envString_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::envString_1)
                    }
                    envString_1
                },
                {
                    fn assertGt_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertGt_3Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::assertGt_3)
                    }
                    assertGt_3
                },
                {
                    fn rememberKeys_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <rememberKeys_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::rememberKeys_1)
                    }
                    rememberKeys_1
                },
                {
                    fn parseTomlType_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseTomlType_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseTomlType_1)
                    }
                    parseTomlType_1
                },
                {
                    fn parseUint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseUintCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::parseUint)
                    }
                    parseUint
                },
                {
                    fn sleep(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <sleepCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::sleep)
                    }
                    sleep
                },
                {
                    fn assertApproxEqRelDecimal_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRelDecimal_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(VmSafeCalls::assertApproxEqRelDecimal_3)
                    }
                    assertApproxEqRelDecimal_3
                },
                {
                    fn parseJsonBytes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <parseJsonBytesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::parseJsonBytes)
                    }
                    parseJsonBytes
                },
                {
                    fn assertEq_27(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertEq_27Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertEq_27)
                    }
                    assertEq_27
                },
                {
                    fn assertApproxEqRel_3(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <assertApproxEqRel_3Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::assertApproxEqRel_3)
                    }
                    assertApproxEqRel_3
                },
                {
                    fn serializeUint_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<VmSafeCalls> {
                        <serializeUint_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(VmSafeCalls::serializeUint_1)
                    }
                    serializeUint_1
                },
                {
                    fn addr(data: &[u8], validate: bool) -> alloy_sol_types::Result<VmSafeCalls> {
                        <addrCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(VmSafeCalls::addr)
                    }
                    addr
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::accesses(inner) => {
                    <accessesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::addr(inner) => {
                    <addrCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertApproxEqAbs_0(inner) => {
                    <assertApproxEqAbs_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbs_1(inner) => {
                    <assertApproxEqAbs_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbs_2(inner) => {
                    <assertApproxEqAbs_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbs_3(inner) => {
                    <assertApproxEqAbs_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbsDecimal_0(inner) => {
                    <assertApproxEqAbsDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbsDecimal_1(inner) => {
                    <assertApproxEqAbsDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbsDecimal_2(inner) => {
                    <assertApproxEqAbsDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqAbsDecimal_3(inner) => {
                    <assertApproxEqAbsDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRel_0(inner) => {
                    <assertApproxEqRel_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRel_1(inner) => {
                    <assertApproxEqRel_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRel_2(inner) => {
                    <assertApproxEqRel_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRel_3(inner) => {
                    <assertApproxEqRel_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRelDecimal_0(inner) => {
                    <assertApproxEqRelDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRelDecimal_1(inner) => {
                    <assertApproxEqRelDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRelDecimal_2(inner) => {
                    <assertApproxEqRelDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertApproxEqRelDecimal_3(inner) => {
                    <assertApproxEqRelDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_0(inner) => {
                    <assertEq_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_1(inner) => {
                    <assertEq_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_2(inner) => {
                    <assertEq_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_3(inner) => {
                    <assertEq_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_4(inner) => {
                    <assertEq_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_5(inner) => {
                    <assertEq_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_6(inner) => {
                    <assertEq_6Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_7(inner) => {
                    <assertEq_7Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_8(inner) => {
                    <assertEq_8Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_9(inner) => {
                    <assertEq_9Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertEq_10(inner) => {
                    <assertEq_10Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_11(inner) => {
                    <assertEq_11Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_12(inner) => {
                    <assertEq_12Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_13(inner) => {
                    <assertEq_13Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_14(inner) => {
                    <assertEq_14Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_15(inner) => {
                    <assertEq_15Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_16(inner) => {
                    <assertEq_16Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_17(inner) => {
                    <assertEq_17Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_18(inner) => {
                    <assertEq_18Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_19(inner) => {
                    <assertEq_19Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_20(inner) => {
                    <assertEq_20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_21(inner) => {
                    <assertEq_21Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_22(inner) => {
                    <assertEq_22Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_23(inner) => {
                    <assertEq_23Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_24(inner) => {
                    <assertEq_24Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_25(inner) => {
                    <assertEq_25Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_26(inner) => {
                    <assertEq_26Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEq_27(inner) => {
                    <assertEq_27Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEqDecimal_0(inner) => {
                    <assertEqDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEqDecimal_1(inner) => {
                    <assertEqDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEqDecimal_2(inner) => {
                    <assertEqDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertEqDecimal_3(inner) => {
                    <assertEqDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertFalse_0(inner) => {
                    <assertFalse_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertFalse_1(inner) => {
                    <assertFalse_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGe_0(inner) => {
                    <assertGe_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGe_1(inner) => {
                    <assertGe_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGe_2(inner) => {
                    <assertGe_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGe_3(inner) => {
                    <assertGe_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGeDecimal_0(inner) => {
                    <assertGeDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGeDecimal_1(inner) => {
                    <assertGeDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGeDecimal_2(inner) => {
                    <assertGeDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGeDecimal_3(inner) => {
                    <assertGeDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGt_0(inner) => {
                    <assertGt_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGt_1(inner) => {
                    <assertGt_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGt_2(inner) => {
                    <assertGt_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGt_3(inner) => {
                    <assertGt_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertGtDecimal_0(inner) => {
                    <assertGtDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGtDecimal_1(inner) => {
                    <assertGtDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGtDecimal_2(inner) => {
                    <assertGtDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertGtDecimal_3(inner) => {
                    <assertGtDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLe_0(inner) => {
                    <assertLe_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLe_1(inner) => {
                    <assertLe_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLe_2(inner) => {
                    <assertLe_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLe_3(inner) => {
                    <assertLe_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLeDecimal_0(inner) => {
                    <assertLeDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLeDecimal_1(inner) => {
                    <assertLeDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLeDecimal_2(inner) => {
                    <assertLeDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLeDecimal_3(inner) => {
                    <assertLeDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLt_0(inner) => {
                    <assertLt_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLt_1(inner) => {
                    <assertLt_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLt_2(inner) => {
                    <assertLt_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLt_3(inner) => {
                    <assertLt_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assertLtDecimal_0(inner) => {
                    <assertLtDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLtDecimal_1(inner) => {
                    <assertLtDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLtDecimal_2(inner) => {
                    <assertLtDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertLtDecimal_3(inner) => {
                    <assertLtDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_0(inner) => {
                    <assertNotEq_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_1(inner) => {
                    <assertNotEq_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_2(inner) => {
                    <assertNotEq_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_3(inner) => {
                    <assertNotEq_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_4(inner) => {
                    <assertNotEq_4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_5(inner) => {
                    <assertNotEq_5Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_6(inner) => {
                    <assertNotEq_6Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_7(inner) => {
                    <assertNotEq_7Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_8(inner) => {
                    <assertNotEq_8Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_9(inner) => {
                    <assertNotEq_9Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_10(inner) => {
                    <assertNotEq_10Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_11(inner) => {
                    <assertNotEq_11Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_12(inner) => {
                    <assertNotEq_12Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_13(inner) => {
                    <assertNotEq_13Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_14(inner) => {
                    <assertNotEq_14Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_15(inner) => {
                    <assertNotEq_15Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_16(inner) => {
                    <assertNotEq_16Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_17(inner) => {
                    <assertNotEq_17Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_18(inner) => {
                    <assertNotEq_18Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_19(inner) => {
                    <assertNotEq_19Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_20(inner) => {
                    <assertNotEq_20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_21(inner) => {
                    <assertNotEq_21Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_22(inner) => {
                    <assertNotEq_22Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_23(inner) => {
                    <assertNotEq_23Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_24(inner) => {
                    <assertNotEq_24Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_25(inner) => {
                    <assertNotEq_25Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_26(inner) => {
                    <assertNotEq_26Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEq_27(inner) => {
                    <assertNotEq_27Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEqDecimal_0(inner) => {
                    <assertNotEqDecimal_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEqDecimal_1(inner) => {
                    <assertNotEqDecimal_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEqDecimal_2(inner) => {
                    <assertNotEqDecimal_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertNotEqDecimal_3(inner) => {
                    <assertNotEqDecimal_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertTrue_0(inner) => {
                    <assertTrue_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assertTrue_1(inner) => {
                    <assertTrue_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::assume(inner) => {
                    <assumeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::assumeNoRevert(inner) => {
                    <assumeNoRevertCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::attachDelegation(inner) => {
                    <attachDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::breakpoint_0(inner) => {
                    <breakpoint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::breakpoint_1(inner) => {
                    <breakpoint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::broadcast_0(inner) => {
                    <broadcast_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::broadcast_1(inner) => {
                    <broadcast_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::broadcast_2(inner) => {
                    <broadcast_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::broadcastRawTransaction(inner) => {
                    <broadcastRawTransactionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeFile(inner) => {
                    <closeFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::computeCreate2Address_0(inner) => {
                    <computeCreate2Address_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeCreate2Address_1(inner) => {
                    <computeCreate2Address_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::computeCreateAddress(inner) => {
                    <computeCreateAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::contains(inner) => {
                    <containsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::copyFile(inner) => {
                    <copyFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::copyStorage(inner) => {
                    <copyStorageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createDir(inner) => {
                    <createDirCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::createWallet_0(inner) => {
                    <createWallet_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createWallet_1(inner) => {
                    <createWallet_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createWallet_2(inner) => {
                    <createWallet_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deployCode_0(inner) => {
                    <deployCode_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deployCode_1(inner) => {
                    <deployCode_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deriveKey_0(inner) => {
                    <deriveKey_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deriveKey_1(inner) => {
                    <deriveKey_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deriveKey_2(inner) => {
                    <deriveKey_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deriveKey_3(inner) => {
                    <deriveKey_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ensNamehash(inner) => {
                    <ensNamehashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envAddress_0(inner) => {
                    <envAddress_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envAddress_1(inner) => {
                    <envAddress_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envBool_0(inner) => {
                    <envBool_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envBool_1(inner) => {
                    <envBool_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envBytes_0(inner) => {
                    <envBytes_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envBytes_1(inner) => {
                    <envBytes_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envBytes32_0(inner) => {
                    <envBytes32_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envBytes32_1(inner) => {
                    <envBytes32_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envExists(inner) => {
                    <envExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envInt_0(inner) => {
                    <envInt_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envInt_1(inner) => {
                    <envInt_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_0(inner) => {
                    <envOr_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_1(inner) => {
                    <envOr_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_2(inner) => {
                    <envOr_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_3(inner) => {
                    <envOr_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_4(inner) => {
                    <envOr_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_5(inner) => {
                    <envOr_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_6(inner) => {
                    <envOr_6Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_7(inner) => {
                    <envOr_7Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_8(inner) => {
                    <envOr_8Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_9(inner) => {
                    <envOr_9Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_10(inner) => {
                    <envOr_10Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_11(inner) => {
                    <envOr_11Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_12(inner) => {
                    <envOr_12Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envOr_13(inner) => {
                    <envOr_13Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envString_0(inner) => {
                    <envString_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envString_1(inner) => {
                    <envString_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::envUint_0(inner) => {
                    <envUint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::envUint_1(inner) => {
                    <envUint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eth_getLogs(inner) => {
                    <eth_getLogsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exists(inner) => {
                    <existsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ffi(inner) => {
                    <ffiCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fsMetadata(inner) => {
                    <fsMetadataCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getArtifactPathByCode(inner) => {
                    <getArtifactPathByCodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getArtifactPathByDeployedCode(inner) => {
                    <getArtifactPathByDeployedCodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlobBaseFee(inner) => {
                    <getBlobBaseFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockNumber(inner) => {
                    <getBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBroadcast(inner) => {
                    <getBroadcastCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBroadcasts_0(inner) => {
                    <getBroadcasts_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBroadcasts_1(inner) => {
                    <getBroadcasts_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCode(inner) => {
                    <getCodeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getDeployedCode(inner) => {
                    <getDeployedCodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDeployment_0(inner) => {
                    <getDeployment_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDeployment_1(inner) => {
                    <getDeployment_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDeployments(inner) => {
                    <getDeploymentsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getFoundryVersion(inner) => {
                    <getFoundryVersionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getLabel(inner) => {
                    <getLabelCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getMappingKeyAndParentOf(inner) => {
                    <getMappingKeyAndParentOfCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getMappingLength(inner) => {
                    <getMappingLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getMappingSlotAt(inner) => {
                    <getMappingSlotAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getNonce_0(inner) => {
                    <getNonce_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getNonce_1(inner) => {
                    <getNonce_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getRecordedLogs(inner) => {
                    <getRecordedLogsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getStateDiff(inner) => {
                    <getStateDiffCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getStateDiffJson(inner) => {
                    <getStateDiffJsonCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getWallets(inner) => {
                    <getWalletsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::indexOf(inner) => {
                    <indexOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isContext(inner) => {
                    <isContextCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isDir(inner) => {
                    <isDirCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isFile(inner) => {
                    <isFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::keyExists(inner) => {
                    <keyExistsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::keyExistsJson(inner) => {
                    <keyExistsJsonCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::keyExistsToml(inner) => {
                    <keyExistsTomlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::label(inner) => {
                    <labelCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::lastCallGas(inner) => {
                    <lastCallGasCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::load(inner) => {
                    <loadCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::parseAddress(inner) => {
                    <parseAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseBool(inner) => {
                    <parseBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::parseBytes(inner) => {
                    <parseBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::parseBytes32(inner) => {
                    <parseBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseInt(inner) => {
                    <parseIntCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::parseJson_0(inner) => {
                    <parseJson_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJson_1(inner) => {
                    <parseJson_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonAddress(inner) => {
                    <parseJsonAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonAddressArray(inner) => {
                    <parseJsonAddressArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBool(inner) => {
                    <parseJsonBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBoolArray(inner) => {
                    <parseJsonBoolArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBytes(inner) => {
                    <parseJsonBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBytes32(inner) => {
                    <parseJsonBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBytes32Array(inner) => {
                    <parseJsonBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonBytesArray(inner) => {
                    <parseJsonBytesArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonInt(inner) => {
                    <parseJsonIntCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonIntArray(inner) => {
                    <parseJsonIntArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonKeys(inner) => {
                    <parseJsonKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonString(inner) => {
                    <parseJsonStringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonStringArray(inner) => {
                    <parseJsonStringArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonType_0(inner) => {
                    <parseJsonType_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonType_1(inner) => {
                    <parseJsonType_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonTypeArray(inner) => {
                    <parseJsonTypeArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonUint(inner) => {
                    <parseJsonUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseJsonUintArray(inner) => {
                    <parseJsonUintArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseToml_0(inner) => {
                    <parseToml_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseToml_1(inner) => {
                    <parseToml_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlAddress(inner) => {
                    <parseTomlAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlAddressArray(inner) => {
                    <parseTomlAddressArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBool(inner) => {
                    <parseTomlBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBoolArray(inner) => {
                    <parseTomlBoolArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBytes(inner) => {
                    <parseTomlBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBytes32(inner) => {
                    <parseTomlBytes32Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBytes32Array(inner) => {
                    <parseTomlBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlBytesArray(inner) => {
                    <parseTomlBytesArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlInt(inner) => {
                    <parseTomlIntCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlIntArray(inner) => {
                    <parseTomlIntArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlKeys(inner) => {
                    <parseTomlKeysCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlString(inner) => {
                    <parseTomlStringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlStringArray(inner) => {
                    <parseTomlStringArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlType_0(inner) => {
                    <parseTomlType_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlType_1(inner) => {
                    <parseTomlType_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlTypeArray(inner) => {
                    <parseTomlTypeArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlUint(inner) => {
                    <parseTomlUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseTomlUintArray(inner) => {
                    <parseTomlUintArrayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::parseUint(inner) => {
                    <parseUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pauseGasMetering(inner) => {
                    <pauseGasMeteringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pauseTracing(inner) => {
                    <pauseTracingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::projectRoot(inner) => {
                    <projectRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::prompt(inner) => {
                    <promptCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::promptAddress(inner) => {
                    <promptAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::promptSecret(inner) => {
                    <promptSecretCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::promptSecretUint(inner) => {
                    <promptSecretUintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::promptUint(inner) => {
                    <promptUintCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::publicKeyP256(inner) => {
                    <publicKeyP256Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomAddress(inner) => {
                    <randomAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomBool(inner) => {
                    <randomBoolCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::randomBytes(inner) => {
                    <randomBytesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomBytes4(inner) => {
                    <randomBytes4Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomBytes8(inner) => {
                    <randomBytes8Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomInt_0(inner) => {
                    <randomInt_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomInt_1(inner) => {
                    <randomInt_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomUint_0(inner) => {
                    <randomUint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomUint_1(inner) => {
                    <randomUint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::randomUint_2(inner) => {
                    <randomUint_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readDir_0(inner) => {
                    <readDir_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readDir_1(inner) => {
                    <readDir_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readDir_2(inner) => {
                    <readDir_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readFile(inner) => {
                    <readFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readFileBinary(inner) => {
                    <readFileBinaryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::readLine(inner) => {
                    <readLineCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::readLink(inner) => {
                    <readLinkCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::record(inner) => {
                    <recordCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::recordLogs(inner) => {
                    <recordLogsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rememberKey(inner) => {
                    <rememberKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rememberKeys_0(inner) => {
                    <rememberKeys_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rememberKeys_1(inner) => {
                    <rememberKeys_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeDir(inner) => {
                    <removeDirCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::removeFile(inner) => {
                    <removeFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::replace(inner) => {
                    <replaceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::resetGasMetering(inner) => {
                    <resetGasMeteringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeGasMetering(inner) => {
                    <resumeGasMeteringCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::resumeTracing(inner) => {
                    <resumeTracingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rpc_0(inner) => {
                    <rpc_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rpc_1(inner) => {
                    <rpc_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rpcUrl(inner) => {
                    <rpcUrlCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rpcUrlStructs(inner) => {
                    <rpcUrlStructsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rpcUrls(inner) => {
                    <rpcUrlsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::serializeAddress_0(inner) => {
                    <serializeAddress_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeAddress_1(inner) => {
                    <serializeAddress_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBool_0(inner) => {
                    <serializeBool_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBool_1(inner) => {
                    <serializeBool_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBytes_0(inner) => {
                    <serializeBytes_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBytes_1(inner) => {
                    <serializeBytes_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBytes32_0(inner) => {
                    <serializeBytes32_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeBytes32_1(inner) => {
                    <serializeBytes32_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeInt_0(inner) => {
                    <serializeInt_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeInt_1(inner) => {
                    <serializeInt_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeJson(inner) => {
                    <serializeJsonCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeJsonType_0(inner) => {
                    <serializeJsonType_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeJsonType_1(inner) => {
                    <serializeJsonType_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeString_0(inner) => {
                    <serializeString_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeString_1(inner) => {
                    <serializeString_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeUint_0(inner) => {
                    <serializeUint_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeUint_1(inner) => {
                    <serializeUint_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serializeUintToHex(inner) => {
                    <serializeUintToHexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setArbitraryStorage(inner) => {
                    <setArbitraryStorageCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setEnv(inner) => {
                    <setEnvCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sign_0(inner) => {
                    <sign_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sign_1(inner) => {
                    <sign_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sign_2(inner) => {
                    <sign_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sign_3(inner) => {
                    <sign_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::signAndAttachDelegation(inner) => {
                    <signAndAttachDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signCompact_0(inner) => {
                    <signCompact_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signCompact_1(inner) => {
                    <signCompact_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signCompact_2(inner) => {
                    <signCompact_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signCompact_3(inner) => {
                    <signCompact_3Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signDelegation(inner) => {
                    <signDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::signP256(inner) => {
                    <signP256Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::sleep(inner) => {
                    <sleepCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::split(inner) => {
                    <splitCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::startBroadcast_0(inner) => {
                    <startBroadcast_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startBroadcast_1(inner) => {
                    <startBroadcast_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startBroadcast_2(inner) => {
                    <startBroadcast_2Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startDebugTraceRecording(inner) => {
                    <startDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startMappingRecording(inner) => {
                    <startMappingRecordingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startStateDiffRecording(inner) => {
                    <startStateDiffRecordingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stopAndReturnDebugTraceRecording(inner) => {
                    <stopAndReturnDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stopAndReturnStateDiff(inner) => {
                    <stopAndReturnStateDiffCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stopBroadcast(inner) => {
                    <stopBroadcastCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::stopMappingRecording(inner) => {
                    <stopMappingRecordingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::toBase64_0(inner) => {
                    <toBase64_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toBase64_1(inner) => {
                    <toBase64_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toBase64URL_0(inner) => {
                    <toBase64URL_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::toBase64URL_1(inner) => {
                    <toBase64URL_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::toLowercase(inner) => {
                    <toLowercaseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::toString_0(inner) => {
                    <toString_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toString_1(inner) => {
                    <toString_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toString_2(inner) => {
                    <toString_2Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toString_3(inner) => {
                    <toString_3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toString_4(inner) => {
                    <toString_4Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toString_5(inner) => {
                    <toString_5Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::toUppercase(inner) => {
                    <toUppercaseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::trim(inner) => {
                    <trimCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tryFfi(inner) => {
                    <tryFfiCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unixTime(inner) => {
                    <unixTimeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::writeFile(inner) => {
                    <writeFileCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::writeFileBinary(inner) => {
                    <writeFileBinaryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::writeJson_0(inner) => {
                    <writeJson_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::writeJson_1(inner) => {
                    <writeJson_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::writeLine(inner) => {
                    <writeLineCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::writeToml_0(inner) => {
                    <writeToml_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::writeToml_1(inner) => {
                    <writeToml_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::accesses(inner) => {
                    <accessesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addr(inner) => {
                    <addrCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::assertApproxEqAbs_0(inner) => {
                    <assertApproxEqAbs_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbs_1(inner) => {
                    <assertApproxEqAbs_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbs_2(inner) => {
                    <assertApproxEqAbs_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbs_3(inner) => {
                    <assertApproxEqAbs_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbsDecimal_0(inner) => {
                    <assertApproxEqAbsDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbsDecimal_1(inner) => {
                    <assertApproxEqAbsDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbsDecimal_2(inner) => {
                    <assertApproxEqAbsDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqAbsDecimal_3(inner) => {
                    <assertApproxEqAbsDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRel_0(inner) => {
                    <assertApproxEqRel_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRel_1(inner) => {
                    <assertApproxEqRel_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRel_2(inner) => {
                    <assertApproxEqRel_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRel_3(inner) => {
                    <assertApproxEqRel_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRelDecimal_0(inner) => {
                    <assertApproxEqRelDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRelDecimal_1(inner) => {
                    <assertApproxEqRelDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRelDecimal_2(inner) => {
                    <assertApproxEqRelDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertApproxEqRelDecimal_3(inner) => {
                    <assertApproxEqRelDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_0(inner) => {
                    <assertEq_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_1(inner) => {
                    <assertEq_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_2(inner) => {
                    <assertEq_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_3(inner) => {
                    <assertEq_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_4(inner) => {
                    <assertEq_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_5(inner) => {
                    <assertEq_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_6(inner) => {
                    <assertEq_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_7(inner) => {
                    <assertEq_7Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_8(inner) => {
                    <assertEq_8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_9(inner) => {
                    <assertEq_9Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_10(inner) => {
                    <assertEq_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_11(inner) => {
                    <assertEq_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_12(inner) => {
                    <assertEq_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_13(inner) => {
                    <assertEq_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_14(inner) => {
                    <assertEq_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_15(inner) => {
                    <assertEq_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_16(inner) => {
                    <assertEq_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_17(inner) => {
                    <assertEq_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_18(inner) => {
                    <assertEq_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_19(inner) => {
                    <assertEq_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_20(inner) => {
                    <assertEq_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_21(inner) => {
                    <assertEq_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_22(inner) => {
                    <assertEq_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_23(inner) => {
                    <assertEq_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_24(inner) => {
                    <assertEq_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_25(inner) => {
                    <assertEq_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_26(inner) => {
                    <assertEq_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEq_27(inner) => {
                    <assertEq_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEqDecimal_0(inner) => {
                    <assertEqDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEqDecimal_1(inner) => {
                    <assertEqDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEqDecimal_2(inner) => {
                    <assertEqDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertEqDecimal_3(inner) => {
                    <assertEqDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertFalse_0(inner) => {
                    <assertFalse_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertFalse_1(inner) => {
                    <assertFalse_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGe_0(inner) => {
                    <assertGe_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGe_1(inner) => {
                    <assertGe_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGe_2(inner) => {
                    <assertGe_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGe_3(inner) => {
                    <assertGe_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGeDecimal_0(inner) => {
                    <assertGeDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGeDecimal_1(inner) => {
                    <assertGeDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGeDecimal_2(inner) => {
                    <assertGeDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGeDecimal_3(inner) => {
                    <assertGeDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGt_0(inner) => {
                    <assertGt_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGt_1(inner) => {
                    <assertGt_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGt_2(inner) => {
                    <assertGt_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGt_3(inner) => {
                    <assertGt_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGtDecimal_0(inner) => {
                    <assertGtDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGtDecimal_1(inner) => {
                    <assertGtDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGtDecimal_2(inner) => {
                    <assertGtDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertGtDecimal_3(inner) => {
                    <assertGtDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLe_0(inner) => {
                    <assertLe_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLe_1(inner) => {
                    <assertLe_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLe_2(inner) => {
                    <assertLe_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLe_3(inner) => {
                    <assertLe_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLeDecimal_0(inner) => {
                    <assertLeDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLeDecimal_1(inner) => {
                    <assertLeDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLeDecimal_2(inner) => {
                    <assertLeDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLeDecimal_3(inner) => {
                    <assertLeDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLt_0(inner) => {
                    <assertLt_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLt_1(inner) => {
                    <assertLt_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLt_2(inner) => {
                    <assertLt_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLt_3(inner) => {
                    <assertLt_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLtDecimal_0(inner) => {
                    <assertLtDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLtDecimal_1(inner) => {
                    <assertLtDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLtDecimal_2(inner) => {
                    <assertLtDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertLtDecimal_3(inner) => {
                    <assertLtDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_0(inner) => {
                    <assertNotEq_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_1(inner) => {
                    <assertNotEq_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_2(inner) => {
                    <assertNotEq_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_3(inner) => {
                    <assertNotEq_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_4(inner) => {
                    <assertNotEq_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_5(inner) => {
                    <assertNotEq_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_6(inner) => {
                    <assertNotEq_6Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_7(inner) => {
                    <assertNotEq_7Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_8(inner) => {
                    <assertNotEq_8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_9(inner) => {
                    <assertNotEq_9Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_10(inner) => {
                    <assertNotEq_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_11(inner) => {
                    <assertNotEq_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_12(inner) => {
                    <assertNotEq_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_13(inner) => {
                    <assertNotEq_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_14(inner) => {
                    <assertNotEq_14Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_15(inner) => {
                    <assertNotEq_15Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_16(inner) => {
                    <assertNotEq_16Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_17(inner) => {
                    <assertNotEq_17Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_18(inner) => {
                    <assertNotEq_18Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_19(inner) => {
                    <assertNotEq_19Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_20(inner) => {
                    <assertNotEq_20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_21(inner) => {
                    <assertNotEq_21Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_22(inner) => {
                    <assertNotEq_22Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_23(inner) => {
                    <assertNotEq_23Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_24(inner) => {
                    <assertNotEq_24Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_25(inner) => {
                    <assertNotEq_25Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_26(inner) => {
                    <assertNotEq_26Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEq_27(inner) => {
                    <assertNotEq_27Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEqDecimal_0(inner) => {
                    <assertNotEqDecimal_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEqDecimal_1(inner) => {
                    <assertNotEqDecimal_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEqDecimal_2(inner) => {
                    <assertNotEqDecimal_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertNotEqDecimal_3(inner) => {
                    <assertNotEqDecimal_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertTrue_0(inner) => {
                    <assertTrue_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assertTrue_1(inner) => {
                    <assertTrue_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::assume(inner) => {
                    <assumeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::assumeNoRevert(inner) => {
                    <assumeNoRevertCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::attachDelegation(inner) => {
                    <attachDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::breakpoint_0(inner) => {
                    <breakpoint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::breakpoint_1(inner) => {
                    <breakpoint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::broadcast_0(inner) => {
                    <broadcast_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::broadcast_1(inner) => {
                    <broadcast_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::broadcast_2(inner) => {
                    <broadcast_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::broadcastRawTransaction(inner) => {
                    <broadcastRawTransactionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeFile(inner) => {
                    <closeFileCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeCreate2Address_0(inner) => {
                    <computeCreate2Address_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeCreate2Address_1(inner) => {
                    <computeCreate2Address_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::computeCreateAddress(inner) => {
                    <computeCreateAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::contains(inner) => {
                    <containsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::copyFile(inner) => {
                    <copyFileCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::copyStorage(inner) => {
                    <copyStorageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createDir(inner) => {
                    <createDirCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createWallet_0(inner) => {
                    <createWallet_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createWallet_1(inner) => {
                    <createWallet_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createWallet_2(inner) => {
                    <createWallet_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deployCode_0(inner) => {
                    <deployCode_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deployCode_1(inner) => {
                    <deployCode_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deriveKey_0(inner) => {
                    <deriveKey_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deriveKey_1(inner) => {
                    <deriveKey_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deriveKey_2(inner) => {
                    <deriveKey_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deriveKey_3(inner) => {
                    <deriveKey_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ensNamehash(inner) => {
                    <ensNamehashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envAddress_0(inner) => {
                    <envAddress_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envAddress_1(inner) => {
                    <envAddress_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBool_0(inner) => {
                    <envBool_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBool_1(inner) => {
                    <envBool_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBytes_0(inner) => {
                    <envBytes_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBytes_1(inner) => {
                    <envBytes_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBytes32_0(inner) => {
                    <envBytes32_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envBytes32_1(inner) => {
                    <envBytes32_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envExists(inner) => {
                    <envExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envInt_0(inner) => {
                    <envInt_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envInt_1(inner) => {
                    <envInt_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envOr_0(inner) => {
                    <envOr_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_1(inner) => {
                    <envOr_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_2(inner) => {
                    <envOr_2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_3(inner) => {
                    <envOr_3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_4(inner) => {
                    <envOr_4Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_5(inner) => {
                    <envOr_5Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_6(inner) => {
                    <envOr_6Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_7(inner) => {
                    <envOr_7Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_8(inner) => {
                    <envOr_8Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_9(inner) => {
                    <envOr_9Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::envOr_10(inner) => {
                    <envOr_10Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envOr_11(inner) => {
                    <envOr_11Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envOr_12(inner) => {
                    <envOr_12Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envOr_13(inner) => {
                    <envOr_13Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envString_0(inner) => {
                    <envString_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envString_1(inner) => {
                    <envString_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envUint_0(inner) => {
                    <envUint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::envUint_1(inner) => {
                    <envUint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eth_getLogs(inner) => {
                    <eth_getLogsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exists(inner) => {
                    <existsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::ffi(inner) => {
                    <ffiCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::fsMetadata(inner) => {
                    <fsMetadataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getArtifactPathByCode(inner) => {
                    <getArtifactPathByCodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getArtifactPathByDeployedCode(inner) => {
                    <getArtifactPathByDeployedCodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlobBaseFee(inner) => {
                    <getBlobBaseFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockNumber(inner) => {
                    <getBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBroadcast(inner) => {
                    <getBroadcastCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBroadcasts_0(inner) => {
                    <getBroadcasts_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBroadcasts_1(inner) => {
                    <getBroadcasts_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCode(inner) => {
                    <getCodeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getDeployedCode(inner) => {
                    <getDeployedCodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDeployment_0(inner) => {
                    <getDeployment_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDeployment_1(inner) => {
                    <getDeployment_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDeployments(inner) => {
                    <getDeploymentsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getFoundryVersion(inner) => {
                    <getFoundryVersionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLabel(inner) => {
                    <getLabelCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getMappingKeyAndParentOf(inner) => {
                    <getMappingKeyAndParentOfCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getMappingLength(inner) => {
                    <getMappingLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getMappingSlotAt(inner) => {
                    <getMappingSlotAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNonce_0(inner) => {
                    <getNonce_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getNonce_1(inner) => {
                    <getNonce_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRecordedLogs(inner) => {
                    <getRecordedLogsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getStateDiff(inner) => {
                    <getStateDiffCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getStateDiffJson(inner) => {
                    <getStateDiffJsonCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getWallets(inner) => {
                    <getWalletsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::indexOf(inner) => {
                    <indexOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isContext(inner) => {
                    <isContextCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isDir(inner) => {
                    <isDirCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isFile(inner) => {
                    <isFileCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::keyExists(inner) => {
                    <keyExistsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::keyExistsJson(inner) => {
                    <keyExistsJsonCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::keyExistsToml(inner) => {
                    <keyExistsTomlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::label(inner) => {
                    <labelCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::lastCallGas(inner) => {
                    <lastCallGasCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::load(inner) => {
                    <loadCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::parseAddress(inner) => {
                    <parseAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseBool(inner) => {
                    <parseBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseBytes(inner) => {
                    <parseBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseBytes32(inner) => {
                    <parseBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseInt(inner) => {
                    <parseIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJson_0(inner) => {
                    <parseJson_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJson_1(inner) => {
                    <parseJson_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonAddress(inner) => {
                    <parseJsonAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonAddressArray(inner) => {
                    <parseJsonAddressArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBool(inner) => {
                    <parseJsonBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBoolArray(inner) => {
                    <parseJsonBoolArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBytes(inner) => {
                    <parseJsonBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBytes32(inner) => {
                    <parseJsonBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBytes32Array(inner) => {
                    <parseJsonBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonBytesArray(inner) => {
                    <parseJsonBytesArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonInt(inner) => {
                    <parseJsonIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonIntArray(inner) => {
                    <parseJsonIntArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonKeys(inner) => {
                    <parseJsonKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonString(inner) => {
                    <parseJsonStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonStringArray(inner) => {
                    <parseJsonStringArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonType_0(inner) => {
                    <parseJsonType_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonType_1(inner) => {
                    <parseJsonType_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonTypeArray(inner) => {
                    <parseJsonTypeArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonUint(inner) => {
                    <parseJsonUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseJsonUintArray(inner) => {
                    <parseJsonUintArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseToml_0(inner) => {
                    <parseToml_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseToml_1(inner) => {
                    <parseToml_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlAddress(inner) => {
                    <parseTomlAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlAddressArray(inner) => {
                    <parseTomlAddressArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBool(inner) => {
                    <parseTomlBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBoolArray(inner) => {
                    <parseTomlBoolArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBytes(inner) => {
                    <parseTomlBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBytes32(inner) => {
                    <parseTomlBytes32Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBytes32Array(inner) => {
                    <parseTomlBytes32ArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlBytesArray(inner) => {
                    <parseTomlBytesArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlInt(inner) => {
                    <parseTomlIntCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlIntArray(inner) => {
                    <parseTomlIntArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlKeys(inner) => {
                    <parseTomlKeysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlString(inner) => {
                    <parseTomlStringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlStringArray(inner) => {
                    <parseTomlStringArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlType_0(inner) => {
                    <parseTomlType_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlType_1(inner) => {
                    <parseTomlType_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlTypeArray(inner) => {
                    <parseTomlTypeArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlUint(inner) => {
                    <parseTomlUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseTomlUintArray(inner) => {
                    <parseTomlUintArrayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::parseUint(inner) => {
                    <parseUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pauseGasMetering(inner) => {
                    <pauseGasMeteringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pauseTracing(inner) => {
                    <pauseTracingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::projectRoot(inner) => {
                    <projectRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::prompt(inner) => {
                    <promptCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::promptAddress(inner) => {
                    <promptAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::promptSecret(inner) => {
                    <promptSecretCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::promptSecretUint(inner) => {
                    <promptSecretUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::promptUint(inner) => {
                    <promptUintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::publicKeyP256(inner) => {
                    <publicKeyP256Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomAddress(inner) => {
                    <randomAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomBool(inner) => {
                    <randomBoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomBytes(inner) => {
                    <randomBytesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomBytes4(inner) => {
                    <randomBytes4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomBytes8(inner) => {
                    <randomBytes8Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomInt_0(inner) => {
                    <randomInt_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomInt_1(inner) => {
                    <randomInt_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomUint_0(inner) => {
                    <randomUint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomUint_1(inner) => {
                    <randomUint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::randomUint_2(inner) => {
                    <randomUint_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readDir_0(inner) => {
                    <readDir_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readDir_1(inner) => {
                    <readDir_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readDir_2(inner) => {
                    <readDir_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readFile(inner) => {
                    <readFileCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readFileBinary(inner) => {
                    <readFileBinaryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readLine(inner) => {
                    <readLineCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::readLink(inner) => {
                    <readLinkCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::record(inner) => {
                    <recordCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::recordLogs(inner) => {
                    <recordLogsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rememberKey(inner) => {
                    <rememberKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rememberKeys_0(inner) => {
                    <rememberKeys_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rememberKeys_1(inner) => {
                    <rememberKeys_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeDir(inner) => {
                    <removeDirCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeFile(inner) => {
                    <removeFileCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::replace(inner) => {
                    <replaceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::resetGasMetering(inner) => {
                    <resetGasMeteringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeGasMetering(inner) => {
                    <resumeGasMeteringCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::resumeTracing(inner) => {
                    <resumeTracingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rpc_0(inner) => {
                    <rpc_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::rpc_1(inner) => {
                    <rpc_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::rpcUrl(inner) => {
                    <rpcUrlCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::rpcUrlStructs(inner) => {
                    <rpcUrlStructsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rpcUrls(inner) => {
                    <rpcUrlsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::serializeAddress_0(inner) => {
                    <serializeAddress_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeAddress_1(inner) => {
                    <serializeAddress_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBool_0(inner) => {
                    <serializeBool_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBool_1(inner) => {
                    <serializeBool_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBytes_0(inner) => {
                    <serializeBytes_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBytes_1(inner) => {
                    <serializeBytes_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBytes32_0(inner) => {
                    <serializeBytes32_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeBytes32_1(inner) => {
                    <serializeBytes32_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeInt_0(inner) => {
                    <serializeInt_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeInt_1(inner) => {
                    <serializeInt_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeJson(inner) => {
                    <serializeJsonCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeJsonType_0(inner) => {
                    <serializeJsonType_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeJsonType_1(inner) => {
                    <serializeJsonType_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeString_0(inner) => {
                    <serializeString_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeString_1(inner) => {
                    <serializeString_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeUint_0(inner) => {
                    <serializeUint_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeUint_1(inner) => {
                    <serializeUint_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serializeUintToHex(inner) => {
                    <serializeUintToHexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setArbitraryStorage(inner) => {
                    <setArbitraryStorageCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setEnv(inner) => {
                    <setEnvCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sign_0(inner) => {
                    <sign_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sign_1(inner) => {
                    <sign_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sign_2(inner) => {
                    <sign_2Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::sign_3(inner) => {
                    <sign_3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::signAndAttachDelegation(inner) => {
                    <signAndAttachDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signCompact_0(inner) => {
                    <signCompact_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signCompact_1(inner) => {
                    <signCompact_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signCompact_2(inner) => {
                    <signCompact_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signCompact_3(inner) => {
                    <signCompact_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signDelegation(inner) => {
                    <signDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::signP256(inner) => {
                    <signP256Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::sleep(inner) => {
                    <sleepCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::split(inner) => {
                    <splitCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::startBroadcast_0(inner) => {
                    <startBroadcast_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startBroadcast_1(inner) => {
                    <startBroadcast_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startBroadcast_2(inner) => {
                    <startBroadcast_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startDebugTraceRecording(inner) => {
                    <startDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startMappingRecording(inner) => {
                    <startMappingRecordingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startStateDiffRecording(inner) => {
                    <startStateDiffRecordingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stopAndReturnDebugTraceRecording(inner) => {
                    <stopAndReturnDebugTraceRecordingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stopAndReturnStateDiff(inner) => {
                    <stopAndReturnStateDiffCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stopBroadcast(inner) => {
                    <stopBroadcastCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::stopMappingRecording(inner) => {
                    <stopMappingRecordingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toBase64_0(inner) => {
                    <toBase64_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toBase64_1(inner) => {
                    <toBase64_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toBase64URL_0(inner) => {
                    <toBase64URL_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toBase64URL_1(inner) => {
                    <toBase64URL_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toLowercase(inner) => {
                    <toLowercaseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_0(inner) => {
                    <toString_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_1(inner) => {
                    <toString_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_2(inner) => {
                    <toString_2Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_3(inner) => {
                    <toString_3Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_4(inner) => {
                    <toString_4Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toString_5(inner) => {
                    <toString_5Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::toUppercase(inner) => {
                    <toUppercaseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::trim(inner) => {
                    <trimCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::tryFfi(inner) => {
                    <tryFfiCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::unixTime(inner) => {
                    <unixTimeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeFile(inner) => {
                    <writeFileCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeFileBinary(inner) => {
                    <writeFileBinaryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeJson_0(inner) => {
                    <writeJson_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeJson_1(inner) => {
                    <writeJson_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeLine(inner) => {
                    <writeLineCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeToml_0(inner) => {
                    <writeToml_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::writeToml_1(inner) => {
                    <writeToml_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`VmSafe`](self) contract instance.

    See the [wrapper's documentation](`VmSafeInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> VmSafeInstance<T, P, N> {
        VmSafeInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<VmSafeInstance<T, P, N>>> {
        VmSafeInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        VmSafeInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`VmSafe`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`VmSafe`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct VmSafeInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for VmSafeInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("VmSafeInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > VmSafeInstance<T, P, N>
    {
        /**Creates a new wrapper around an on-chain [`VmSafe`](self) contract instance.

        See the [wrapper's documentation](`VmSafeInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self { address, provider, _network_transport: ::core::marker::PhantomData }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(provider: P) -> alloy_contract::Result<VmSafeInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> VmSafeInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> VmSafeInstance<T, P, N> {
            VmSafeInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > VmSafeInstance<T, P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`accesses`] function.
        pub fn accesses(
            &self,
            target: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, accessesCall, N> {
            self.call_builder(&accessesCall { target })
        }
        ///Creates a new call builder for the [`addr`] function.
        pub fn addr(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, addrCall, N> {
            self.call_builder(&addrCall { privateKey })
        }
        ///Creates a new call builder for the [`assertApproxEqAbs_0`] function.
        pub fn assertApproxEqAbs_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbs_0Call, N> {
            self.call_builder(&assertApproxEqAbs_0Call { left, right, maxDelta })
        }
        ///Creates a new call builder for the [`assertApproxEqAbs_1`] function.
        pub fn assertApproxEqAbs_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbs_1Call, N> {
            self.call_builder(&assertApproxEqAbs_1Call { left, right, maxDelta })
        }
        ///Creates a new call builder for the [`assertApproxEqAbs_2`] function.
        pub fn assertApproxEqAbs_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbs_2Call, N> {
            self.call_builder(&assertApproxEqAbs_2Call { left, right, maxDelta, error })
        }
        ///Creates a new call builder for the [`assertApproxEqAbs_3`] function.
        pub fn assertApproxEqAbs_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbs_3Call, N> {
            self.call_builder(&assertApproxEqAbs_3Call { left, right, maxDelta, error })
        }
        ///Creates a new call builder for the [`assertApproxEqAbsDecimal_0`] function.
        pub fn assertApproxEqAbsDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbsDecimal_0Call, N> {
            self.call_builder(&assertApproxEqAbsDecimal_0Call { left, right, maxDelta, decimals })
        }
        ///Creates a new call builder for the [`assertApproxEqAbsDecimal_1`] function.
        pub fn assertApproxEqAbsDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbsDecimal_1Call, N> {
            self.call_builder(&assertApproxEqAbsDecimal_1Call { left, right, maxDelta, decimals })
        }
        ///Creates a new call builder for the [`assertApproxEqAbsDecimal_2`] function.
        pub fn assertApproxEqAbsDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbsDecimal_2Call, N> {
            self.call_builder(&assertApproxEqAbsDecimal_2Call {
                left,
                right,
                maxDelta,
                decimals,
                error,
            })
        }
        ///Creates a new call builder for the [`assertApproxEqAbsDecimal_3`] function.
        pub fn assertApproxEqAbsDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqAbsDecimal_3Call, N> {
            self.call_builder(&assertApproxEqAbsDecimal_3Call {
                left,
                right,
                maxDelta,
                decimals,
                error,
            })
        }
        ///Creates a new call builder for the [`assertApproxEqRel_0`] function.
        pub fn assertApproxEqRel_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRel_0Call, N> {
            self.call_builder(&assertApproxEqRel_0Call { left, right, maxPercentDelta, error })
        }
        ///Creates a new call builder for the [`assertApproxEqRel_1`] function.
        pub fn assertApproxEqRel_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRel_1Call, N> {
            self.call_builder(&assertApproxEqRel_1Call { left, right, maxPercentDelta })
        }
        ///Creates a new call builder for the [`assertApproxEqRel_2`] function.
        pub fn assertApproxEqRel_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRel_2Call, N> {
            self.call_builder(&assertApproxEqRel_2Call { left, right, maxPercentDelta, error })
        }
        ///Creates a new call builder for the [`assertApproxEqRel_3`] function.
        pub fn assertApproxEqRel_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRel_3Call, N> {
            self.call_builder(&assertApproxEqRel_3Call { left, right, maxPercentDelta })
        }
        ///Creates a new call builder for the [`assertApproxEqRelDecimal_0`] function.
        pub fn assertApproxEqRelDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRelDecimal_0Call, N> {
            self.call_builder(&assertApproxEqRelDecimal_0Call {
                left,
                right,
                maxPercentDelta,
                decimals,
            })
        }
        ///Creates a new call builder for the [`assertApproxEqRelDecimal_1`] function.
        pub fn assertApproxEqRelDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRelDecimal_1Call, N> {
            self.call_builder(&assertApproxEqRelDecimal_1Call {
                left,
                right,
                maxPercentDelta,
                decimals,
                error,
            })
        }
        ///Creates a new call builder for the [`assertApproxEqRelDecimal_2`] function.
        pub fn assertApproxEqRelDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRelDecimal_2Call, N> {
            self.call_builder(&assertApproxEqRelDecimal_2Call {
                left,
                right,
                maxPercentDelta,
                decimals,
            })
        }
        ///Creates a new call builder for the [`assertApproxEqRelDecimal_3`] function.
        pub fn assertApproxEqRelDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            maxPercentDelta: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertApproxEqRelDecimal_3Call, N> {
            self.call_builder(&assertApproxEqRelDecimal_3Call {
                left,
                right,
                maxPercentDelta,
                decimals,
                error,
            })
        }
        ///Creates a new call builder for the [`assertEq_0`] function.
        pub fn assertEq_0(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_0Call, N> {
            self.call_builder(&assertEq_0Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_1`] function.
        pub fn assertEq_1(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_1Call, N> {
            self.call_builder(&assertEq_1Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_2`] function.
        pub fn assertEq_2(
            &self,
            left: alloy::sol_types::private::Address,
            right: alloy::sol_types::private::Address,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_2Call, N> {
            self.call_builder(&assertEq_2Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_3`] function.
        pub fn assertEq_3(
            &self,
            left: alloy::sol_types::private::String,
            right: alloy::sol_types::private::String,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_3Call, N> {
            self.call_builder(&assertEq_3Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_4`] function.
        pub fn assertEq_4(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_4Call, N> {
            self.call_builder(&assertEq_4Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_5`] function.
        pub fn assertEq_5(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_5Call, N> {
            self.call_builder(&assertEq_5Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_6`] function.
        pub fn assertEq_6(
            &self,
            left: bool,
            right: bool,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_6Call, N> {
            self.call_builder(&assertEq_6Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_7`] function.
        pub fn assertEq_7(
            &self,
            left: alloy::sol_types::private::Address,
            right: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_7Call, N> {
            self.call_builder(&assertEq_7Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_8`] function.
        pub fn assertEq_8(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_8Call, N> {
            self.call_builder(&assertEq_8Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_9`] function.
        pub fn assertEq_9(
            &self,
            left: alloy::sol_types::private::Vec<bool>,
            right: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_9Call, N> {
            self.call_builder(&assertEq_9Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_10`] function.
        pub fn assertEq_10(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_10Call, N> {
            self.call_builder(&assertEq_10Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_11`] function.
        pub fn assertEq_11(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_11Call, N> {
            self.call_builder(&assertEq_11Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_12`] function.
        pub fn assertEq_12(
            &self,
            left: alloy::sol_types::private::FixedBytes<32>,
            right: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_12Call, N> {
            self.call_builder(&assertEq_12Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_13`] function.
        pub fn assertEq_13(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_13Call, N> {
            self.call_builder(&assertEq_13Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_14`] function.
        pub fn assertEq_14(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_14Call, N> {
            self.call_builder(&assertEq_14Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_15`] function.
        pub fn assertEq_15(
            &self,
            left: alloy::sol_types::private::Bytes,
            right: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_15Call, N> {
            self.call_builder(&assertEq_15Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_16`] function.
        pub fn assertEq_16(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_16Call, N> {
            self.call_builder(&assertEq_16Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_17`] function.
        pub fn assertEq_17(
            &self,
            left: alloy::sol_types::private::FixedBytes<32>,
            right: alloy::sol_types::private::FixedBytes<32>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_17Call, N> {
            self.call_builder(&assertEq_17Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_18`] function.
        pub fn assertEq_18(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_18Call, N> {
            self.call_builder(&assertEq_18Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_19`] function.
        pub fn assertEq_19(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_19Call, N> {
            self.call_builder(&assertEq_19Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_20`] function.
        pub fn assertEq_20(
            &self,
            left: alloy::sol_types::private::Bytes,
            right: alloy::sol_types::private::Bytes,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_20Call, N> {
            self.call_builder(&assertEq_20Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_21`] function.
        pub fn assertEq_21(
            &self,
            left: alloy::sol_types::private::Vec<bool>,
            right: alloy::sol_types::private::Vec<bool>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_21Call, N> {
            self.call_builder(&assertEq_21Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_22`] function.
        pub fn assertEq_22(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_22Call, N> {
            self.call_builder(&assertEq_22Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_23`] function.
        pub fn assertEq_23(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_23Call, N> {
            self.call_builder(&assertEq_23Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_24`] function.
        pub fn assertEq_24(
            &self,
            left: alloy::sol_types::private::String,
            right: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_24Call, N> {
            self.call_builder(&assertEq_24Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_25`] function.
        pub fn assertEq_25(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_25Call, N> {
            self.call_builder(&assertEq_25Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertEq_26`] function.
        pub fn assertEq_26(
            &self,
            left: bool,
            right: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_26Call, N> {
            self.call_builder(&assertEq_26Call { left, right })
        }
        ///Creates a new call builder for the [`assertEq_27`] function.
        pub fn assertEq_27(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEq_27Call, N> {
            self.call_builder(&assertEq_27Call { left, right })
        }
        ///Creates a new call builder for the [`assertEqDecimal_0`] function.
        pub fn assertEqDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEqDecimal_0Call, N> {
            self.call_builder(&assertEqDecimal_0Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertEqDecimal_1`] function.
        pub fn assertEqDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEqDecimal_1Call, N> {
            self.call_builder(&assertEqDecimal_1Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertEqDecimal_2`] function.
        pub fn assertEqDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEqDecimal_2Call, N> {
            self.call_builder(&assertEqDecimal_2Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertEqDecimal_3`] function.
        pub fn assertEqDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertEqDecimal_3Call, N> {
            self.call_builder(&assertEqDecimal_3Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertFalse_0`] function.
        pub fn assertFalse_0(
            &self,
            condition: bool,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertFalse_0Call, N> {
            self.call_builder(&assertFalse_0Call { condition, error })
        }
        ///Creates a new call builder for the [`assertFalse_1`] function.
        pub fn assertFalse_1(
            &self,
            condition: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertFalse_1Call, N> {
            self.call_builder(&assertFalse_1Call { condition })
        }
        ///Creates a new call builder for the [`assertGe_0`] function.
        pub fn assertGe_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGe_0Call, N> {
            self.call_builder(&assertGe_0Call { left, right })
        }
        ///Creates a new call builder for the [`assertGe_1`] function.
        pub fn assertGe_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGe_1Call, N> {
            self.call_builder(&assertGe_1Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertGe_2`] function.
        pub fn assertGe_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGe_2Call, N> {
            self.call_builder(&assertGe_2Call { left, right })
        }
        ///Creates a new call builder for the [`assertGe_3`] function.
        pub fn assertGe_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGe_3Call, N> {
            self.call_builder(&assertGe_3Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertGeDecimal_0`] function.
        pub fn assertGeDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGeDecimal_0Call, N> {
            self.call_builder(&assertGeDecimal_0Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertGeDecimal_1`] function.
        pub fn assertGeDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGeDecimal_1Call, N> {
            self.call_builder(&assertGeDecimal_1Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertGeDecimal_2`] function.
        pub fn assertGeDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGeDecimal_2Call, N> {
            self.call_builder(&assertGeDecimal_2Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertGeDecimal_3`] function.
        pub fn assertGeDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGeDecimal_3Call, N> {
            self.call_builder(&assertGeDecimal_3Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertGt_0`] function.
        pub fn assertGt_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGt_0Call, N> {
            self.call_builder(&assertGt_0Call { left, right })
        }
        ///Creates a new call builder for the [`assertGt_1`] function.
        pub fn assertGt_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGt_1Call, N> {
            self.call_builder(&assertGt_1Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertGt_2`] function.
        pub fn assertGt_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGt_2Call, N> {
            self.call_builder(&assertGt_2Call { left, right })
        }
        ///Creates a new call builder for the [`assertGt_3`] function.
        pub fn assertGt_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGt_3Call, N> {
            self.call_builder(&assertGt_3Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertGtDecimal_0`] function.
        pub fn assertGtDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGtDecimal_0Call, N> {
            self.call_builder(&assertGtDecimal_0Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertGtDecimal_1`] function.
        pub fn assertGtDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGtDecimal_1Call, N> {
            self.call_builder(&assertGtDecimal_1Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertGtDecimal_2`] function.
        pub fn assertGtDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGtDecimal_2Call, N> {
            self.call_builder(&assertGtDecimal_2Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertGtDecimal_3`] function.
        pub fn assertGtDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertGtDecimal_3Call, N> {
            self.call_builder(&assertGtDecimal_3Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertLe_0`] function.
        pub fn assertLe_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLe_0Call, N> {
            self.call_builder(&assertLe_0Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertLe_1`] function.
        pub fn assertLe_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLe_1Call, N> {
            self.call_builder(&assertLe_1Call { left, right })
        }
        ///Creates a new call builder for the [`assertLe_2`] function.
        pub fn assertLe_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLe_2Call, N> {
            self.call_builder(&assertLe_2Call { left, right })
        }
        ///Creates a new call builder for the [`assertLe_3`] function.
        pub fn assertLe_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLe_3Call, N> {
            self.call_builder(&assertLe_3Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertLeDecimal_0`] function.
        pub fn assertLeDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLeDecimal_0Call, N> {
            self.call_builder(&assertLeDecimal_0Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertLeDecimal_1`] function.
        pub fn assertLeDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLeDecimal_1Call, N> {
            self.call_builder(&assertLeDecimal_1Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertLeDecimal_2`] function.
        pub fn assertLeDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLeDecimal_2Call, N> {
            self.call_builder(&assertLeDecimal_2Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertLeDecimal_3`] function.
        pub fn assertLeDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLeDecimal_3Call, N> {
            self.call_builder(&assertLeDecimal_3Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertLt_0`] function.
        pub fn assertLt_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLt_0Call, N> {
            self.call_builder(&assertLt_0Call { left, right })
        }
        ///Creates a new call builder for the [`assertLt_1`] function.
        pub fn assertLt_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLt_1Call, N> {
            self.call_builder(&assertLt_1Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertLt_2`] function.
        pub fn assertLt_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLt_2Call, N> {
            self.call_builder(&assertLt_2Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertLt_3`] function.
        pub fn assertLt_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLt_3Call, N> {
            self.call_builder(&assertLt_3Call { left, right })
        }
        ///Creates a new call builder for the [`assertLtDecimal_0`] function.
        pub fn assertLtDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLtDecimal_0Call, N> {
            self.call_builder(&assertLtDecimal_0Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertLtDecimal_1`] function.
        pub fn assertLtDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLtDecimal_1Call, N> {
            self.call_builder(&assertLtDecimal_1Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertLtDecimal_2`] function.
        pub fn assertLtDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLtDecimal_2Call, N> {
            self.call_builder(&assertLtDecimal_2Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertLtDecimal_3`] function.
        pub fn assertLtDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertLtDecimal_3Call, N> {
            self.call_builder(&assertLtDecimal_3Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertNotEq_0`] function.
        pub fn assertNotEq_0(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_0Call, N> {
            self.call_builder(&assertNotEq_0Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_1`] function.
        pub fn assertNotEq_1(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_1Call, N> {
            self.call_builder(&assertNotEq_1Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_2`] function.
        pub fn assertNotEq_2(
            &self,
            left: bool,
            right: bool,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_2Call, N> {
            self.call_builder(&assertNotEq_2Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_3`] function.
        pub fn assertNotEq_3(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_3Call, N> {
            self.call_builder(&assertNotEq_3Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_4`] function.
        pub fn assertNotEq_4(
            &self,
            left: bool,
            right: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_4Call, N> {
            self.call_builder(&assertNotEq_4Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_5`] function.
        pub fn assertNotEq_5(
            &self,
            left: alloy::sol_types::private::Vec<bool>,
            right: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_5Call, N> {
            self.call_builder(&assertNotEq_5Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_6`] function.
        pub fn assertNotEq_6(
            &self,
            left: alloy::sol_types::private::Bytes,
            right: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_6Call, N> {
            self.call_builder(&assertNotEq_6Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_7`] function.
        pub fn assertNotEq_7(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_7Call, N> {
            self.call_builder(&assertNotEq_7Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_8`] function.
        pub fn assertNotEq_8(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_8Call, N> {
            self.call_builder(&assertNotEq_8Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_9`] function.
        pub fn assertNotEq_9(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_9Call, N> {
            self.call_builder(&assertNotEq_9Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_10`] function.
        pub fn assertNotEq_10(
            &self,
            left: alloy::sol_types::private::Vec<bool>,
            right: alloy::sol_types::private::Vec<bool>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_10Call, N> {
            self.call_builder(&assertNotEq_10Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_11`] function.
        pub fn assertNotEq_11(
            &self,
            left: alloy::sol_types::private::String,
            right: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_11Call, N> {
            self.call_builder(&assertNotEq_11Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_12`] function.
        pub fn assertNotEq_12(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_12Call, N> {
            self.call_builder(&assertNotEq_12Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_13`] function.
        pub fn assertNotEq_13(
            &self,
            left: alloy::sol_types::private::String,
            right: alloy::sol_types::private::String,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_13Call, N> {
            self.call_builder(&assertNotEq_13Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_14`] function.
        pub fn assertNotEq_14(
            &self,
            left: alloy::sol_types::private::Address,
            right: alloy::sol_types::private::Address,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_14Call, N> {
            self.call_builder(&assertNotEq_14Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_15`] function.
        pub fn assertNotEq_15(
            &self,
            left: alloy::sol_types::private::FixedBytes<32>,
            right: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_15Call, N> {
            self.call_builder(&assertNotEq_15Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_16`] function.
        pub fn assertNotEq_16(
            &self,
            left: alloy::sol_types::private::Bytes,
            right: alloy::sol_types::private::Bytes,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_16Call, N> {
            self.call_builder(&assertNotEq_16Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_17`] function.
        pub fn assertNotEq_17(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_17Call, N> {
            self.call_builder(&assertNotEq_17Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_18`] function.
        pub fn assertNotEq_18(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_18Call, N> {
            self.call_builder(&assertNotEq_18Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_19`] function.
        pub fn assertNotEq_19(
            &self,
            left: alloy::sol_types::private::Address,
            right: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_19Call, N> {
            self.call_builder(&assertNotEq_19Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_20`] function.
        pub fn assertNotEq_20(
            &self,
            left: alloy::sol_types::private::FixedBytes<32>,
            right: alloy::sol_types::private::FixedBytes<32>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_20Call, N> {
            self.call_builder(&assertNotEq_20Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_21`] function.
        pub fn assertNotEq_21(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_21Call, N> {
            self.call_builder(&assertNotEq_21Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_22`] function.
        pub fn assertNotEq_22(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_22Call, N> {
            self.call_builder(&assertNotEq_22Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_23`] function.
        pub fn assertNotEq_23(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_23Call, N> {
            self.call_builder(&assertNotEq_23Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_24`] function.
        pub fn assertNotEq_24(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_24Call, N> {
            self.call_builder(&assertNotEq_24Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_25`] function.
        pub fn assertNotEq_25(
            &self,
            left: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            right: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_25Call, N> {
            self.call_builder(&assertNotEq_25Call { left, right, error })
        }
        ///Creates a new call builder for the [`assertNotEq_26`] function.
        pub fn assertNotEq_26(
            &self,
            left: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            right: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_26Call, N> {
            self.call_builder(&assertNotEq_26Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEq_27`] function.
        pub fn assertNotEq_27(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEq_27Call, N> {
            self.call_builder(&assertNotEq_27Call { left, right })
        }
        ///Creates a new call builder for the [`assertNotEqDecimal_0`] function.
        pub fn assertNotEqDecimal_0(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEqDecimal_0Call, N> {
            self.call_builder(&assertNotEqDecimal_0Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertNotEqDecimal_1`] function.
        pub fn assertNotEqDecimal_1(
            &self,
            left: alloy::sol_types::private::primitives::aliases::I256,
            right: alloy::sol_types::private::primitives::aliases::I256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEqDecimal_1Call, N> {
            self.call_builder(&assertNotEqDecimal_1Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertNotEqDecimal_2`] function.
        pub fn assertNotEqDecimal_2(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEqDecimal_2Call, N> {
            self.call_builder(&assertNotEqDecimal_2Call { left, right, decimals })
        }
        ///Creates a new call builder for the [`assertNotEqDecimal_3`] function.
        pub fn assertNotEqDecimal_3(
            &self,
            left: alloy::sol_types::private::primitives::aliases::U256,
            right: alloy::sol_types::private::primitives::aliases::U256,
            decimals: alloy::sol_types::private::primitives::aliases::U256,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertNotEqDecimal_3Call, N> {
            self.call_builder(&assertNotEqDecimal_3Call { left, right, decimals, error })
        }
        ///Creates a new call builder for the [`assertTrue_0`] function.
        pub fn assertTrue_0(
            &self,
            condition: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertTrue_0Call, N> {
            self.call_builder(&assertTrue_0Call { condition })
        }
        ///Creates a new call builder for the [`assertTrue_1`] function.
        pub fn assertTrue_1(
            &self,
            condition: bool,
            error: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, assertTrue_1Call, N> {
            self.call_builder(&assertTrue_1Call { condition, error })
        }
        ///Creates a new call builder for the [`assume`] function.
        pub fn assume(
            &self,
            condition: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, assumeCall, N> {
            self.call_builder(&assumeCall { condition })
        }
        ///Creates a new call builder for the [`assumeNoRevert`] function.
        pub fn assumeNoRevert(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, assumeNoRevertCall, N> {
            self.call_builder(&assumeNoRevertCall {})
        }
        ///Creates a new call builder for the [`attachDelegation`] function.
        pub fn attachDelegation(
            &self,
            signedDelegation: <SignedDelegation as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, attachDelegationCall, N> {
            self.call_builder(&attachDelegationCall { signedDelegation })
        }
        ///Creates a new call builder for the [`breakpoint_0`] function.
        pub fn breakpoint_0(
            &self,
            char: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, breakpoint_0Call, N> {
            self.call_builder(&breakpoint_0Call { char })
        }
        ///Creates a new call builder for the [`breakpoint_1`] function.
        pub fn breakpoint_1(
            &self,
            char: alloy::sol_types::private::String,
            value: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, breakpoint_1Call, N> {
            self.call_builder(&breakpoint_1Call { char, value })
        }
        ///Creates a new call builder for the [`broadcast_0`] function.
        pub fn broadcast_0(&self) -> alloy_contract::SolCallBuilder<T, &P, broadcast_0Call, N> {
            self.call_builder(&broadcast_0Call {})
        }
        ///Creates a new call builder for the [`broadcast_1`] function.
        pub fn broadcast_1(
            &self,
            signer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, broadcast_1Call, N> {
            self.call_builder(&broadcast_1Call { signer })
        }
        ///Creates a new call builder for the [`broadcast_2`] function.
        pub fn broadcast_2(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, broadcast_2Call, N> {
            self.call_builder(&broadcast_2Call { privateKey })
        }
        ///Creates a new call builder for the [`broadcastRawTransaction`] function.
        pub fn broadcastRawTransaction(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, broadcastRawTransactionCall, N> {
            self.call_builder(&broadcastRawTransactionCall { data })
        }
        ///Creates a new call builder for the [`closeFile`] function.
        pub fn closeFile(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, closeFileCall, N> {
            self.call_builder(&closeFileCall { path })
        }
        ///Creates a new call builder for the [`computeCreate2Address_0`] function.
        pub fn computeCreate2Address_0(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
            initCodeHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, computeCreate2Address_0Call, N> {
            self.call_builder(&computeCreate2Address_0Call { salt, initCodeHash })
        }
        ///Creates a new call builder for the [`computeCreate2Address_1`] function.
        pub fn computeCreate2Address_1(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
            initCodeHash: alloy::sol_types::private::FixedBytes<32>,
            deployer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, computeCreate2Address_1Call, N> {
            self.call_builder(&computeCreate2Address_1Call { salt, initCodeHash, deployer })
        }
        ///Creates a new call builder for the [`computeCreateAddress`] function.
        pub fn computeCreateAddress(
            &self,
            deployer: alloy::sol_types::private::Address,
            nonce: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, computeCreateAddressCall, N> {
            self.call_builder(&computeCreateAddressCall { deployer, nonce })
        }
        ///Creates a new call builder for the [`contains`] function.
        pub fn contains(
            &self,
            subject: alloy::sol_types::private::String,
            search: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, containsCall, N> {
            self.call_builder(&containsCall { subject, search })
        }
        ///Creates a new call builder for the [`copyFile`] function.
        pub fn copyFile(
            &self,
            from: alloy::sol_types::private::String,
            to: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, copyFileCall, N> {
            self.call_builder(&copyFileCall { from, to })
        }
        ///Creates a new call builder for the [`copyStorage`] function.
        pub fn copyStorage(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, copyStorageCall, N> {
            self.call_builder(&copyStorageCall { from, to })
        }
        ///Creates a new call builder for the [`createDir`] function.
        pub fn createDir(
            &self,
            path: alloy::sol_types::private::String,
            recursive: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, createDirCall, N> {
            self.call_builder(&createDirCall { path, recursive })
        }
        ///Creates a new call builder for the [`createWallet_0`] function.
        pub fn createWallet_0(
            &self,
            walletLabel: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, createWallet_0Call, N> {
            self.call_builder(&createWallet_0Call { walletLabel })
        }
        ///Creates a new call builder for the [`createWallet_1`] function.
        pub fn createWallet_1(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, createWallet_1Call, N> {
            self.call_builder(&createWallet_1Call { privateKey })
        }
        ///Creates a new call builder for the [`createWallet_2`] function.
        pub fn createWallet_2(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
            walletLabel: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, createWallet_2Call, N> {
            self.call_builder(&createWallet_2Call { privateKey, walletLabel })
        }
        ///Creates a new call builder for the [`deployCode_0`] function.
        pub fn deployCode_0(
            &self,
            artifactPath: alloy::sol_types::private::String,
            constructorArgs: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, deployCode_0Call, N> {
            self.call_builder(&deployCode_0Call { artifactPath, constructorArgs })
        }
        ///Creates a new call builder for the [`deployCode_1`] function.
        pub fn deployCode_1(
            &self,
            artifactPath: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, deployCode_1Call, N> {
            self.call_builder(&deployCode_1Call { artifactPath })
        }
        ///Creates a new call builder for the [`deriveKey_0`] function.
        pub fn deriveKey_0(
            &self,
            mnemonic: alloy::sol_types::private::String,
            derivationPath: alloy::sol_types::private::String,
            index: u32,
            language: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, deriveKey_0Call, N> {
            self.call_builder(&deriveKey_0Call { mnemonic, derivationPath, index, language })
        }
        ///Creates a new call builder for the [`deriveKey_1`] function.
        pub fn deriveKey_1(
            &self,
            mnemonic: alloy::sol_types::private::String,
            index: u32,
            language: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, deriveKey_1Call, N> {
            self.call_builder(&deriveKey_1Call { mnemonic, index, language })
        }
        ///Creates a new call builder for the [`deriveKey_2`] function.
        pub fn deriveKey_2(
            &self,
            mnemonic: alloy::sol_types::private::String,
            index: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, deriveKey_2Call, N> {
            self.call_builder(&deriveKey_2Call { mnemonic, index })
        }
        ///Creates a new call builder for the [`deriveKey_3`] function.
        pub fn deriveKey_3(
            &self,
            mnemonic: alloy::sol_types::private::String,
            derivationPath: alloy::sol_types::private::String,
            index: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, deriveKey_3Call, N> {
            self.call_builder(&deriveKey_3Call { mnemonic, derivationPath, index })
        }
        ///Creates a new call builder for the [`ensNamehash`] function.
        pub fn ensNamehash(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, ensNamehashCall, N> {
            self.call_builder(&ensNamehashCall { name })
        }
        ///Creates a new call builder for the [`envAddress_0`] function.
        pub fn envAddress_0(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envAddress_0Call, N> {
            self.call_builder(&envAddress_0Call { name })
        }
        ///Creates a new call builder for the [`envAddress_1`] function.
        pub fn envAddress_1(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envAddress_1Call, N> {
            self.call_builder(&envAddress_1Call { name, delim })
        }
        ///Creates a new call builder for the [`envBool_0`] function.
        pub fn envBool_0(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBool_0Call, N> {
            self.call_builder(&envBool_0Call { name })
        }
        ///Creates a new call builder for the [`envBool_1`] function.
        pub fn envBool_1(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBool_1Call, N> {
            self.call_builder(&envBool_1Call { name, delim })
        }
        ///Creates a new call builder for the [`envBytes_0`] function.
        pub fn envBytes_0(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBytes_0Call, N> {
            self.call_builder(&envBytes_0Call { name })
        }
        ///Creates a new call builder for the [`envBytes_1`] function.
        pub fn envBytes_1(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBytes_1Call, N> {
            self.call_builder(&envBytes_1Call { name, delim })
        }
        ///Creates a new call builder for the [`envBytes32_0`] function.
        pub fn envBytes32_0(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBytes32_0Call, N> {
            self.call_builder(&envBytes32_0Call { name, delim })
        }
        ///Creates a new call builder for the [`envBytes32_1`] function.
        pub fn envBytes32_1(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envBytes32_1Call, N> {
            self.call_builder(&envBytes32_1Call { name })
        }
        ///Creates a new call builder for the [`envExists`] function.
        pub fn envExists(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envExistsCall, N> {
            self.call_builder(&envExistsCall { name })
        }
        ///Creates a new call builder for the [`envInt_0`] function.
        pub fn envInt_0(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envInt_0Call, N> {
            self.call_builder(&envInt_0Call { name, delim })
        }
        ///Creates a new call builder for the [`envInt_1`] function.
        pub fn envInt_1(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envInt_1Call, N> {
            self.call_builder(&envInt_1Call { name })
        }
        ///Creates a new call builder for the [`envOr_0`] function.
        pub fn envOr_0(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_0Call, N> {
            self.call_builder(&envOr_0Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_1`] function.
        pub fn envOr_1(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_1Call, N> {
            self.call_builder(&envOr_1Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_2`] function.
        pub fn envOr_2(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_2Call, N> {
            self.call_builder(&envOr_2Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_3`] function.
        pub fn envOr_3(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_3Call, N> {
            self.call_builder(&envOr_3Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_4`] function.
        pub fn envOr_4(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_4Call, N> {
            self.call_builder(&envOr_4Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_5`] function.
        pub fn envOr_5(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_5Call, N> {
            self.call_builder(&envOr_5Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_6`] function.
        pub fn envOr_6(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_6Call, N> {
            self.call_builder(&envOr_6Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_7`] function.
        pub fn envOr_7(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_7Call, N> {
            self.call_builder(&envOr_7Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_8`] function.
        pub fn envOr_8(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_8Call, N> {
            self.call_builder(&envOr_8Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_9`] function.
        pub fn envOr_9(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_9Call, N> {
            self.call_builder(&envOr_9Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_10`] function.
        pub fn envOr_10(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_10Call, N> {
            self.call_builder(&envOr_10Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_11`] function.
        pub fn envOr_11(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_11Call, N> {
            self.call_builder(&envOr_11Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_12`] function.
        pub fn envOr_12(
            &self,
            name: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_12Call, N> {
            self.call_builder(&envOr_12Call { name, defaultValue })
        }
        ///Creates a new call builder for the [`envOr_13`] function.
        pub fn envOr_13(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
            defaultValue: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, envOr_13Call, N> {
            self.call_builder(&envOr_13Call { name, delim, defaultValue })
        }
        ///Creates a new call builder for the [`envString_0`] function.
        pub fn envString_0(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envString_0Call, N> {
            self.call_builder(&envString_0Call { name, delim })
        }
        ///Creates a new call builder for the [`envString_1`] function.
        pub fn envString_1(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envString_1Call, N> {
            self.call_builder(&envString_1Call { name })
        }
        ///Creates a new call builder for the [`envUint_0`] function.
        pub fn envUint_0(
            &self,
            name: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envUint_0Call, N> {
            self.call_builder(&envUint_0Call { name })
        }
        ///Creates a new call builder for the [`envUint_1`] function.
        pub fn envUint_1(
            &self,
            name: alloy::sol_types::private::String,
            delim: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, envUint_1Call, N> {
            self.call_builder(&envUint_1Call { name, delim })
        }
        ///Creates a new call builder for the [`eth_getLogs`] function.
        pub fn eth_getLogs(
            &self,
            fromBlock: alloy::sol_types::private::primitives::aliases::U256,
            toBlock: alloy::sol_types::private::primitives::aliases::U256,
            target: alloy::sol_types::private::Address,
            topics: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, eth_getLogsCall, N> {
            self.call_builder(&eth_getLogsCall { fromBlock, toBlock, target, topics })
        }
        ///Creates a new call builder for the [`exists`] function.
        pub fn exists(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, existsCall, N> {
            self.call_builder(&existsCall { path })
        }
        ///Creates a new call builder for the [`ffi`] function.
        pub fn ffi(
            &self,
            commandInput: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, ffiCall, N> {
            self.call_builder(&ffiCall { commandInput })
        }
        ///Creates a new call builder for the [`fsMetadata`] function.
        pub fn fsMetadata(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, fsMetadataCall, N> {
            self.call_builder(&fsMetadataCall { path })
        }
        ///Creates a new call builder for the [`getArtifactPathByCode`] function.
        pub fn getArtifactPathByCode(
            &self,
            code: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, getArtifactPathByCodeCall, N> {
            self.call_builder(&getArtifactPathByCodeCall { code })
        }
        ///Creates a new call builder for the [`getArtifactPathByDeployedCode`] function.
        pub fn getArtifactPathByDeployedCode(
            &self,
            deployedCode: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, getArtifactPathByDeployedCodeCall, N> {
            self.call_builder(&getArtifactPathByDeployedCodeCall { deployedCode })
        }
        ///Creates a new call builder for the [`getBlobBaseFee`] function.
        pub fn getBlobBaseFee(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlobBaseFeeCall, N> {
            self.call_builder(&getBlobBaseFeeCall {})
        }
        ///Creates a new call builder for the [`getBlockNumber`] function.
        pub fn getBlockNumber(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlockNumberCall, N> {
            self.call_builder(&getBlockNumberCall {})
        }
        ///Creates a new call builder for the [`getBlockTimestamp`] function.
        pub fn getBlockTimestamp(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlockTimestampCall, N> {
            self.call_builder(&getBlockTimestampCall {})
        }
        ///Creates a new call builder for the [`getBroadcast`] function.
        pub fn getBroadcast(
            &self,
            contractName: alloy::sol_types::private::String,
            chainId: u64,
            txType: <BroadcastTxType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBroadcastCall, N> {
            self.call_builder(&getBroadcastCall { contractName, chainId, txType })
        }
        ///Creates a new call builder for the [`getBroadcasts_0`] function.
        pub fn getBroadcasts_0(
            &self,
            contractName: alloy::sol_types::private::String,
            chainId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBroadcasts_0Call, N> {
            self.call_builder(&getBroadcasts_0Call { contractName, chainId })
        }
        ///Creates a new call builder for the [`getBroadcasts_1`] function.
        pub fn getBroadcasts_1(
            &self,
            contractName: alloy::sol_types::private::String,
            chainId: u64,
            txType: <BroadcastTxType as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBroadcasts_1Call, N> {
            self.call_builder(&getBroadcasts_1Call { contractName, chainId, txType })
        }
        ///Creates a new call builder for the [`getCode`] function.
        pub fn getCode(
            &self,
            artifactPath: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCodeCall, N> {
            self.call_builder(&getCodeCall { artifactPath })
        }
        ///Creates a new call builder for the [`getDeployedCode`] function.
        pub fn getDeployedCode(
            &self,
            artifactPath: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDeployedCodeCall, N> {
            self.call_builder(&getDeployedCodeCall { artifactPath })
        }
        ///Creates a new call builder for the [`getDeployment_0`] function.
        pub fn getDeployment_0(
            &self,
            contractName: alloy::sol_types::private::String,
            chainId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDeployment_0Call, N> {
            self.call_builder(&getDeployment_0Call { contractName, chainId })
        }
        ///Creates a new call builder for the [`getDeployment_1`] function.
        pub fn getDeployment_1(
            &self,
            contractName: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDeployment_1Call, N> {
            self.call_builder(&getDeployment_1Call { contractName })
        }
        ///Creates a new call builder for the [`getDeployments`] function.
        pub fn getDeployments(
            &self,
            contractName: alloy::sol_types::private::String,
            chainId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getDeploymentsCall, N> {
            self.call_builder(&getDeploymentsCall { contractName, chainId })
        }
        ///Creates a new call builder for the [`getFoundryVersion`] function.
        pub fn getFoundryVersion(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getFoundryVersionCall, N> {
            self.call_builder(&getFoundryVersionCall {})
        }
        ///Creates a new call builder for the [`getLabel`] function.
        pub fn getLabel(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLabelCall, N> {
            self.call_builder(&getLabelCall { account })
        }
        ///Creates a new call builder for the [`getMappingKeyAndParentOf`] function.
        pub fn getMappingKeyAndParentOf(
            &self,
            target: alloy::sol_types::private::Address,
            elementSlot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getMappingKeyAndParentOfCall, N> {
            self.call_builder(&getMappingKeyAndParentOfCall { target, elementSlot })
        }
        ///Creates a new call builder for the [`getMappingLength`] function.
        pub fn getMappingLength(
            &self,
            target: alloy::sol_types::private::Address,
            mappingSlot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getMappingLengthCall, N> {
            self.call_builder(&getMappingLengthCall { target, mappingSlot })
        }
        ///Creates a new call builder for the [`getMappingSlotAt`] function.
        pub fn getMappingSlotAt(
            &self,
            target: alloy::sol_types::private::Address,
            mappingSlot: alloy::sol_types::private::FixedBytes<32>,
            idx: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getMappingSlotAtCall, N> {
            self.call_builder(&getMappingSlotAtCall { target, mappingSlot, idx })
        }
        ///Creates a new call builder for the [`getNonce_0`] function.
        pub fn getNonce_0(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNonce_0Call, N> {
            self.call_builder(&getNonce_0Call { account })
        }
        ///Creates a new call builder for the [`getNonce_1`] function.
        pub fn getNonce_1(
            &self,
            wallet: <Wallet as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, getNonce_1Call, N> {
            self.call_builder(&getNonce_1Call { wallet })
        }
        ///Creates a new call builder for the [`getRecordedLogs`] function.
        pub fn getRecordedLogs(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRecordedLogsCall, N> {
            self.call_builder(&getRecordedLogsCall {})
        }
        ///Creates a new call builder for the [`getStateDiff`] function.
        pub fn getStateDiff(&self) -> alloy_contract::SolCallBuilder<T, &P, getStateDiffCall, N> {
            self.call_builder(&getStateDiffCall {})
        }
        ///Creates a new call builder for the [`getStateDiffJson`] function.
        pub fn getStateDiffJson(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getStateDiffJsonCall, N> {
            self.call_builder(&getStateDiffJsonCall {})
        }
        ///Creates a new call builder for the [`getWallets`] function.
        pub fn getWallets(&self) -> alloy_contract::SolCallBuilder<T, &P, getWalletsCall, N> {
            self.call_builder(&getWalletsCall {})
        }
        ///Creates a new call builder for the [`indexOf`] function.
        pub fn indexOf(
            &self,
            input: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, indexOfCall, N> {
            self.call_builder(&indexOfCall { input, key })
        }
        ///Creates a new call builder for the [`isContext`] function.
        pub fn isContext(
            &self,
            context: <ForgeContext as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, isContextCall, N> {
            self.call_builder(&isContextCall { context })
        }
        ///Creates a new call builder for the [`isDir`] function.
        pub fn isDir(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, isDirCall, N> {
            self.call_builder(&isDirCall { path })
        }
        ///Creates a new call builder for the [`isFile`] function.
        pub fn isFile(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, isFileCall, N> {
            self.call_builder(&isFileCall { path })
        }
        ///Creates a new call builder for the [`keyExists`] function.
        pub fn keyExists(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, keyExistsCall, N> {
            self.call_builder(&keyExistsCall { json, key })
        }
        ///Creates a new call builder for the [`keyExistsJson`] function.
        pub fn keyExistsJson(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, keyExistsJsonCall, N> {
            self.call_builder(&keyExistsJsonCall { json, key })
        }
        ///Creates a new call builder for the [`keyExistsToml`] function.
        pub fn keyExistsToml(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, keyExistsTomlCall, N> {
            self.call_builder(&keyExistsTomlCall { toml, key })
        }
        ///Creates a new call builder for the [`label`] function.
        pub fn label(
            &self,
            account: alloy::sol_types::private::Address,
            newLabel: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, labelCall, N> {
            self.call_builder(&labelCall { account, newLabel })
        }
        ///Creates a new call builder for the [`lastCallGas`] function.
        pub fn lastCallGas(&self) -> alloy_contract::SolCallBuilder<T, &P, lastCallGasCall, N> {
            self.call_builder(&lastCallGasCall {})
        }
        ///Creates a new call builder for the [`load`] function.
        pub fn load(
            &self,
            target: alloy::sol_types::private::Address,
            slot: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, loadCall, N> {
            self.call_builder(&loadCall { target, slot })
        }
        ///Creates a new call builder for the [`parseAddress`] function.
        pub fn parseAddress(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseAddressCall, N> {
            self.call_builder(&parseAddressCall { stringifiedValue })
        }
        ///Creates a new call builder for the [`parseBool`] function.
        pub fn parseBool(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseBoolCall, N> {
            self.call_builder(&parseBoolCall { stringifiedValue })
        }
        ///Creates a new call builder for the [`parseBytes`] function.
        pub fn parseBytes(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseBytesCall, N> {
            self.call_builder(&parseBytesCall { stringifiedValue })
        }
        ///Creates a new call builder for the [`parseBytes32`] function.
        pub fn parseBytes32(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseBytes32Call, N> {
            self.call_builder(&parseBytes32Call { stringifiedValue })
        }
        ///Creates a new call builder for the [`parseInt`] function.
        pub fn parseInt(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseIntCall, N> {
            self.call_builder(&parseIntCall { stringifiedValue })
        }
        ///Creates a new call builder for the [`parseJson_0`] function.
        pub fn parseJson_0(
            &self,
            json: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJson_0Call, N> {
            self.call_builder(&parseJson_0Call { json })
        }
        ///Creates a new call builder for the [`parseJson_1`] function.
        pub fn parseJson_1(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJson_1Call, N> {
            self.call_builder(&parseJson_1Call { json, key })
        }
        ///Creates a new call builder for the [`parseJsonAddress`] function.
        pub fn parseJsonAddress(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonAddressCall, N> {
            self.call_builder(&parseJsonAddressCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonAddressArray`] function.
        pub fn parseJsonAddressArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonAddressArrayCall, N> {
            self.call_builder(&parseJsonAddressArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBool`] function.
        pub fn parseJsonBool(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBoolCall, N> {
            self.call_builder(&parseJsonBoolCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBoolArray`] function.
        pub fn parseJsonBoolArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBoolArrayCall, N> {
            self.call_builder(&parseJsonBoolArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBytes`] function.
        pub fn parseJsonBytes(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBytesCall, N> {
            self.call_builder(&parseJsonBytesCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBytes32`] function.
        pub fn parseJsonBytes32(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBytes32Call, N> {
            self.call_builder(&parseJsonBytes32Call { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBytes32Array`] function.
        pub fn parseJsonBytes32Array(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBytes32ArrayCall, N> {
            self.call_builder(&parseJsonBytes32ArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonBytesArray`] function.
        pub fn parseJsonBytesArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonBytesArrayCall, N> {
            self.call_builder(&parseJsonBytesArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonInt`] function.
        pub fn parseJsonInt(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonIntCall, N> {
            self.call_builder(&parseJsonIntCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonIntArray`] function.
        pub fn parseJsonIntArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonIntArrayCall, N> {
            self.call_builder(&parseJsonIntArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonKeys`] function.
        pub fn parseJsonKeys(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonKeysCall, N> {
            self.call_builder(&parseJsonKeysCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonString`] function.
        pub fn parseJsonString(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonStringCall, N> {
            self.call_builder(&parseJsonStringCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonStringArray`] function.
        pub fn parseJsonStringArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonStringArrayCall, N> {
            self.call_builder(&parseJsonStringArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonType_0`] function.
        pub fn parseJsonType_0(
            &self,
            json: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonType_0Call, N> {
            self.call_builder(&parseJsonType_0Call { json, typeDescription })
        }
        ///Creates a new call builder for the [`parseJsonType_1`] function.
        pub fn parseJsonType_1(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonType_1Call, N> {
            self.call_builder(&parseJsonType_1Call { json, key, typeDescription })
        }
        ///Creates a new call builder for the [`parseJsonTypeArray`] function.
        pub fn parseJsonTypeArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonTypeArrayCall, N> {
            self.call_builder(&parseJsonTypeArrayCall { json, key, typeDescription })
        }
        ///Creates a new call builder for the [`parseJsonUint`] function.
        pub fn parseJsonUint(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonUintCall, N> {
            self.call_builder(&parseJsonUintCall { json, key })
        }
        ///Creates a new call builder for the [`parseJsonUintArray`] function.
        pub fn parseJsonUintArray(
            &self,
            json: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseJsonUintArrayCall, N> {
            self.call_builder(&parseJsonUintArrayCall { json, key })
        }
        ///Creates a new call builder for the [`parseToml_0`] function.
        pub fn parseToml_0(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseToml_0Call, N> {
            self.call_builder(&parseToml_0Call { toml, key })
        }
        ///Creates a new call builder for the [`parseToml_1`] function.
        pub fn parseToml_1(
            &self,
            toml: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseToml_1Call, N> {
            self.call_builder(&parseToml_1Call { toml })
        }
        ///Creates a new call builder for the [`parseTomlAddress`] function.
        pub fn parseTomlAddress(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlAddressCall, N> {
            self.call_builder(&parseTomlAddressCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlAddressArray`] function.
        pub fn parseTomlAddressArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlAddressArrayCall, N> {
            self.call_builder(&parseTomlAddressArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBool`] function.
        pub fn parseTomlBool(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBoolCall, N> {
            self.call_builder(&parseTomlBoolCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBoolArray`] function.
        pub fn parseTomlBoolArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBoolArrayCall, N> {
            self.call_builder(&parseTomlBoolArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBytes`] function.
        pub fn parseTomlBytes(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBytesCall, N> {
            self.call_builder(&parseTomlBytesCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBytes32`] function.
        pub fn parseTomlBytes32(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBytes32Call, N> {
            self.call_builder(&parseTomlBytes32Call { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBytes32Array`] function.
        pub fn parseTomlBytes32Array(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBytes32ArrayCall, N> {
            self.call_builder(&parseTomlBytes32ArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlBytesArray`] function.
        pub fn parseTomlBytesArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlBytesArrayCall, N> {
            self.call_builder(&parseTomlBytesArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlInt`] function.
        pub fn parseTomlInt(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlIntCall, N> {
            self.call_builder(&parseTomlIntCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlIntArray`] function.
        pub fn parseTomlIntArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlIntArrayCall, N> {
            self.call_builder(&parseTomlIntArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlKeys`] function.
        pub fn parseTomlKeys(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlKeysCall, N> {
            self.call_builder(&parseTomlKeysCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlString`] function.
        pub fn parseTomlString(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlStringCall, N> {
            self.call_builder(&parseTomlStringCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlStringArray`] function.
        pub fn parseTomlStringArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlStringArrayCall, N> {
            self.call_builder(&parseTomlStringArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlType_0`] function.
        pub fn parseTomlType_0(
            &self,
            toml: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlType_0Call, N> {
            self.call_builder(&parseTomlType_0Call { toml, typeDescription })
        }
        ///Creates a new call builder for the [`parseTomlType_1`] function.
        pub fn parseTomlType_1(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlType_1Call, N> {
            self.call_builder(&parseTomlType_1Call { toml, key, typeDescription })
        }
        ///Creates a new call builder for the [`parseTomlTypeArray`] function.
        pub fn parseTomlTypeArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlTypeArrayCall, N> {
            self.call_builder(&parseTomlTypeArrayCall { toml, key, typeDescription })
        }
        ///Creates a new call builder for the [`parseTomlUint`] function.
        pub fn parseTomlUint(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlUintCall, N> {
            self.call_builder(&parseTomlUintCall { toml, key })
        }
        ///Creates a new call builder for the [`parseTomlUintArray`] function.
        pub fn parseTomlUintArray(
            &self,
            toml: alloy::sol_types::private::String,
            key: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseTomlUintArrayCall, N> {
            self.call_builder(&parseTomlUintArrayCall { toml, key })
        }
        ///Creates a new call builder for the [`parseUint`] function.
        pub fn parseUint(
            &self,
            stringifiedValue: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, parseUintCall, N> {
            self.call_builder(&parseUintCall { stringifiedValue })
        }
        ///Creates a new call builder for the [`pauseGasMetering`] function.
        pub fn pauseGasMetering(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseGasMeteringCall, N> {
            self.call_builder(&pauseGasMeteringCall {})
        }
        ///Creates a new call builder for the [`pauseTracing`] function.
        pub fn pauseTracing(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseTracingCall, N> {
            self.call_builder(&pauseTracingCall {})
        }
        ///Creates a new call builder for the [`projectRoot`] function.
        pub fn projectRoot(&self) -> alloy_contract::SolCallBuilder<T, &P, projectRootCall, N> {
            self.call_builder(&projectRootCall {})
        }
        ///Creates a new call builder for the [`prompt`] function.
        pub fn prompt(
            &self,
            promptText: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, promptCall, N> {
            self.call_builder(&promptCall { promptText })
        }
        ///Creates a new call builder for the [`promptAddress`] function.
        pub fn promptAddress(
            &self,
            promptText: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, promptAddressCall, N> {
            self.call_builder(&promptAddressCall { promptText })
        }
        ///Creates a new call builder for the [`promptSecret`] function.
        pub fn promptSecret(
            &self,
            promptText: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, promptSecretCall, N> {
            self.call_builder(&promptSecretCall { promptText })
        }
        ///Creates a new call builder for the [`promptSecretUint`] function.
        pub fn promptSecretUint(
            &self,
            promptText: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, promptSecretUintCall, N> {
            self.call_builder(&promptSecretUintCall { promptText })
        }
        ///Creates a new call builder for the [`promptUint`] function.
        pub fn promptUint(
            &self,
            promptText: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, promptUintCall, N> {
            self.call_builder(&promptUintCall { promptText })
        }
        ///Creates a new call builder for the [`publicKeyP256`] function.
        pub fn publicKeyP256(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, publicKeyP256Call, N> {
            self.call_builder(&publicKeyP256Call { privateKey })
        }
        ///Creates a new call builder for the [`randomAddress`] function.
        pub fn randomAddress(&self) -> alloy_contract::SolCallBuilder<T, &P, randomAddressCall, N> {
            self.call_builder(&randomAddressCall {})
        }
        ///Creates a new call builder for the [`randomBool`] function.
        pub fn randomBool(&self) -> alloy_contract::SolCallBuilder<T, &P, randomBoolCall, N> {
            self.call_builder(&randomBoolCall {})
        }
        ///Creates a new call builder for the [`randomBytes`] function.
        pub fn randomBytes(
            &self,
            len: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomBytesCall, N> {
            self.call_builder(&randomBytesCall { len })
        }
        ///Creates a new call builder for the [`randomBytes4`] function.
        pub fn randomBytes4(&self) -> alloy_contract::SolCallBuilder<T, &P, randomBytes4Call, N> {
            self.call_builder(&randomBytes4Call {})
        }
        ///Creates a new call builder for the [`randomBytes8`] function.
        pub fn randomBytes8(&self) -> alloy_contract::SolCallBuilder<T, &P, randomBytes8Call, N> {
            self.call_builder(&randomBytes8Call {})
        }
        ///Creates a new call builder for the [`randomInt_0`] function.
        pub fn randomInt_0(&self) -> alloy_contract::SolCallBuilder<T, &P, randomInt_0Call, N> {
            self.call_builder(&randomInt_0Call {})
        }
        ///Creates a new call builder for the [`randomInt_1`] function.
        pub fn randomInt_1(
            &self,
            bits: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomInt_1Call, N> {
            self.call_builder(&randomInt_1Call { bits })
        }
        ///Creates a new call builder for the [`randomUint_0`] function.
        pub fn randomUint_0(&self) -> alloy_contract::SolCallBuilder<T, &P, randomUint_0Call, N> {
            self.call_builder(&randomUint_0Call {})
        }
        ///Creates a new call builder for the [`randomUint_1`] function.
        pub fn randomUint_1(
            &self,
            bits: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomUint_1Call, N> {
            self.call_builder(&randomUint_1Call { bits })
        }
        ///Creates a new call builder for the [`randomUint_2`] function.
        pub fn randomUint_2(
            &self,
            min: alloy::sol_types::private::primitives::aliases::U256,
            max: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, randomUint_2Call, N> {
            self.call_builder(&randomUint_2Call { min, max })
        }
        ///Creates a new call builder for the [`readDir_0`] function.
        pub fn readDir_0(
            &self,
            path: alloy::sol_types::private::String,
            maxDepth: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, readDir_0Call, N> {
            self.call_builder(&readDir_0Call { path, maxDepth })
        }
        ///Creates a new call builder for the [`readDir_1`] function.
        pub fn readDir_1(
            &self,
            path: alloy::sol_types::private::String,
            maxDepth: u64,
            followLinks: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, readDir_1Call, N> {
            self.call_builder(&readDir_1Call { path, maxDepth, followLinks })
        }
        ///Creates a new call builder for the [`readDir_2`] function.
        pub fn readDir_2(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, readDir_2Call, N> {
            self.call_builder(&readDir_2Call { path })
        }
        ///Creates a new call builder for the [`readFile`] function.
        pub fn readFile(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, readFileCall, N> {
            self.call_builder(&readFileCall { path })
        }
        ///Creates a new call builder for the [`readFileBinary`] function.
        pub fn readFileBinary(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, readFileBinaryCall, N> {
            self.call_builder(&readFileBinaryCall { path })
        }
        ///Creates a new call builder for the [`readLine`] function.
        pub fn readLine(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, readLineCall, N> {
            self.call_builder(&readLineCall { path })
        }
        ///Creates a new call builder for the [`readLink`] function.
        pub fn readLink(
            &self,
            linkPath: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, readLinkCall, N> {
            self.call_builder(&readLinkCall { linkPath })
        }
        ///Creates a new call builder for the [`record`] function.
        pub fn record(&self) -> alloy_contract::SolCallBuilder<T, &P, recordCall, N> {
            self.call_builder(&recordCall {})
        }
        ///Creates a new call builder for the [`recordLogs`] function.
        pub fn recordLogs(&self) -> alloy_contract::SolCallBuilder<T, &P, recordLogsCall, N> {
            self.call_builder(&recordLogsCall {})
        }
        ///Creates a new call builder for the [`rememberKey`] function.
        pub fn rememberKey(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, rememberKeyCall, N> {
            self.call_builder(&rememberKeyCall { privateKey })
        }
        ///Creates a new call builder for the [`rememberKeys_0`] function.
        pub fn rememberKeys_0(
            &self,
            mnemonic: alloy::sol_types::private::String,
            derivationPath: alloy::sol_types::private::String,
            count: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, rememberKeys_0Call, N> {
            self.call_builder(&rememberKeys_0Call { mnemonic, derivationPath, count })
        }
        ///Creates a new call builder for the [`rememberKeys_1`] function.
        pub fn rememberKeys_1(
            &self,
            mnemonic: alloy::sol_types::private::String,
            derivationPath: alloy::sol_types::private::String,
            language: alloy::sol_types::private::String,
            count: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, rememberKeys_1Call, N> {
            self.call_builder(&rememberKeys_1Call { mnemonic, derivationPath, language, count })
        }
        ///Creates a new call builder for the [`removeDir`] function.
        pub fn removeDir(
            &self,
            path: alloy::sol_types::private::String,
            recursive: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeDirCall, N> {
            self.call_builder(&removeDirCall { path, recursive })
        }
        ///Creates a new call builder for the [`removeFile`] function.
        pub fn removeFile(
            &self,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, removeFileCall, N> {
            self.call_builder(&removeFileCall { path })
        }
        ///Creates a new call builder for the [`replace`] function.
        pub fn replace(
            &self,
            input: alloy::sol_types::private::String,
            from: alloy::sol_types::private::String,
            to: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, replaceCall, N> {
            self.call_builder(&replaceCall { input, from, to })
        }
        ///Creates a new call builder for the [`resetGasMetering`] function.
        pub fn resetGasMetering(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resetGasMeteringCall, N> {
            self.call_builder(&resetGasMeteringCall {})
        }
        ///Creates a new call builder for the [`resumeGasMetering`] function.
        pub fn resumeGasMetering(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, resumeGasMeteringCall, N> {
            self.call_builder(&resumeGasMeteringCall {})
        }
        ///Creates a new call builder for the [`resumeTracing`] function.
        pub fn resumeTracing(&self) -> alloy_contract::SolCallBuilder<T, &P, resumeTracingCall, N> {
            self.call_builder(&resumeTracingCall {})
        }
        ///Creates a new call builder for the [`rpc_0`] function.
        pub fn rpc_0(
            &self,
            urlOrAlias: alloy::sol_types::private::String,
            method: alloy::sol_types::private::String,
            params: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, rpc_0Call, N> {
            self.call_builder(&rpc_0Call { urlOrAlias, method, params })
        }
        ///Creates a new call builder for the [`rpc_1`] function.
        pub fn rpc_1(
            &self,
            method: alloy::sol_types::private::String,
            params: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, rpc_1Call, N> {
            self.call_builder(&rpc_1Call { method, params })
        }
        ///Creates a new call builder for the [`rpcUrl`] function.
        pub fn rpcUrl(
            &self,
            rpcAlias: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, rpcUrlCall, N> {
            self.call_builder(&rpcUrlCall { rpcAlias })
        }
        ///Creates a new call builder for the [`rpcUrlStructs`] function.
        pub fn rpcUrlStructs(&self) -> alloy_contract::SolCallBuilder<T, &P, rpcUrlStructsCall, N> {
            self.call_builder(&rpcUrlStructsCall {})
        }
        ///Creates a new call builder for the [`rpcUrls`] function.
        pub fn rpcUrls(&self) -> alloy_contract::SolCallBuilder<T, &P, rpcUrlsCall, N> {
            self.call_builder(&rpcUrlsCall {})
        }
        ///Creates a new call builder for the [`serializeAddress_0`] function.
        pub fn serializeAddress_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeAddress_0Call, N> {
            self.call_builder(&serializeAddress_0Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeAddress_1`] function.
        pub fn serializeAddress_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeAddress_1Call, N> {
            self.call_builder(&serializeAddress_1Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeBool_0`] function.
        pub fn serializeBool_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<bool>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBool_0Call, N> {
            self.call_builder(&serializeBool_0Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeBool_1`] function.
        pub fn serializeBool_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBool_1Call, N> {
            self.call_builder(&serializeBool_1Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeBytes_0`] function.
        pub fn serializeBytes_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBytes_0Call, N> {
            self.call_builder(&serializeBytes_0Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeBytes_1`] function.
        pub fn serializeBytes_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBytes_1Call, N> {
            self.call_builder(&serializeBytes_1Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeBytes32_0`] function.
        pub fn serializeBytes32_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBytes32_0Call, N> {
            self.call_builder(&serializeBytes32_0Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeBytes32_1`] function.
        pub fn serializeBytes32_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeBytes32_1Call, N> {
            self.call_builder(&serializeBytes32_1Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeInt_0`] function.
        pub fn serializeInt_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeInt_0Call, N> {
            self.call_builder(&serializeInt_0Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeInt_1`] function.
        pub fn serializeInt_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::I256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeInt_1Call, N> {
            self.call_builder(&serializeInt_1Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeJson`] function.
        pub fn serializeJson(
            &self,
            objectKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeJsonCall, N> {
            self.call_builder(&serializeJsonCall { objectKey, value })
        }
        ///Creates a new call builder for the [`serializeJsonType_0`] function.
        pub fn serializeJsonType_0(
            &self,
            typeDescription: alloy::sol_types::private::String,
            value: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeJsonType_0Call, N> {
            self.call_builder(&serializeJsonType_0Call { typeDescription, value })
        }
        ///Creates a new call builder for the [`serializeJsonType_1`] function.
        pub fn serializeJsonType_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            typeDescription: alloy::sol_types::private::String,
            value: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeJsonType_1Call, N> {
            self.call_builder(&serializeJsonType_1Call {
                objectKey,
                valueKey,
                typeDescription,
                value,
            })
        }
        ///Creates a new call builder for the [`serializeString_0`] function.
        pub fn serializeString_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeString_0Call, N> {
            self.call_builder(&serializeString_0Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeString_1`] function.
        pub fn serializeString_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeString_1Call, N> {
            self.call_builder(&serializeString_1Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeUint_0`] function.
        pub fn serializeUint_0(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeUint_0Call, N> {
            self.call_builder(&serializeUint_0Call { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`serializeUint_1`] function.
        pub fn serializeUint_1(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            values: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeUint_1Call, N> {
            self.call_builder(&serializeUint_1Call { objectKey, valueKey, values })
        }
        ///Creates a new call builder for the [`serializeUintToHex`] function.
        pub fn serializeUintToHex(
            &self,
            objectKey: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, serializeUintToHexCall, N> {
            self.call_builder(&serializeUintToHexCall { objectKey, valueKey, value })
        }
        ///Creates a new call builder for the [`setArbitraryStorage`] function.
        pub fn setArbitraryStorage(
            &self,
            target: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setArbitraryStorageCall, N> {
            self.call_builder(&setArbitraryStorageCall { target })
        }
        ///Creates a new call builder for the [`setEnv`] function.
        pub fn setEnv(
            &self,
            name: alloy::sol_types::private::String,
            value: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, setEnvCall, N> {
            self.call_builder(&setEnvCall { name, value })
        }
        ///Creates a new call builder for the [`sign_0`] function.
        pub fn sign_0(
            &self,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, sign_0Call, N> {
            self.call_builder(&sign_0Call { digest })
        }
        ///Creates a new call builder for the [`sign_1`] function.
        pub fn sign_1(
            &self,
            signer: alloy::sol_types::private::Address,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, sign_1Call, N> {
            self.call_builder(&sign_1Call { signer, digest })
        }
        ///Creates a new call builder for the [`sign_2`] function.
        pub fn sign_2(
            &self,
            wallet: <Wallet as alloy::sol_types::SolType>::RustType,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, sign_2Call, N> {
            self.call_builder(&sign_2Call { wallet, digest })
        }
        ///Creates a new call builder for the [`sign_3`] function.
        pub fn sign_3(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, sign_3Call, N> {
            self.call_builder(&sign_3Call { privateKey, digest })
        }
        ///Creates a new call builder for the [`signAndAttachDelegation`] function.
        pub fn signAndAttachDelegation(
            &self,
            implementation: alloy::sol_types::private::Address,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, signAndAttachDelegationCall, N> {
            self.call_builder(&signAndAttachDelegationCall { implementation, privateKey })
        }
        ///Creates a new call builder for the [`signCompact_0`] function.
        pub fn signCompact_0(
            &self,
            wallet: <Wallet as alloy::sol_types::SolType>::RustType,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signCompact_0Call, N> {
            self.call_builder(&signCompact_0Call { wallet, digest })
        }
        ///Creates a new call builder for the [`signCompact_1`] function.
        pub fn signCompact_1(
            &self,
            signer: alloy::sol_types::private::Address,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signCompact_1Call, N> {
            self.call_builder(&signCompact_1Call { signer, digest })
        }
        ///Creates a new call builder for the [`signCompact_2`] function.
        pub fn signCompact_2(
            &self,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signCompact_2Call, N> {
            self.call_builder(&signCompact_2Call { digest })
        }
        ///Creates a new call builder for the [`signCompact_3`] function.
        pub fn signCompact_3(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signCompact_3Call, N> {
            self.call_builder(&signCompact_3Call { privateKey, digest })
        }
        ///Creates a new call builder for the [`signDelegation`] function.
        pub fn signDelegation(
            &self,
            implementation: alloy::sol_types::private::Address,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, signDelegationCall, N> {
            self.call_builder(&signDelegationCall { implementation, privateKey })
        }
        ///Creates a new call builder for the [`signP256`] function.
        pub fn signP256(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
            digest: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, signP256Call, N> {
            self.call_builder(&signP256Call { privateKey, digest })
        }
        ///Creates a new call builder for the [`sleep`] function.
        pub fn sleep(
            &self,
            duration: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, sleepCall, N> {
            self.call_builder(&sleepCall { duration })
        }
        ///Creates a new call builder for the [`split`] function.
        pub fn split(
            &self,
            input: alloy::sol_types::private::String,
            delimiter: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, splitCall, N> {
            self.call_builder(&splitCall { input, delimiter })
        }
        ///Creates a new call builder for the [`startBroadcast_0`] function.
        pub fn startBroadcast_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startBroadcast_0Call, N> {
            self.call_builder(&startBroadcast_0Call {})
        }
        ///Creates a new call builder for the [`startBroadcast_1`] function.
        pub fn startBroadcast_1(
            &self,
            signer: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, startBroadcast_1Call, N> {
            self.call_builder(&startBroadcast_1Call { signer })
        }
        ///Creates a new call builder for the [`startBroadcast_2`] function.
        pub fn startBroadcast_2(
            &self,
            privateKey: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, startBroadcast_2Call, N> {
            self.call_builder(&startBroadcast_2Call { privateKey })
        }
        ///Creates a new call builder for the [`startDebugTraceRecording`] function.
        pub fn startDebugTraceRecording(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startDebugTraceRecordingCall, N> {
            self.call_builder(&startDebugTraceRecordingCall {})
        }
        ///Creates a new call builder for the [`startMappingRecording`] function.
        pub fn startMappingRecording(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startMappingRecordingCall, N> {
            self.call_builder(&startMappingRecordingCall {})
        }
        ///Creates a new call builder for the [`startStateDiffRecording`] function.
        pub fn startStateDiffRecording(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, startStateDiffRecordingCall, N> {
            self.call_builder(&startStateDiffRecordingCall {})
        }
        ///Creates a new call builder for the [`stopAndReturnDebugTraceRecording`] function.
        pub fn stopAndReturnDebugTraceRecording(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, stopAndReturnDebugTraceRecordingCall, N>
        {
            self.call_builder(&stopAndReturnDebugTraceRecordingCall {})
        }
        ///Creates a new call builder for the [`stopAndReturnStateDiff`] function.
        pub fn stopAndReturnStateDiff(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, stopAndReturnStateDiffCall, N> {
            self.call_builder(&stopAndReturnStateDiffCall {})
        }
        ///Creates a new call builder for the [`stopBroadcast`] function.
        pub fn stopBroadcast(&self) -> alloy_contract::SolCallBuilder<T, &P, stopBroadcastCall, N> {
            self.call_builder(&stopBroadcastCall {})
        }
        ///Creates a new call builder for the [`stopMappingRecording`] function.
        pub fn stopMappingRecording(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, stopMappingRecordingCall, N> {
            self.call_builder(&stopMappingRecordingCall {})
        }
        ///Creates a new call builder for the [`toBase64_0`] function.
        pub fn toBase64_0(
            &self,
            data: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, toBase64_0Call, N> {
            self.call_builder(&toBase64_0Call { data })
        }
        ///Creates a new call builder for the [`toBase64_1`] function.
        pub fn toBase64_1(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, toBase64_1Call, N> {
            self.call_builder(&toBase64_1Call { data })
        }
        ///Creates a new call builder for the [`toBase64URL_0`] function.
        pub fn toBase64URL_0(
            &self,
            data: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, toBase64URL_0Call, N> {
            self.call_builder(&toBase64URL_0Call { data })
        }
        ///Creates a new call builder for the [`toBase64URL_1`] function.
        pub fn toBase64URL_1(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, toBase64URL_1Call, N> {
            self.call_builder(&toBase64URL_1Call { data })
        }
        ///Creates a new call builder for the [`toLowercase`] function.
        pub fn toLowercase(
            &self,
            input: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, toLowercaseCall, N> {
            self.call_builder(&toLowercaseCall { input })
        }
        ///Creates a new call builder for the [`toString_0`] function.
        pub fn toString_0(
            &self,
            value: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_0Call, N> {
            self.call_builder(&toString_0Call { value })
        }
        ///Creates a new call builder for the [`toString_1`] function.
        pub fn toString_1(
            &self,
            value: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_1Call, N> {
            self.call_builder(&toString_1Call { value })
        }
        ///Creates a new call builder for the [`toString_2`] function.
        pub fn toString_2(
            &self,
            value: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_2Call, N> {
            self.call_builder(&toString_2Call { value })
        }
        ///Creates a new call builder for the [`toString_3`] function.
        pub fn toString_3(
            &self,
            value: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_3Call, N> {
            self.call_builder(&toString_3Call { value })
        }
        ///Creates a new call builder for the [`toString_4`] function.
        pub fn toString_4(
            &self,
            value: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_4Call, N> {
            self.call_builder(&toString_4Call { value })
        }
        ///Creates a new call builder for the [`toString_5`] function.
        pub fn toString_5(
            &self,
            value: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, toString_5Call, N> {
            self.call_builder(&toString_5Call { value })
        }
        ///Creates a new call builder for the [`toUppercase`] function.
        pub fn toUppercase(
            &self,
            input: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, toUppercaseCall, N> {
            self.call_builder(&toUppercaseCall { input })
        }
        ///Creates a new call builder for the [`trim`] function.
        pub fn trim(
            &self,
            input: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, trimCall, N> {
            self.call_builder(&trimCall { input })
        }
        ///Creates a new call builder for the [`tryFfi`] function.
        pub fn tryFfi(
            &self,
            commandInput: alloy::sol_types::private::Vec<alloy::sol_types::private::String>,
        ) -> alloy_contract::SolCallBuilder<T, &P, tryFfiCall, N> {
            self.call_builder(&tryFfiCall { commandInput })
        }
        ///Creates a new call builder for the [`unixTime`] function.
        pub fn unixTime(&self) -> alloy_contract::SolCallBuilder<T, &P, unixTimeCall, N> {
            self.call_builder(&unixTimeCall {})
        }
        ///Creates a new call builder for the [`writeFile`] function.
        pub fn writeFile(
            &self,
            path: alloy::sol_types::private::String,
            data: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeFileCall, N> {
            self.call_builder(&writeFileCall { path, data })
        }
        ///Creates a new call builder for the [`writeFileBinary`] function.
        pub fn writeFileBinary(
            &self,
            path: alloy::sol_types::private::String,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeFileBinaryCall, N> {
            self.call_builder(&writeFileBinaryCall { path, data })
        }
        ///Creates a new call builder for the [`writeJson_0`] function.
        pub fn writeJson_0(
            &self,
            json: alloy::sol_types::private::String,
            path: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeJson_0Call, N> {
            self.call_builder(&writeJson_0Call { json, path, valueKey })
        }
        ///Creates a new call builder for the [`writeJson_1`] function.
        pub fn writeJson_1(
            &self,
            json: alloy::sol_types::private::String,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeJson_1Call, N> {
            self.call_builder(&writeJson_1Call { json, path })
        }
        ///Creates a new call builder for the [`writeLine`] function.
        pub fn writeLine(
            &self,
            path: alloy::sol_types::private::String,
            data: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeLineCall, N> {
            self.call_builder(&writeLineCall { path, data })
        }
        ///Creates a new call builder for the [`writeToml_0`] function.
        pub fn writeToml_0(
            &self,
            json: alloy::sol_types::private::String,
            path: alloy::sol_types::private::String,
            valueKey: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeToml_0Call, N> {
            self.call_builder(&writeToml_0Call { json, path, valueKey })
        }
        ///Creates a new call builder for the [`writeToml_1`] function.
        pub fn writeToml_1(
            &self,
            json: alloy::sol_types::private::String,
            path: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, writeToml_1Call, N> {
            self.call_builder(&writeToml_1Call { json, path })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > VmSafeInstance<T, P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
