/**

Generated by the following Solidity interface...
```solidity
interface ConditionalTokens {
    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
    error ERC1155InvalidApprover(address approver);
    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
    error ERC1155InvalidOperator(address operator);
    error ERC1155InvalidReceiver(address receiver);
    error ERC1155InvalidSender(address sender);
    error ERC1155MissingApprovalForAll(address operator, address owner);

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event ConditionPreparation(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount);
    event ConditionResolution(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount, uint256[] payoutNumerators);
    event PayoutRedemption(address indexed redeemer, address indexed collateralToken, bytes32 indexed parentCollectionId, bytes32 conditionId, uint256[] indexSets, uint256 payout);
    event PositionSplit(address indexed stakeholder, address collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint256[] partition, uint256 amount);
    event PositionsMerge(address indexed stakeholder, address collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint256[] partition, uint256 amount);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event URI(string value, uint256 indexed id);

    constructor(string uri_);

    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) external view returns (uint256[] memory);
    function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet) external view returns (bytes32);
    function getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external pure returns (bytes32);
    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);
    function getPositionId(address collateralToken, bytes32 collectionId) external pure returns (uint256);
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function mergePositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory partition, uint256 amount) external;
    function payoutDenominator(bytes32) external view returns (uint256);
    function payoutNumerators(bytes32, uint256) external view returns (uint256);
    function prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external;
    function redeemPositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory indexSets) external;
    function reportPayouts(bytes32 questionId, uint256[] memory payouts) external;
    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external;
    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) external;
    function setApprovalForAll(address operator, bool approved) external;
    function splitPosition(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory partition, uint256 amount) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function uri(uint256) external view returns (string memory);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "uri_",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "balanceOf",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "balanceOfBatch",
    "inputs": [
      {
        "name": "accounts",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "ids",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCollectionId",
    "inputs": [
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "indexSet",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getConditionId",
    "inputs": [
      {
        "name": "oracle",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "questionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "outcomeSlotCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "getOutcomeSlotCount",
    "inputs": [
      {
        "name": "conditionId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPositionId",
    "inputs": [
      {
        "name": "collateralToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "collectionId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "isApprovedForAll",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "mergePositions",
    "inputs": [
      {
        "name": "collateralToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "partition",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "payoutDenominator",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "payoutNumerators",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "prepareCondition",
    "inputs": [
      {
        "name": "oracle",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "questionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "outcomeSlotCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "redeemPositions",
    "inputs": [
      {
        "name": "collateralToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "indexSets",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "reportPayouts",
    "inputs": [
      {
        "name": "questionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "payouts",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeBatchTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ids",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "values",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "safeTransferFrom",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "value",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setApprovalForAll",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "splitPosition",
    "inputs": [
      {
        "name": "collateralToken",
        "type": "address",
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "partition",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "uri",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "ApprovalForAll",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "approved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ConditionPreparation",
    "inputs": [
      {
        "name": "conditionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "oracle",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "questionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "outcomeSlotCount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ConditionResolution",
    "inputs": [
      {
        "name": "conditionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "oracle",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "questionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "outcomeSlotCount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "payoutNumerators",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PayoutRedemption",
    "inputs": [
      {
        "name": "redeemer",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "collateralToken",
        "type": "address",
        "indexed": true,
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "indexSets",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      },
      {
        "name": "payout",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PositionSplit",
    "inputs": [
      {
        "name": "stakeholder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "collateralToken",
        "type": "address",
        "indexed": false,
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "partition",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PositionsMerge",
    "inputs": [
      {
        "name": "stakeholder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "collateralToken",
        "type": "address",
        "indexed": false,
        "internalType": "contract IERC20"
      },
      {
        "name": "parentCollectionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "conditionId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "partition",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TransferBatch",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ids",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      },
      {
        "name": "values",
        "type": "uint256[]",
        "indexed": false,
        "internalType": "uint256[]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TransferSingle",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "value",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "URI",
    "inputs": [
      {
        "name": "value",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      },
      {
        "name": "id",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "ERC1155InsufficientBalance",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "balance",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "needed",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155InvalidApprover",
    "inputs": [
      {
        "name": "approver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155InvalidArrayLength",
    "inputs": [
      {
        "name": "idsLength",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "valuesLength",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155InvalidOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155InvalidReceiver",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155InvalidSender",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1155MissingApprovalForAll",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "owner",
        "type": "address",
        "internalType": "address"
      }
    ]
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod ConditionalTokens {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060405161339038038061339083398101604081905261002e91610063565b806100388161003f565b5050610266565b600261004b82826101ac565b5050565b634e487b7160e01b5f52604160045260245ffd5b5f60208284031215610073575f5ffd5b81516001600160401b03811115610088575f5ffd5b8201601f81018413610098575f5ffd5b80516001600160401b038111156100b1576100b161004f565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100df576100df61004f565b6040528181528282016020018610156100f6575f5ffd5b5f5b82811015610114576020818501810151838301820152016100f8565b505f91810160200191909152949350505050565b600181811c9082168061013c57607f821691505b60208210810361015a57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156101a757805f5260205f20601f840160051c810160208510156101855750805b601f840160051c820191505b818110156101a4575f8155600101610191565b50505b505050565b81516001600160401b038111156101c5576101c561004f565b6101d9816101d38454610128565b84610160565b6020601f82116001811461020b575f83156101f45750848201515b5f19600385901b1c1916600184901b1784556101a4565b5f84815260208120601f198516915b8281101561023a578785015182556020948501946001909201910161021a565b508482101561025757868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b61311d806102735f395ff3fe608060405234801561000f575f5ffd5b506004361061011b575f3560e01c8063852c6ae2116100a9578063d42dc0c21161006e578063d42dc0c214610268578063d96ee75414610287578063dd34de671461029a578063e985e9c5146102b9578063f242432a146102cc575f5ffd5b8063852c6ae214610209578063856296f71461021c5780639e7212ad1461022f578063a22cb46514610242578063c49298ac14610255575f5ffd5b80630e89341c116100ef5780630e89341c146101905780632eb2c2d6146101b057806339dd7530146101c35780634e1273f4146101d657806372ce4275146101f6575f5ffd5b8062fdd58e1461011f57806301b7037c1461014557806301ffc9a71461015a5780630504c8141461017d575b5f5ffd5b61013261012d3660046126c7565b6102df565b6040519081526020015b60405180910390f35b610158610153366004612738565b610306565b005b61016d6101683660046127b1565b61061a565b604051901515815260200161013c565b61013261018b3660046127cc565b610669565b6101a361019e3660046127ec565b610694565b60405161013c9190612850565b6101586101be36600461299d565b610726565b6101326101d13660046126c7565b61078d565b6101e96101e4366004612a4d565b61079f565b60405161013c9190612b4a565b610158610204366004612b5c565b610869565b610132610217366004612bc8565b610be8565b61013261022a366004612bfa565b610bfc565b61015861023d366004612b5c565b610c08565b610158610250366004612c30565b610f60565b610158610263366004612c67565b610f6f565b6101326102763660046127ec565b5f9081526003602052604090205490565b610158610295366004612bc8565b6111e1565b6101326102a83660046127ec565b60046020525f908152604090205481565b61016d6102c7366004612cae565b611366565b6101586102da366004612cda565b611393565b5f818152602081815260408083206001600160a01b03861684529091529020545b92915050565b5f83815260046020526040902054806103745760405162461bcd60e51b815260206004820152602560248201527f726573756c7420666f7220636f6e646974696f6e206e6f74207265636569766560448201526419081e595d60da1b60648201526084015b60405180910390fd5b5f848152600360205260409020548061039f5760405162461bcd60e51b815260040161036b90612d31565b5f806103ae600180851b612d7c565b90505f5b858110156104bb575f8787838181106103cd576103cd612d8f565b9050602002013590505f811180156103e457508281105b6104005760405162461bcd60e51b815260040161036b90612da3565b5f6104158c6104108d8d866113f2565b6116e7565b90505f805b8781101561046b576001811b841615610463575f8c815260036020526040902080548290811061044c5761044c612d8f565b905f5260205f200154826104609190612dd2565b91505b60010161041a565b505f61047733846102df565b905080156104ab578861048a8383612de5565b6104949190612e10565b61049e9088612dd2565b96506104ab33848361172e565b5050600190920191506103b29050565b5081156105bd578761059a5760405163a9059cbb60e01b8152336004820152602481018390526001600160a01b038a169063a9059cbb906044016020604051808303815f875af1158015610511573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105359190612e23565b6105955760405162461bcd60e51b815260206004820152602b60248201527f636f756c64206e6f74207472616e73666572207061796f757420746f206d657360448201526a39b0b3b29039b2b73232b960a91b606482015260840161036b565b6105bd565b6105bd336105a88b8b6116e7565b8460405180602001604052805f81525061179b565b87896001600160a01b0316336001600160a01b03167f2682012a4a4f1973119f1c9b90745d1bd91fa2bab387344f044cb3586864d18d8a8a8a886040516106079493929190612e6e565b60405180910390a4505050505050505050565b5f6001600160e01b03198216636cdb3d1360e11b148061064a57506001600160e01b031982166303a24d0760e21b145b8061030057506301ffc9a760e01b6001600160e01b0319831614610300565b6003602052815f5260405f208181548110610682575f80fd5b905f5260205f20015f91509150505481565b6060600280546106a390612e98565b80601f01602080910402602001604051908101604052809291908181526020018280546106cf90612e98565b801561071a5780601f106106f15761010080835404028352916020019161071a565b820191905f5260205f20905b8154815290600101906020018083116106fd57829003601f168201915b50505050509050919050565b336001600160a01b038616811480159061074757506107458682611366565b155b156107785760405163711bec9160e11b81526001600160a01b0380831660048301528716602482015260440161036b565b61078586868686866117f6565b505050505050565b5f61079883836116e7565b9392505050565b606081518351146107d05781518351604051635b05999160e01b81526004810192909252602482015260440161036b565b5f83516001600160401b038111156107ea576107ea612862565b604051908082528060200260200182016040528015610813578160200160208202803683370190505b5090505f5b84518110156108615760208082028601015161083c906020808402870101516102df565b82828151811061084e5761084e612d8f565b6020908102919091010152600101610818565b509392505050565b600182116108b95760405162461bcd60e51b815260206004820181905260248201527f676f7420656d707479206f722073696e676c65746f6e20706172746974696f6e604482015260640161036b565b5f84815260036020526040902054806108e45760405162461bcd60e51b815260040161036b90612d31565b5f6108f2600180841b612d7c565b9050805f856001600160401b0381111561090e5761090e612862565b604051908082528060200260200182016040528015610937578160200160208202803683370190505b5090505f866001600160401b0381111561095357610953612862565b60405190808252806020026020018201604052801561097c578160200160208202803683370190505b5090505f5b87811015610a71575f89898381811061099c5761099c612d8f565b9050602002013590505f811180156109b357508581105b6109cf5760405162461bcd60e51b815260040161036b90612da3565b8085821614610a195760405162461bcd60e51b81526020600482015260166024820152751c185c9d1a5d1a5bdb881b9bdd08191a5cda9bda5b9d60521b604482015260640161036b565b93841893610a2c8d6104108e8e856113f2565b848381518110610a3e57610a3e612d8f565b60200260200101818152505087838381518110610a5d57610a5d612d8f565b602090810291909101015250600101610981565b50825f03610b635789610b4f576040516323b872dd60e01b8152336004820152306024820152604481018790526001600160a01b038c16906323b872dd906064016020604051808303815f875af1158015610ace573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610af29190612e23565b610b4a5760405162461bcd60e51b815260206004820152602360248201527f636f756c64206e6f74207265636569766520636f6c6c61746572616c20746f6b604482015262656e7360e81b606482015260840161036b565b610b78565b610b4a33610b5d8d8d6116e7565b8861172e565b610b7833610b5d8d6104108e8e898b186113f2565b610b9233838360405180602001604052805f815250611854565b888a336001600160a01b03167f2e6bb91f8cbcda0c93623c54d0403a43514fabc40084ec96b6d5379a747862988e8c8c8c604051610bd39493929190612ed0565b60405180910390a45050505050505050505050565b5f610bf4848484611890565b949350505050565b5f610bf48484846113f2565b60018211610c585760405162461bcd60e51b815260206004820181905260248201527f676f7420656d707479206f722073696e676c65746f6e20706172746974696f6e604482015260640161036b565b5f8481526003602052604090205480610c835760405162461bcd60e51b815260040161036b90612d31565b5f610c91600180841b612d7c565b9050805f856001600160401b03811115610cad57610cad612862565b604051908082528060200260200182016040528015610cd6578160200160208202803683370190505b5090505f866001600160401b03811115610cf257610cf2612862565b604051908082528060200260200182016040528015610d1b578160200160208202803683370190505b5090505f5b87811015610e10575f898983818110610d3b57610d3b612d8f565b9050602002013590505f81118015610d5257508581105b610d6e5760405162461bcd60e51b815260040161036b90612da3565b8085821614610db85760405162461bcd60e51b81526020600482015260166024820152751c185c9d1a5d1a5bdb881b9bdd08191a5cda9bda5b9d60521b604482015260640161036b565b93841893610dcb8d6104108e8e856113f2565b848381518110610ddd57610ddd612d8f565b60200260200101818152505087838381518110610dfc57610dfc612d8f565b602090810291909101015250600101610d20565b50610e1c3383836118de565b825f03610f0a5789610ee75760405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038c169063a9059cbb906044016020604051808303815f875af1158015610e72573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e969190612e23565b610ee25760405162461bcd60e51b815260206004820181905260248201527f636f756c64206e6f742073656e6420636f6c6c61746572616c20746f6b656e73604482015260640161036b565b610f1f565b610ee233610ef58d8d6116e7565b8860405180602001604052805f81525061179b565b610f1f33610ef58d6104108e8e898b186113f2565b888a336001600160a01b03167f6f13ca62553fcc2bcd2372180a43949c1e4cebba603901ede2f4e14f36b282ca8e8c8c8c604051610bd39493929190612ed0565b610f6b338383611926565b5050565b8060018111610f905760405162461bcd60e51b815260040161036b90612ef4565b5f610f9c338684611890565b5f818152600360205260409020549091508214610ffb5760405162461bcd60e51b815260206004820152601f60248201527f636f6e646974696f6e206e6f74207072657061726564206f7220666f756e6400604482015260640161036b565b5f81815260046020526040902054156110565760405162461bcd60e51b815260206004820152601e60248201527f7061796f75742064656e6f6d696e61746f7220616c7265616479207365740000604482015260640161036b565b5f805b83811015611139575f86868381811061107457611074612d8f565b90506020020135905080836110899190612dd2565b5f858152600360205260409020805491945090839081106110ac576110ac612d8f565b905f5260205f2001545f146111035760405162461bcd60e51b815260206004820152601c60248201527f7061796f7574206e756d657261746f7220616c72656164792073657400000000604482015260640161036b565b5f84815260036020526040902080548291908490811061112557611125612d8f565b5f9182526020909120015550600101611059565b505f81116111805760405162461bcd60e51b81526020600482015260146024820152737061796f757420697320616c6c207a65726f657360601b604482015260640161036b565b5f82815260046020908152604080832084905560039091529081902090518791339185917fb44d84d3289691f71497564b85d4233648d9dbae8cbdbb4329f301c3a0185894916111d1918991612f3e565b60405180910390a4505050505050565b61010081111561122c5760405162461bcd60e51b8152602060048201526016602482015275746f6f206d616e79206f7574636f6d6520736c6f747360501b604482015260640161036b565b6001811161124c5760405162461bcd60e51b815260040161036b90612ef4565b5f611258848484611890565b5f81815260036020526040902054909150156112b65760405162461bcd60e51b815260206004820152601a60248201527f636f6e646974696f6e20616c7265616479207072657061726564000000000000604482015260640161036b565b816001600160401b038111156112ce576112ce612862565b6040519080825280602002602001820160405280156112f7578160200160208202803683370190505b505f828152600360209081526040909120825161131a9391929190910190612653565b5082846001600160a01b0316827fab3760c3bd2bb38b5bcf54dc79802ed67338b4cf29f3054ded67ed24661e41778560405161135891815260200190565b60405180910390a450505050565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205460ff1690565b336001600160a01b03861681148015906113b457506113b28682611366565b155b156113e55760405163711bec9160e11b81526001600160a01b0380831660048301528716602482015260440161036b565b61078586868686866119ba565b5f5f8383604051602001611410929190918252602082015260400190565b60408051601f198184030181529190528051602090910120905060ff81901c15155f805b5f5160206130c85f395f51905f526001850893505f5160206130c85f395f51905f5260035f5160206130c85f395f51905f5280878809870908905061147881611a46565b9150805f5160206130c85f395f51905f5283840903611434578280156114a657506114a4600283612f8e565b155b806114c45750821580156114c457506114c0600283612f8e565b6001145b156114e3576114e0825f5160206130c85f395f51905f52612d7c565b91505b8780156116be5760fe81901c151593506001600160fe1b03165f5160206130c85f395f51905f5260035f5160206130c85f395f51905f528084850984090891505f61152d83611a46565b90508480156115445750611542600282612f8e565b155b80611562575084158015611562575061155e600282612f8e565b6001145b156115815761157e815f5160206130c85f395f51905f52612d7c565b90505b825f5160206130c85f395f51905f52828309146115e05760405162461bcd60e51b815260206004820152601c60248201527f696e76616c696420706172656e7420636f6c6c656374696f6e20494400000000604482015260640161036b565b604080516020810188905290810185905260608101839052608081018290525f90819060069060a00160408051601f198184030181529082905261162391612fa1565b5f60405180830381855afa9150503d805f811461165b576040519150601f19603f3d011682016040523d82523d5f602084013e611660565b606091505b5091509150816116a15760405162461bcd60e51b815260206004820152600c60248201526b1958d859190819985a5b195960a21b604482015260640161036b565b808060200190518101906116b59190612fbc565b90985095505050505b6116c9600284612f8e565b6001036116da57600160fe1b851894505b5092979650505050505050565b6040516bffffffffffffffffffffffff19606084901b166020820152603481018290525f9060540160408051601f1981840301815291905280516020909101209392505050565b6001600160a01b03831661175657604051626a0d4560e21b81525f600482015260240161036b565b604080516001808252602082018590528183019081526060820184905260a082019092525f60808201818152919291611794918791859085906121e9565b5050505050565b6001600160a01b0384166117c457604051632bfa23e760e11b81525f600482015260240161036b565b604080516001808252602082018690528183019081526060820185905260808201909252906107855f878484876121e9565b6001600160a01b03841661181f57604051632bfa23e760e11b81525f600482015260240161036b565b6001600160a01b03851661184757604051626a0d4560e21b81525f600482015260240161036b565b61179485858585856121e9565b6001600160a01b03841661187d57604051632bfa23e760e11b81525f600482015260240161036b565b61188a5f858585856121e9565b50505050565b6040516bffffffffffffffffffffffff19606085901b16602082015260348101839052605481018290525f906074016040516020818303038152906040528051906020012090509392505050565b6001600160a01b03831661190657604051626a0d4560e21b81525f600482015260240161036b565b611921835f848460405180602001604052805f8152506121e9565b505050565b6001600160a01b03821661194e5760405162ced3e160e81b81525f600482015260240161036b565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6001600160a01b0384166119e357604051632bfa23e760e11b81525f600482015260240161036b565b6001600160a01b038516611a0b57604051626a0d4560e21b81525f600482015260240161036b565b60408051600180825260208201869052818301908152606082018590526080820190925290611a3d87878484876121e9565b50505050505050565b5f5f5160206130c85f395f51905f52808380099150808283098181820990508181840992508183850993508184840992508183840990508181820982818309905082818209905082818209905082818309915082828609945082858609915082828309915082828509935082848509915082828309915082828309915082828509915082828609945082858609915082828309915082828309915082828609915082828509935082848609945082858609915082828309915082828509935082848509915082828309905082818209905082818209905082818309915082828609945082858509935082848509915082828309915082828309915082828609945082858609915082828309915082828609915082828309915082828309915082828609915082828509935082848509915082828309905082818209905082818309905082818509905082818209905082818209905082818209905082818209905082818309915082828609945082858609915082828609915082828509935082848509915082828509915082828309915082828309905082818309905082818209838182099050838182099050838182099050838182099050838183099150508281830991508282860994508285850993508284850991508282860994508285850993508284860994508285850993508284860994508285860991508282860991508282830991508282850993508284850991508282830991508282860994508285850993508284850991508282850991508282860994508285850993508284860994508285850993508284850991508282830991508282850991508282860994508285860991508282860991508282850993508284860994508285850993508284860994508285850993508284850991508282850991508282830991508282860994508285850993508284850991508282850991508282830991508282860994508285860991508282830990508281820990508281830990508281860990508281820990508281820990508281820990508281820990508281830991508282850993508284860994508285850993508284860994508285860991508282860991508282830991508282830991508282830991508282860991508282850993508284850991508282850991508282830991508282860994508285860991508282860991508282850993508284860994508285860991508282830991508282850993508284860994508285860991508282850993508284860994508285850993508284850991508282850991508282860994508285850993508284850991508282850991508282830991508282830991508282860994508285860991508282830991508282830991508282860991508282850993508284860994508285860991508282860990508281820990508281820990508281830991508282850993508284850991508282860994508285850993508284860994508285850993508284860994508285850993508284850991508282850990508281850991508282830991508282830991508282820991505081818509935081848409925081838509935081848409925081838509935081848509905081818509905081818409925050808284099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808383099392505050565b6121f58585858561223c565b6001600160a01b03841615611794578251339060010361222e576020848101519084015161222783898985858961244b565b5050610785565b61078581878787878761256c565b805182511461226b5781518151604051635b05999160e01b81526004810192909252602482015260440161036b565b335f5b835181101561236d576020818102858101820151908501909101516001600160a01b0388161561231f575f828152602081815260408083206001600160a01b038c168452909152902054818110156122f9576040516303dee4c560e01b81526001600160a01b038a16600482015260248101829052604481018390526064810184905260840161036b565b5f838152602081815260408083206001600160a01b038d16845290915290209082900390555b6001600160a01b03871615612363575f828152602081815260408083206001600160a01b038b1684529091528120805483929061235d908490612dd2565b90915550505b505060010161226e565b5082516001036123ed5760208301515f906020840151909150856001600160a01b0316876001600160a01b0316846001600160a01b03167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f6285856040516123de929190918252602082015260400190565b60405180910390a45050611794565b836001600160a01b0316856001600160a01b0316826001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb868660405161243c929190612fde565b60405180910390a45050505050565b6001600160a01b0384163b156107855760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061248f908990899088908890889060040161300b565b6020604051808303815f875af19250505080156124c9575060408051601f3d908101601f191682019092526124c69181019061304f565b60015b612530573d8080156124f6576040519150601f19603f3d011682016040523d82523d5f602084013e6124fb565b606091505b5080515f0361252857604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b805181602001fd5b6001600160e01b0319811663f23a6e6160e01b14611a3d57604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b6001600160a01b0384163b156107855760405163bc197c8160e01b81526001600160a01b0385169063bc197c81906125b0908990899088908890889060040161306a565b6020604051808303815f875af19250505080156125ea575060408051601f3d908101601f191682019092526125e79181019061304f565b60015b612617573d8080156124f6576040519150601f19603f3d011682016040523d82523d5f602084013e6124fb565b6001600160e01b0319811663bc197c8160e01b14611a3d57604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b828054828255905f5260205f2090810192821561268c579160200282015b8281111561268c578251825591602001919060010190612671565b5061269892915061269c565b5090565b5b80821115612698575f815560010161269d565b6001600160a01b03811681146126c4575f5ffd5b50565b5f5f604083850312156126d8575f5ffd5b82356126e3816126b0565b946020939093013593505050565b5f5f83601f840112612701575f5ffd5b5081356001600160401b03811115612717575f5ffd5b6020830191508360208260051b8501011115612731575f5ffd5b9250929050565b5f5f5f5f5f6080868803121561274c575f5ffd5b8535612757816126b0565b9450602086013593506040860135925060608601356001600160401b0381111561277f575f5ffd5b61278b888289016126f1565b969995985093965092949392505050565b6001600160e01b0319811681146126c4575f5ffd5b5f602082840312156127c1575f5ffd5b81356107988161279c565b5f5f604083850312156127dd575f5ffd5b50508035926020909101359150565b5f602082840312156127fc575f5ffd5b5035919050565b5f5b8381101561281d578181015183820152602001612805565b50505f910152565b5f815180845261283c816020860160208601612803565b601f01601f19169290920160200192915050565b602081525f6107986020830184612825565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b038111828210171561289e5761289e612862565b604052919050565b5f6001600160401b038211156128be576128be612862565b5060051b60200190565b5f82601f8301126128d7575f5ffd5b81356128ea6128e5826128a6565b612876565b8082825260208201915060208360051b86010192508583111561290b575f5ffd5b602085015b83811015612928578035835260209283019201612910565b5095945050505050565b5f82601f830112612941575f5ffd5b81356001600160401b0381111561295a5761295a612862565b61296d601f8201601f1916602001612876565b818152846020838601011115612981575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f5f5f5f5f60a086880312156129b1575f5ffd5b85356129bc816126b0565b945060208601356129cc816126b0565b935060408601356001600160401b038111156129e6575f5ffd5b6129f2888289016128c8565b93505060608601356001600160401b03811115612a0d575f5ffd5b612a19888289016128c8565b92505060808601356001600160401b03811115612a34575f5ffd5b612a4088828901612932565b9150509295509295909350565b5f5f60408385031215612a5e575f5ffd5b82356001600160401b03811115612a73575f5ffd5b8301601f81018513612a83575f5ffd5b8035612a916128e5826128a6565b8082825260208201915060208360051b850101925087831115612ab2575f5ffd5b6020840193505b82841015612add578335612acc816126b0565b825260209384019390910190612ab9565b945050505060208301356001600160401b03811115612afa575f5ffd5b612b06858286016128c8565b9150509250929050565b5f8151808452602084019350602083015f5b82811015612b40578151865260209586019590910190600101612b22565b5093949350505050565b602081525f6107986020830184612b10565b5f5f5f5f5f5f60a08789031215612b71575f5ffd5b8635612b7c816126b0565b9550602087013594506040870135935060608701356001600160401b03811115612ba4575f5ffd5b612bb089828a016126f1565b979a9699509497949695608090950135949350505050565b5f5f5f60608486031215612bda575f5ffd5b8335612be5816126b0565b95602085013595506040909401359392505050565b5f5f5f60608486031215612c0c575f5ffd5b505081359360208301359350604090920135919050565b80151581146126c4575f5ffd5b5f5f60408385031215612c41575f5ffd5b8235612c4c816126b0565b91506020830135612c5c81612c23565b809150509250929050565b5f5f5f60408486031215612c79575f5ffd5b8335925060208401356001600160401b03811115612c95575f5ffd5b612ca1868287016126f1565b9497909650939450505050565b5f5f60408385031215612cbf575f5ffd5b8235612cca816126b0565b91506020830135612c5c816126b0565b5f5f5f5f5f60a08688031215612cee575f5ffd5b8535612cf9816126b0565b94506020860135612d09816126b0565b9350604086013592506060860135915060808601356001600160401b03811115612a34575f5ffd5b6020808252601a908201527f636f6e646974696f6e206e6f7420707265706172656420796574000000000000604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561030057610300612d68565b634e487b7160e01b5f52603260045260245ffd5b60208082526015908201527419dbdd081a5b9d985b1a59081a5b99195e081cd95d605a1b604082015260600190565b8082018082111561030057610300612d68565b808202811582820484141761030057610300612d68565b634e487b7160e01b5f52601260045260245ffd5b5f82612e1e57612e1e612dfc565b500490565b5f60208284031215612e33575f5ffd5b815161079881612c23565b8183525f6001600160fb1b03831115612e55575f5ffd5b8260051b80836020870137939093016020019392505050565b848152606060208201525f612e87606083018587612e3e565b905082604083015295945050505050565b600181811c90821680612eac57607f821691505b602082108103612eca57634e487b7160e01b5f52602260045260245ffd5b50919050565b6001600160a01b03851681526060602082018190525f90612e879083018587612e3e565b6020808252602a908201527f74686572652073686f756c64206265206d6f7265207468616e206f6e65206f756040820152691d18dbdb59481cdb1bdd60b21b606082015260800190565b5f6040820184835260406020840152808454808352606085019150855f5260205f2092505f5b81811015612f82578354835260019384019360209093019201612f64565b50909695505050505050565b5f82612f9c57612f9c612dfc565b500690565b5f8251612fb2818460208701612803565b9190910192915050565b5f5f60408385031215612fcd575f5ffd5b505080516020909101519092909150565b604081525f612ff06040830185612b10565b82810360208401526130028185612b10565b95945050505050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f9061304490830184612825565b979650505050505050565b5f6020828403121561305f575f5ffd5b81516107988161279c565b6001600160a01b0386811682528516602082015260a0604082018190525f9061309590830186612b10565b82810360608401526130a78186612b10565b905082810360808401526130bb8185612825565b9897505050505050505056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47a26469706673582212202b1b4d5fa7f1d62e00bc43f25a36749f8354ac2351323b8dbbd480c0e0cbf12964736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`@Qa3\x908\x03\x80a3\x90\x839\x81\x01`@\x81\x90Ra\0.\x91a\0cV[\x80a\08\x81a\0?V[PPa\x02fV[`\x02a\0K\x82\x82a\x01\xACV[PPV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\0sW__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\0\x88W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\0\x98W__\xFD[\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\0\xB1Wa\0\xB1a\0OV[`@Q`\x1F\x82\x01`\x1F\x19\x90\x81\x16`?\x01\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\0\xDFWa\0\xDFa\0OV[`@R\x81\x81R\x82\x82\x01` \x01\x86\x10\x15a\0\xF6W__\xFD[_[\x82\x81\x10\x15a\x01\x14W` \x81\x85\x01\x81\x01Q\x83\x83\x01\x82\x01R\x01a\0\xF8V[P_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a\x01<W`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a\x01ZWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x1F\x82\x11\x15a\x01\xA7W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15a\x01\x85WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x01\xA4W_\x81U`\x01\x01a\x01\x91V[PP[PPPV[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x01\xC5Wa\x01\xC5a\0OV[a\x01\xD9\x81a\x01\xD3\x84Ta\x01(V[\x84a\x01`V[` `\x1F\x82\x11`\x01\x81\x14a\x02\x0BW_\x83\x15a\x01\xF4WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x01\xA4V[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15a\x02:W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01a\x02\x1AV[P\x84\x82\x10\x15a\x02WW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[a1\x1D\x80a\x02s_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\x1BW_5`\xE0\x1C\x80c\x85,j\xE2\x11a\0\xA9W\x80c\xD4-\xC0\xC2\x11a\0nW\x80c\xD4-\xC0\xC2\x14a\x02hW\x80c\xD9n\xE7T\x14a\x02\x87W\x80c\xDD4\xDEg\x14a\x02\x9AW\x80c\xE9\x85\xE9\xC5\x14a\x02\xB9W\x80c\xF2BC*\x14a\x02\xCCW__\xFD[\x80c\x85,j\xE2\x14a\x02\tW\x80c\x85b\x96\xF7\x14a\x02\x1CW\x80c\x9Er\x12\xAD\x14a\x02/W\x80c\xA2,\xB4e\x14a\x02BW\x80c\xC4\x92\x98\xAC\x14a\x02UW__\xFD[\x80c\x0E\x894\x1C\x11a\0\xEFW\x80c\x0E\x894\x1C\x14a\x01\x90W\x80c.\xB2\xC2\xD6\x14a\x01\xB0W\x80c9\xDDu0\x14a\x01\xC3W\x80cN\x12s\xF4\x14a\x01\xD6W\x80cr\xCEBu\x14a\x01\xF6W__\xFD[\x80b\xFD\xD5\x8E\x14a\x01\x1FW\x80c\x01\xB7\x03|\x14a\x01EW\x80c\x01\xFF\xC9\xA7\x14a\x01ZW\x80c\x05\x04\xC8\x14\x14a\x01}W[__\xFD[a\x012a\x01-6`\x04a&\xC7V[a\x02\xDFV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01Xa\x01S6`\x04a'8V[a\x03\x06V[\0[a\x01ma\x01h6`\x04a'\xB1V[a\x06\x1AV[`@Q\x90\x15\x15\x81R` \x01a\x01<V[a\x012a\x01\x8B6`\x04a'\xCCV[a\x06iV[a\x01\xA3a\x01\x9E6`\x04a'\xECV[a\x06\x94V[`@Qa\x01<\x91\x90a(PV[a\x01Xa\x01\xBE6`\x04a)\x9DV[a\x07&V[a\x012a\x01\xD16`\x04a&\xC7V[a\x07\x8DV[a\x01\xE9a\x01\xE46`\x04a*MV[a\x07\x9FV[`@Qa\x01<\x91\x90a+JV[a\x01Xa\x02\x046`\x04a+\\V[a\x08iV[a\x012a\x02\x176`\x04a+\xC8V[a\x0B\xE8V[a\x012a\x02*6`\x04a+\xFAV[a\x0B\xFCV[a\x01Xa\x02=6`\x04a+\\V[a\x0C\x08V[a\x01Xa\x02P6`\x04a,0V[a\x0F`V[a\x01Xa\x02c6`\x04a,gV[a\x0FoV[a\x012a\x02v6`\x04a'\xECV[_\x90\x81R`\x03` R`@\x90 T\x90V[a\x01Xa\x02\x956`\x04a+\xC8V[a\x11\xE1V[a\x012a\x02\xA86`\x04a'\xECV[`\x04` R_\x90\x81R`@\x90 T\x81V[a\x01ma\x02\xC76`\x04a,\xAEV[a\x13fV[a\x01Xa\x02\xDA6`\x04a,\xDAV[a\x13\x93V[_\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T[\x92\x91PPV[_\x83\x81R`\x04` R`@\x90 T\x80a\x03tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`%`$\x82\x01R\x7Fresult for condition not receive`D\x82\x01Rd\x19\x08\x1EY]`\xDA\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[_\x84\x81R`\x03` R`@\x90 T\x80a\x03\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_\x80a\x03\xAE`\x01\x80\x85\x1Ba-|V[\x90P_[\x85\x81\x10\x15a\x04\xBBW_\x87\x87\x83\x81\x81\x10a\x03\xCDWa\x03\xCDa-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\x03\xE4WP\x82\x81\x10[a\x04\0W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[_a\x04\x15\x8Ca\x04\x10\x8D\x8D\x86a\x13\xF2V[a\x16\xE7V[\x90P_\x80[\x87\x81\x10\x15a\x04kW`\x01\x81\x1B\x84\x16\x15a\x04cW_\x8C\x81R`\x03` R`@\x90 \x80T\x82\x90\x81\x10a\x04LWa\x04La-\x8FV[\x90_R` _ \x01T\x82a\x04`\x91\x90a-\xD2V[\x91P[`\x01\x01a\x04\x1AV[P_a\x04w3\x84a\x02\xDFV[\x90P\x80\x15a\x04\xABW\x88a\x04\x8A\x83\x83a-\xE5V[a\x04\x94\x91\x90a.\x10V[a\x04\x9E\x90\x88a-\xD2V[\x96Pa\x04\xAB3\x84\x83a\x17.V[PP`\x01\x90\x92\x01\x91Pa\x03\xB2\x90PV[P\x81\x15a\x05\xBDW\x87a\x05\x9AW`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x8A\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x05\x11W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x055\x91\x90a.#V[a\x05\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7Fcould not transfer payout to mes`D\x82\x01Rj9\xB0\xB3\xB2\x909\xB2\xB722\xB9`\xA9\x1B`d\x82\x01R`\x84\x01a\x03kV[a\x05\xBDV[a\x05\xBD3a\x05\xA8\x8B\x8Ba\x16\xE7V[\x84`@Q\x80` \x01`@R\x80_\x81RPa\x17\x9BV[\x87\x89`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x16\x7F&\x82\x01*JO\x19s\x11\x9F\x1C\x9B\x90t]\x1B\xD9\x1F\xA2\xBA\xB3\x874O\x04L\xB3Xhd\xD1\x8D\x8A\x8A\x8A\x88`@Qa\x06\x07\x94\x93\x92\x91\x90a.nV[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cl\xDB=\x13`\xE1\x1B\x14\x80a\x06JWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x03\xA2M\x07`\xE2\x1B\x14[\x80a\x03\0WPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x03\0V[`\x03` R\x81_R`@_ \x81\x81T\x81\x10a\x06\x82W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PPT\x81V[```\x02\x80Ta\x06\xA3\x90a.\x98V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x06\xCF\x90a.\x98V[\x80\x15a\x07\x1AW\x80`\x1F\x10a\x06\xF1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x07\x1AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x06\xFDW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x91\x90PV[3`\x01`\x01`\xA0\x1B\x03\x86\x16\x81\x14\x80\x15\x90a\x07GWPa\x07E\x86\x82a\x13fV[\x15[\x15a\x07xW`@Qcq\x1B\xEC\x91`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x87\x16`$\x82\x01R`D\x01a\x03kV[a\x07\x85\x86\x86\x86\x86\x86a\x17\xF6V[PPPPPPV[_a\x07\x98\x83\x83a\x16\xE7V[\x93\x92PPPV[``\x81Q\x83Q\x14a\x07\xD0W\x81Q\x83Q`@Qc[\x05\x99\x91`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x03kV[_\x83Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07\xEAWa\x07\xEAa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\x13W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x84Q\x81\x10\x15a\x08aW` \x80\x82\x02\x86\x01\x01Qa\x08<\x90` \x80\x84\x02\x87\x01\x01Qa\x02\xDFV[\x82\x82\x81Q\x81\x10a\x08NWa\x08Na-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x08\x18V[P\x93\x92PPPV[`\x01\x82\x11a\x08\xB9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fgot empty or singleton partition`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 T\x80a\x08\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_a\x08\xF2`\x01\x80\x84\x1Ba-|V[\x90P\x80_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\t\x0EWa\t\x0Ea(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\t7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x86`\x01`\x01`@\x1B\x03\x81\x11\x15a\tSWa\tSa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\t|W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x87\x81\x10\x15a\nqW_\x89\x89\x83\x81\x81\x10a\t\x9CWa\t\x9Ca-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\t\xB3WP\x85\x81\x10[a\t\xCFW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[\x80\x85\x82\x16\x14a\n\x19W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x1C\x18\\\x9D\x1A]\x1A[\xDB\x88\x1B\x9B\xDD\x08\x19\x1A\\\xDA\x9B\xDA[\x9D`R\x1B`D\x82\x01R`d\x01a\x03kV[\x93\x84\x18\x93a\n,\x8Da\x04\x10\x8E\x8E\x85a\x13\xF2V[\x84\x83\x81Q\x81\x10a\n>Wa\n>a-\x8FV[` \x02` \x01\x01\x81\x81RPP\x87\x83\x83\x81Q\x81\x10a\n]Wa\n]a-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01RP`\x01\x01a\t\x81V[P\x82_\x03a\x0BcW\x89a\x0BOW`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x8C\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\n\xCEW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF2\x91\x90a.#V[a\x0BJW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`#`$\x82\x01R\x7Fcould not receive collateral tok`D\x82\x01Rbens`\xE8\x1B`d\x82\x01R`\x84\x01a\x03kV[a\x0BxV[a\x0BJ3a\x0B]\x8D\x8Da\x16\xE7V[\x88a\x17.V[a\x0Bx3a\x0B]\x8Da\x04\x10\x8E\x8E\x89\x8B\x18a\x13\xF2V[a\x0B\x923\x83\x83`@Q\x80` \x01`@R\x80_\x81RPa\x18TV[\x88\x8A3`\x01`\x01`\xA0\x1B\x03\x16\x7F.k\xB9\x1F\x8C\xBC\xDA\x0C\x93b<T\xD0@:CQO\xAB\xC4\0\x84\xEC\x96\xB6\xD57\x9Atxb\x98\x8E\x8C\x8C\x8C`@Qa\x0B\xD3\x94\x93\x92\x91\x90a.\xD0V[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[_a\x0B\xF4\x84\x84\x84a\x18\x90V[\x94\x93PPPPV[_a\x0B\xF4\x84\x84\x84a\x13\xF2V[`\x01\x82\x11a\x0CXW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fgot empty or singleton partition`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 T\x80a\x0C\x83W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_a\x0C\x91`\x01\x80\x84\x1Ba-|V[\x90P\x80_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xADWa\x0C\xADa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\xD6W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x86`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xF2Wa\x0C\xF2a(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\r\x1BW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x87\x81\x10\x15a\x0E\x10W_\x89\x89\x83\x81\x81\x10a\r;Wa\r;a-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\rRWP\x85\x81\x10[a\rnW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[\x80\x85\x82\x16\x14a\r\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x1C\x18\\\x9D\x1A]\x1A[\xDB\x88\x1B\x9B\xDD\x08\x19\x1A\\\xDA\x9B\xDA[\x9D`R\x1B`D\x82\x01R`d\x01a\x03kV[\x93\x84\x18\x93a\r\xCB\x8Da\x04\x10\x8E\x8E\x85a\x13\xF2V[\x84\x83\x81Q\x81\x10a\r\xDDWa\r\xDDa-\x8FV[` \x02` \x01\x01\x81\x81RPP\x87\x83\x83\x81Q\x81\x10a\r\xFCWa\r\xFCa-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01RP`\x01\x01a\r V[Pa\x0E\x1C3\x83\x83a\x18\xDEV[\x82_\x03a\x0F\nW\x89a\x0E\xE7W`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x8C\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0ErW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E\x96\x91\x90a.#V[a\x0E\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fcould not send collateral tokens`D\x82\x01R`d\x01a\x03kV[a\x0F\x1FV[a\x0E\xE23a\x0E\xF5\x8D\x8Da\x16\xE7V[\x88`@Q\x80` \x01`@R\x80_\x81RPa\x17\x9BV[a\x0F\x1F3a\x0E\xF5\x8Da\x04\x10\x8E\x8E\x89\x8B\x18a\x13\xF2V[\x88\x8A3`\x01`\x01`\xA0\x1B\x03\x16\x7Fo\x13\xCAbU?\xCC+\xCD#r\x18\nC\x94\x9C\x1EL\xEB\xBA`9\x01\xED\xE2\xF4\xE1O6\xB2\x82\xCA\x8E\x8C\x8C\x8C`@Qa\x0B\xD3\x94\x93\x92\x91\x90a.\xD0V[a\x0Fk3\x83\x83a\x19&V[PPV[\x80`\x01\x81\x11a\x0F\x90W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a.\xF4V[_a\x0F\x9C3\x86\x84a\x18\x90V[_\x81\x81R`\x03` R`@\x90 T\x90\x91P\x82\x14a\x0F\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7Fcondition not prepared or found\0`D\x82\x01R`d\x01a\x03kV[_\x81\x81R`\x04` R`@\x90 T\x15a\x10VW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7Fpayout denominator already set\0\0`D\x82\x01R`d\x01a\x03kV[_\x80[\x83\x81\x10\x15a\x119W_\x86\x86\x83\x81\x81\x10a\x10tWa\x10ta-\x8FV[\x90P` \x02\x015\x90P\x80\x83a\x10\x89\x91\x90a-\xD2V[_\x85\x81R`\x03` R`@\x90 \x80T\x91\x94P\x90\x83\x90\x81\x10a\x10\xACWa\x10\xACa-\x8FV[\x90_R` _ \x01T_\x14a\x11\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fpayout numerator already set\0\0\0\0`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 \x80T\x82\x91\x90\x84\x90\x81\x10a\x11%Wa\x11%a-\x8FV[_\x91\x82R` \x90\x91 \x01UP`\x01\x01a\x10YV[P_\x81\x11a\x11\x80W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rspayout is all zeroes``\x1B`D\x82\x01R`d\x01a\x03kV[_\x82\x81R`\x04` \x90\x81R`@\x80\x83 \x84\x90U`\x03\x90\x91R\x90\x81\x90 \x90Q\x87\x913\x91\x85\x91\x7F\xB4M\x84\xD3(\x96\x91\xF7\x14\x97VK\x85\xD4#6H\xD9\xDB\xAE\x8C\xBD\xBBC)\xF3\x01\xC3\xA0\x18X\x94\x91a\x11\xD1\x91\x89\x91a/>V[`@Q\x80\x91\x03\x90\xA4PPPPPPV[a\x01\0\x81\x11\x15a\x12,W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Rutoo many outcome slots`P\x1B`D\x82\x01R`d\x01a\x03kV[`\x01\x81\x11a\x12LW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a.\xF4V[_a\x12X\x84\x84\x84a\x18\x90V[_\x81\x81R`\x03` R`@\x90 T\x90\x91P\x15a\x12\xB6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7Fcondition already prepared\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03kV[\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\xCEWa\x12\xCEa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x12\xF7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P_\x82\x81R`\x03` \x90\x81R`@\x90\x91 \x82Qa\x13\x1A\x93\x91\x92\x91\x90\x91\x01\x90a&SV[P\x82\x84`\x01`\x01`\xA0\x1B\x03\x16\x82\x7F\xAB7`\xC3\xBD+\xB3\x8B[\xCFT\xDCy\x80.\xD6s8\xB4\xCF)\xF3\x05M\xEDg\xED$f\x1EAw\x85`@Qa\x13X\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA4PPPPV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x01` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[3`\x01`\x01`\xA0\x1B\x03\x86\x16\x81\x14\x80\x15\x90a\x13\xB4WPa\x13\xB2\x86\x82a\x13fV[\x15[\x15a\x13\xE5W`@Qcq\x1B\xEC\x91`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x87\x16`$\x82\x01R`D\x01a\x03kV[a\x07\x85\x86\x86\x86\x86\x86a\x19\xBAV[__\x83\x83`@Q` \x01a\x14\x10\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P`\xFF\x81\x90\x1C\x15\x15_\x80[_Q` a0\xC8_9_Q\x90_R`\x01\x85\x08\x93P_Q` a0\xC8_9_Q\x90_R`\x03_Q` a0\xC8_9_Q\x90_R\x80\x87\x88\t\x87\t\x08\x90Pa\x14x\x81a\x1AFV[\x91P\x80_Q` a0\xC8_9_Q\x90_R\x83\x84\t\x03a\x144W\x82\x80\x15a\x14\xA6WPa\x14\xA4`\x02\x83a/\x8EV[\x15[\x80a\x14\xC4WP\x82\x15\x80\x15a\x14\xC4WPa\x14\xC0`\x02\x83a/\x8EV[`\x01\x14[\x15a\x14\xE3Wa\x14\xE0\x82_Q` a0\xC8_9_Q\x90_Ra-|V[\x91P[\x87\x80\x15a\x16\xBEW`\xFE\x81\x90\x1C\x15\x15\x93P`\x01`\x01`\xFE\x1B\x03\x16_Q` a0\xC8_9_Q\x90_R`\x03_Q` a0\xC8_9_Q\x90_R\x80\x84\x85\t\x84\t\x08\x91P_a\x15-\x83a\x1AFV[\x90P\x84\x80\x15a\x15DWPa\x15B`\x02\x82a/\x8EV[\x15[\x80a\x15bWP\x84\x15\x80\x15a\x15bWPa\x15^`\x02\x82a/\x8EV[`\x01\x14[\x15a\x15\x81Wa\x15~\x81_Q` a0\xC8_9_Q\x90_Ra-|V[\x90P[\x82_Q` a0\xC8_9_Q\x90_R\x82\x83\t\x14a\x15\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Finvalid parent collection ID\0\0\0\0`D\x82\x01R`d\x01a\x03kV[`@\x80Q` \x81\x01\x88\x90R\x90\x81\x01\x85\x90R``\x81\x01\x83\x90R`\x80\x81\x01\x82\x90R_\x90\x81\x90`\x06\x90`\xA0\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x16#\x91a/\xA1V[_`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80_\x81\x14a\x16[W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x16`V[``\x91P[P\x91P\x91P\x81a\x16\xA1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01Rk\x19X\xD8Y\x19\x08\x19\x98Z[\x19Y`\xA2\x1B`D\x82\x01R`d\x01a\x03kV[\x80\x80` \x01\x90Q\x81\x01\x90a\x16\xB5\x91\x90a/\xBCV[\x90\x98P\x95PPPP[a\x16\xC9`\x02\x84a/\x8EV[`\x01\x03a\x16\xDAW`\x01`\xFE\x1B\x85\x18\x94P[P\x92\x97\x96PPPPPPPV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x84\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R_\x90`T\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x17VW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x85\x90R\x81\x83\x01\x90\x81R``\x82\x01\x84\x90R`\xA0\x82\x01\x90\x92R_`\x80\x82\x01\x81\x81R\x91\x92\x91a\x17\x94\x91\x87\x91\x85\x90\x85\x90a!\xE9V[PPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x17\xC4W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x86\x90R\x81\x83\x01\x90\x81R``\x82\x01\x85\x90R`\x80\x82\x01\x90\x92R\x90a\x07\x85_\x87\x84\x84\x87a!\xE9V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18\x1FW`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x18GW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x17\x94\x85\x85\x85\x85\x85a!\xE9V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18}W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x18\x8A_\x85\x85\x85\x85a!\xE9V[PPPPV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x85\x90\x1B\x16` \x82\x01R`4\x81\x01\x83\x90R`T\x81\x01\x82\x90R_\x90`t\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x19\x06W`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x19!\x83_\x84\x84`@Q\x80` \x01`@R\x80_\x81RPa!\xE9V[PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x19NW`@Qb\xCE\xD3\xE1`\xE8\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x01` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x19\xE3W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x1A\x0BW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x86\x90R\x81\x83\x01\x90\x81R``\x82\x01\x85\x90R`\x80\x82\x01\x90\x92R\x90a\x1A=\x87\x87\x84\x84\x87a!\xE9V[PPPPPPPV[__Q` a0\xC8_9_Q\x90_R\x80\x83\x80\t\x91P\x80\x82\x83\t\x81\x81\x82\t\x90P\x81\x81\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x84\t\x90P\x81\x81\x82\t\x82\x81\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x90P\x82\x81\x85\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x90P\x82\x81\x83\t\x90P\x82\x81\x82\t\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x83\t\x91PP\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x90P\x82\x81\x86\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x90P\x82\x81\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x82\t\x91PP\x81\x81\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x85\t\x90P\x81\x81\x85\t\x90P\x81\x81\x84\t\x92PP\x80\x82\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x83\t\x93\x92PPPV[a!\xF5\x85\x85\x85\x85a\"<V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x17\x94W\x82Q3\x90`\x01\x03a\".W` \x84\x81\x01Q\x90\x84\x01Qa\"'\x83\x89\x89\x85\x85\x89a$KV[PPa\x07\x85V[a\x07\x85\x81\x87\x87\x87\x87\x87a%lV[\x80Q\x82Q\x14a\"kW\x81Q\x81Q`@Qc[\x05\x99\x91`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x03kV[3_[\x83Q\x81\x10\x15a#mW` \x81\x81\x02\x85\x81\x01\x82\x01Q\x90\x85\x01\x90\x91\x01Q`\x01`\x01`\xA0\x1B\x03\x88\x16\x15a#\x1FW_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8C\x16\x84R\x90\x91R\x90 T\x81\x81\x10\x15a\"\xF9W`@Qc\x03\xDE\xE4\xC5`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8A\x16`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x81\x01\x83\x90R`d\x81\x01\x84\x90R`\x84\x01a\x03kV[_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8D\x16\x84R\x90\x91R\x90 \x90\x82\x90\x03\x90U[`\x01`\x01`\xA0\x1B\x03\x87\x16\x15a#cW_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8B\x16\x84R\x90\x91R\x81 \x80T\x83\x92\x90a#]\x90\x84\x90a-\xD2V[\x90\x91UPP[PP`\x01\x01a\"nV[P\x82Q`\x01\x03a#\xEDW` \x83\x01Q_\x90` \x84\x01Q\x90\x91P\x85`\x01`\x01`\xA0\x1B\x03\x16\x87`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x7F\xC3\xD5\x81h\xC5\xAEs\x97s\x1D\x06=[\xBF=exTBsC\xF4\xC0\x83$\x0Fz\xAC\xAA-\x0Fb\x85\x85`@Qa#\xDE\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA4PPa\x17\x94V[\x83`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x7FJ9\xDC\x06\xD4\xC0\xDB\xC6Kp\xAF\x90\xFDi\x8A#:Q\x8A\xA5\xD0~Y]\x98;\x8C\x05&\xC8\xF7\xFB\x86\x86`@Qa$<\x92\x91\x90a/\xDEV[`@Q\x80\x91\x03\x90\xA4PPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x07\x85W`@Qc\xF2:na`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xF2:na\x90a$\x8F\x90\x89\x90\x89\x90\x88\x90\x88\x90\x88\x90`\x04\x01a0\x0BV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a$\xC9WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra$\xC6\x91\x81\x01\x90a0OV[`\x01[a%0W=\x80\x80\x15a$\xF6W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a$\xFBV[``\x91P[P\x80Q_\x03a%(W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16c\xF2:na`\xE0\x1B\x14a\x1A=W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x07\x85W`@Qc\xBC\x19|\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xBC\x19|\x81\x90a%\xB0\x90\x89\x90\x89\x90\x88\x90\x88\x90\x88\x90`\x04\x01a0jV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a%\xEAWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra%\xE7\x91\x81\x01\x90a0OV[`\x01[a&\x17W=\x80\x80\x15a$\xF6W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a$\xFBV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16c\xBC\x19|\x81`\xE0\x1B\x14a\x1A=W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a&\x8CW\x91` \x02\x82\x01[\x82\x81\x11\x15a&\x8CW\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a&qV[Pa&\x98\x92\x91Pa&\x9CV[P\x90V[[\x80\x82\x11\x15a&\x98W_\x81U`\x01\x01a&\x9DV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a&\xC4W__\xFD[PV[__`@\x83\x85\x03\x12\x15a&\xD8W__\xFD[\x825a&\xE3\x81a&\xB0V[\x94` \x93\x90\x93\x015\x93PPPV[__\x83`\x1F\x84\x01\x12a'\x01W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x17W__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a'1W__\xFD[\x92P\x92\x90PV[_____`\x80\x86\x88\x03\x12\x15a'LW__\xFD[\x855a'W\x81a&\xB0V[\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x7FW__\xFD[a'\x8B\x88\x82\x89\x01a&\xF1V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a&\xC4W__\xFD[_` \x82\x84\x03\x12\x15a'\xC1W__\xFD[\x815a\x07\x98\x81a'\x9CV[__`@\x83\x85\x03\x12\x15a'\xDDW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a'\xFCW__\xFD[P5\x91\x90PV[_[\x83\x81\x10\x15a(\x1DW\x81\x81\x01Q\x83\x82\x01R` \x01a(\x05V[PP_\x91\x01RV[_\x81Q\x80\x84Ra(<\x81` \x86\x01` \x86\x01a(\x03V[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R_a\x07\x98` \x83\x01\x84a(%V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a(\x9EWa(\x9Ea(bV[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15a(\xBEWa(\xBEa(bV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a(\xD7W__\xFD[\x815a(\xEAa(\xE5\x82a(\xA6V[a(vV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a)\x0BW__\xFD[` \x85\x01[\x83\x81\x10\x15a)(W\x805\x83R` \x92\x83\x01\x92\x01a)\x10V[P\x95\x94PPPPPV[_\x82`\x1F\x83\x01\x12a)AW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a)ZWa)Za(bV[a)m`\x1F\x82\x01`\x1F\x19\x16` \x01a(vV[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a)\x81W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a)\xB1W__\xFD[\x855a)\xBC\x81a&\xB0V[\x94P` \x86\x015a)\xCC\x81a&\xB0V[\x93P`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)\xE6W__\xFD[a)\xF2\x88\x82\x89\x01a(\xC8V[\x93PP``\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\rW__\xFD[a*\x19\x88\x82\x89\x01a(\xC8V[\x92PP`\x80\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*4W__\xFD[a*@\x88\x82\x89\x01a)2V[\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15a*^W__\xFD[\x825`\x01`\x01`@\x1B\x03\x81\x11\x15a*sW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a*\x83W__\xFD[\x805a*\x91a(\xE5\x82a(\xA6V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a*\xB2W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a*\xDDW\x835a*\xCC\x81a&\xB0V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a*\xB9V[\x94PPPP` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\xFAW__\xFD[a+\x06\x85\x82\x86\x01a(\xC8V[\x91PP\x92P\x92\x90PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+@W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a+\"V[P\x93\x94\x93PPPPV[` \x81R_a\x07\x98` \x83\x01\x84a+\x10V[______`\xA0\x87\x89\x03\x12\x15a+qW__\xFD[\x865a+|\x81a&\xB0V[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a+\xA4W__\xFD[a+\xB0\x89\x82\x8A\x01a&\xF1V[\x97\x9A\x96\x99P\x94\x97\x94\x96\x95`\x80\x90\x95\x015\x94\x93PPPPV[___``\x84\x86\x03\x12\x15a+\xDAW__\xFD[\x835a+\xE5\x81a&\xB0V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[___``\x84\x86\x03\x12\x15a,\x0CW__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[\x80\x15\x15\x81\x14a&\xC4W__\xFD[__`@\x83\x85\x03\x12\x15a,AW__\xFD[\x825a,L\x81a&\xB0V[\x91P` \x83\x015a,\\\x81a,#V[\x80\x91PP\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a,yW__\xFD[\x835\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a,\x95W__\xFD[a,\xA1\x86\x82\x87\x01a&\xF1V[\x94\x97\x90\x96P\x93\x94PPPPV[__`@\x83\x85\x03\x12\x15a,\xBFW__\xFD[\x825a,\xCA\x81a&\xB0V[\x91P` \x83\x015a,\\\x81a&\xB0V[_____`\xA0\x86\x88\x03\x12\x15a,\xEEW__\xFD[\x855a,\xF9\x81a&\xB0V[\x94P` \x86\x015a-\t\x81a&\xB0V[\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*4W__\xFD[` \x80\x82R`\x1A\x90\x82\x01R\x7Fcondition not prepared yet\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x03\0Wa\x03\0a-hV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[` \x80\x82R`\x15\x90\x82\x01Rt\x19\xDB\xDD\x08\x1A[\x9D\x98[\x1AY\x08\x1A[\x99\x19^\x08\x1C\xD9]`Z\x1B`@\x82\x01R``\x01\x90V[\x80\x82\x01\x80\x82\x11\x15a\x03\0Wa\x03\0a-hV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\0Wa\x03\0a-hV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a.\x1EWa.\x1Ea-\xFCV[P\x04\x90V[_` \x82\x84\x03\x12\x15a.3W__\xFD[\x81Qa\x07\x98\x81a,#V[\x81\x83R_`\x01`\x01`\xFB\x1B\x03\x83\x11\x15a.UW__\xFD[\x82`\x05\x1B\x80\x83` \x87\x017\x93\x90\x93\x01` \x01\x93\x92PPPV[\x84\x81R``` \x82\x01R_a.\x87``\x83\x01\x85\x87a.>V[\x90P\x82`@\x83\x01R\x95\x94PPPPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a.\xACW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a.\xCAWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R``` \x82\x01\x81\x90R_\x90a.\x87\x90\x83\x01\x85\x87a.>V[` \x80\x82R`*\x90\x82\x01R\x7Fthere should be more than one ou`@\x82\x01Ri\x1D\x18\xDB\xDBYH\x1C\xDB\x1B\xDD`\xB2\x1B``\x82\x01R`\x80\x01\x90V[_`@\x82\x01\x84\x83R`@` \x84\x01R\x80\x84T\x80\x83R``\x85\x01\x91P\x85_R` _ \x92P_[\x81\x81\x10\x15a/\x82W\x83T\x83R`\x01\x93\x84\x01\x93` \x90\x93\x01\x92\x01a/dV[P\x90\x96\x95PPPPPPV[_\x82a/\x9CWa/\x9Ca-\xFCV[P\x06\x90V[_\x82Qa/\xB2\x81\x84` \x87\x01a(\x03V[\x91\x90\x91\x01\x92\x91PPV[__`@\x83\x85\x03\x12\x15a/\xCDW__\xFD[PP\x80Q` \x90\x91\x01Q\x90\x92\x90\x91PV[`@\x81R_a/\xF0`@\x83\x01\x85a+\x10V[\x82\x81\x03` \x84\x01Ra0\x02\x81\x85a+\x10V[\x95\x94PPPPPV[`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x82R\x85\x16` \x82\x01R`@\x81\x01\x84\x90R``\x81\x01\x83\x90R`\xA0`\x80\x82\x01\x81\x90R_\x90a0D\x90\x83\x01\x84a(%V[\x97\x96PPPPPPPV[_` \x82\x84\x03\x12\x15a0_W__\xFD[\x81Qa\x07\x98\x81a'\x9CV[`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x82R\x85\x16` \x82\x01R`\xA0`@\x82\x01\x81\x90R_\x90a0\x95\x90\x83\x01\x86a+\x10V[\x82\x81\x03``\x84\x01Ra0\xA7\x81\x86a+\x10V[\x90P\x82\x81\x03`\x80\x84\x01Ra0\xBB\x81\x85a(%V[\x98\x97PPPPPPPPV\xFE0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\xA2dipfsX\"\x12 +\x1BM_\xA7\xF1\xD6.\0\xBCC\xF2Z6t\x9F\x83T\xAC#Q2;\x8D\xBB\xD4\x80\xC0\xE0\xCB\xF1)dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b506004361061011b575f3560e01c8063852c6ae2116100a9578063d42dc0c21161006e578063d42dc0c214610268578063d96ee75414610287578063dd34de671461029a578063e985e9c5146102b9578063f242432a146102cc575f5ffd5b8063852c6ae214610209578063856296f71461021c5780639e7212ad1461022f578063a22cb46514610242578063c49298ac14610255575f5ffd5b80630e89341c116100ef5780630e89341c146101905780632eb2c2d6146101b057806339dd7530146101c35780634e1273f4146101d657806372ce4275146101f6575f5ffd5b8062fdd58e1461011f57806301b7037c1461014557806301ffc9a71461015a5780630504c8141461017d575b5f5ffd5b61013261012d3660046126c7565b6102df565b6040519081526020015b60405180910390f35b610158610153366004612738565b610306565b005b61016d6101683660046127b1565b61061a565b604051901515815260200161013c565b61013261018b3660046127cc565b610669565b6101a361019e3660046127ec565b610694565b60405161013c9190612850565b6101586101be36600461299d565b610726565b6101326101d13660046126c7565b61078d565b6101e96101e4366004612a4d565b61079f565b60405161013c9190612b4a565b610158610204366004612b5c565b610869565b610132610217366004612bc8565b610be8565b61013261022a366004612bfa565b610bfc565b61015861023d366004612b5c565b610c08565b610158610250366004612c30565b610f60565b610158610263366004612c67565b610f6f565b6101326102763660046127ec565b5f9081526003602052604090205490565b610158610295366004612bc8565b6111e1565b6101326102a83660046127ec565b60046020525f908152604090205481565b61016d6102c7366004612cae565b611366565b6101586102da366004612cda565b611393565b5f818152602081815260408083206001600160a01b03861684529091529020545b92915050565b5f83815260046020526040902054806103745760405162461bcd60e51b815260206004820152602560248201527f726573756c7420666f7220636f6e646974696f6e206e6f74207265636569766560448201526419081e595d60da1b60648201526084015b60405180910390fd5b5f848152600360205260409020548061039f5760405162461bcd60e51b815260040161036b90612d31565b5f806103ae600180851b612d7c565b90505f5b858110156104bb575f8787838181106103cd576103cd612d8f565b9050602002013590505f811180156103e457508281105b6104005760405162461bcd60e51b815260040161036b90612da3565b5f6104158c6104108d8d866113f2565b6116e7565b90505f805b8781101561046b576001811b841615610463575f8c815260036020526040902080548290811061044c5761044c612d8f565b905f5260205f200154826104609190612dd2565b91505b60010161041a565b505f61047733846102df565b905080156104ab578861048a8383612de5565b6104949190612e10565b61049e9088612dd2565b96506104ab33848361172e565b5050600190920191506103b29050565b5081156105bd578761059a5760405163a9059cbb60e01b8152336004820152602481018390526001600160a01b038a169063a9059cbb906044016020604051808303815f875af1158015610511573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105359190612e23565b6105955760405162461bcd60e51b815260206004820152602b60248201527f636f756c64206e6f74207472616e73666572207061796f757420746f206d657360448201526a39b0b3b29039b2b73232b960a91b606482015260840161036b565b6105bd565b6105bd336105a88b8b6116e7565b8460405180602001604052805f81525061179b565b87896001600160a01b0316336001600160a01b03167f2682012a4a4f1973119f1c9b90745d1bd91fa2bab387344f044cb3586864d18d8a8a8a886040516106079493929190612e6e565b60405180910390a4505050505050505050565b5f6001600160e01b03198216636cdb3d1360e11b148061064a57506001600160e01b031982166303a24d0760e21b145b8061030057506301ffc9a760e01b6001600160e01b0319831614610300565b6003602052815f5260405f208181548110610682575f80fd5b905f5260205f20015f91509150505481565b6060600280546106a390612e98565b80601f01602080910402602001604051908101604052809291908181526020018280546106cf90612e98565b801561071a5780601f106106f15761010080835404028352916020019161071a565b820191905f5260205f20905b8154815290600101906020018083116106fd57829003601f168201915b50505050509050919050565b336001600160a01b038616811480159061074757506107458682611366565b155b156107785760405163711bec9160e11b81526001600160a01b0380831660048301528716602482015260440161036b565b61078586868686866117f6565b505050505050565b5f61079883836116e7565b9392505050565b606081518351146107d05781518351604051635b05999160e01b81526004810192909252602482015260440161036b565b5f83516001600160401b038111156107ea576107ea612862565b604051908082528060200260200182016040528015610813578160200160208202803683370190505b5090505f5b84518110156108615760208082028601015161083c906020808402870101516102df565b82828151811061084e5761084e612d8f565b6020908102919091010152600101610818565b509392505050565b600182116108b95760405162461bcd60e51b815260206004820181905260248201527f676f7420656d707479206f722073696e676c65746f6e20706172746974696f6e604482015260640161036b565b5f84815260036020526040902054806108e45760405162461bcd60e51b815260040161036b90612d31565b5f6108f2600180841b612d7c565b9050805f856001600160401b0381111561090e5761090e612862565b604051908082528060200260200182016040528015610937578160200160208202803683370190505b5090505f866001600160401b0381111561095357610953612862565b60405190808252806020026020018201604052801561097c578160200160208202803683370190505b5090505f5b87811015610a71575f89898381811061099c5761099c612d8f565b9050602002013590505f811180156109b357508581105b6109cf5760405162461bcd60e51b815260040161036b90612da3565b8085821614610a195760405162461bcd60e51b81526020600482015260166024820152751c185c9d1a5d1a5bdb881b9bdd08191a5cda9bda5b9d60521b604482015260640161036b565b93841893610a2c8d6104108e8e856113f2565b848381518110610a3e57610a3e612d8f565b60200260200101818152505087838381518110610a5d57610a5d612d8f565b602090810291909101015250600101610981565b50825f03610b635789610b4f576040516323b872dd60e01b8152336004820152306024820152604481018790526001600160a01b038c16906323b872dd906064016020604051808303815f875af1158015610ace573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610af29190612e23565b610b4a5760405162461bcd60e51b815260206004820152602360248201527f636f756c64206e6f74207265636569766520636f6c6c61746572616c20746f6b604482015262656e7360e81b606482015260840161036b565b610b78565b610b4a33610b5d8d8d6116e7565b8861172e565b610b7833610b5d8d6104108e8e898b186113f2565b610b9233838360405180602001604052805f815250611854565b888a336001600160a01b03167f2e6bb91f8cbcda0c93623c54d0403a43514fabc40084ec96b6d5379a747862988e8c8c8c604051610bd39493929190612ed0565b60405180910390a45050505050505050505050565b5f610bf4848484611890565b949350505050565b5f610bf48484846113f2565b60018211610c585760405162461bcd60e51b815260206004820181905260248201527f676f7420656d707479206f722073696e676c65746f6e20706172746974696f6e604482015260640161036b565b5f8481526003602052604090205480610c835760405162461bcd60e51b815260040161036b90612d31565b5f610c91600180841b612d7c565b9050805f856001600160401b03811115610cad57610cad612862565b604051908082528060200260200182016040528015610cd6578160200160208202803683370190505b5090505f866001600160401b03811115610cf257610cf2612862565b604051908082528060200260200182016040528015610d1b578160200160208202803683370190505b5090505f5b87811015610e10575f898983818110610d3b57610d3b612d8f565b9050602002013590505f81118015610d5257508581105b610d6e5760405162461bcd60e51b815260040161036b90612da3565b8085821614610db85760405162461bcd60e51b81526020600482015260166024820152751c185c9d1a5d1a5bdb881b9bdd08191a5cda9bda5b9d60521b604482015260640161036b565b93841893610dcb8d6104108e8e856113f2565b848381518110610ddd57610ddd612d8f565b60200260200101818152505087838381518110610dfc57610dfc612d8f565b602090810291909101015250600101610d20565b50610e1c3383836118de565b825f03610f0a5789610ee75760405163a9059cbb60e01b8152336004820152602481018790526001600160a01b038c169063a9059cbb906044016020604051808303815f875af1158015610e72573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610e969190612e23565b610ee25760405162461bcd60e51b815260206004820181905260248201527f636f756c64206e6f742073656e6420636f6c6c61746572616c20746f6b656e73604482015260640161036b565b610f1f565b610ee233610ef58d8d6116e7565b8860405180602001604052805f81525061179b565b610f1f33610ef58d6104108e8e898b186113f2565b888a336001600160a01b03167f6f13ca62553fcc2bcd2372180a43949c1e4cebba603901ede2f4e14f36b282ca8e8c8c8c604051610bd39493929190612ed0565b610f6b338383611926565b5050565b8060018111610f905760405162461bcd60e51b815260040161036b90612ef4565b5f610f9c338684611890565b5f818152600360205260409020549091508214610ffb5760405162461bcd60e51b815260206004820152601f60248201527f636f6e646974696f6e206e6f74207072657061726564206f7220666f756e6400604482015260640161036b565b5f81815260046020526040902054156110565760405162461bcd60e51b815260206004820152601e60248201527f7061796f75742064656e6f6d696e61746f7220616c7265616479207365740000604482015260640161036b565b5f805b83811015611139575f86868381811061107457611074612d8f565b90506020020135905080836110899190612dd2565b5f858152600360205260409020805491945090839081106110ac576110ac612d8f565b905f5260205f2001545f146111035760405162461bcd60e51b815260206004820152601c60248201527f7061796f7574206e756d657261746f7220616c72656164792073657400000000604482015260640161036b565b5f84815260036020526040902080548291908490811061112557611125612d8f565b5f9182526020909120015550600101611059565b505f81116111805760405162461bcd60e51b81526020600482015260146024820152737061796f757420697320616c6c207a65726f657360601b604482015260640161036b565b5f82815260046020908152604080832084905560039091529081902090518791339185917fb44d84d3289691f71497564b85d4233648d9dbae8cbdbb4329f301c3a0185894916111d1918991612f3e565b60405180910390a4505050505050565b61010081111561122c5760405162461bcd60e51b8152602060048201526016602482015275746f6f206d616e79206f7574636f6d6520736c6f747360501b604482015260640161036b565b6001811161124c5760405162461bcd60e51b815260040161036b90612ef4565b5f611258848484611890565b5f81815260036020526040902054909150156112b65760405162461bcd60e51b815260206004820152601a60248201527f636f6e646974696f6e20616c7265616479207072657061726564000000000000604482015260640161036b565b816001600160401b038111156112ce576112ce612862565b6040519080825280602002602001820160405280156112f7578160200160208202803683370190505b505f828152600360209081526040909120825161131a9391929190910190612653565b5082846001600160a01b0316827fab3760c3bd2bb38b5bcf54dc79802ed67338b4cf29f3054ded67ed24661e41778560405161135891815260200190565b60405180910390a450505050565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205460ff1690565b336001600160a01b03861681148015906113b457506113b28682611366565b155b156113e55760405163711bec9160e11b81526001600160a01b0380831660048301528716602482015260440161036b565b61078586868686866119ba565b5f5f8383604051602001611410929190918252602082015260400190565b60408051601f198184030181529190528051602090910120905060ff81901c15155f805b5f5160206130c85f395f51905f526001850893505f5160206130c85f395f51905f5260035f5160206130c85f395f51905f5280878809870908905061147881611a46565b9150805f5160206130c85f395f51905f5283840903611434578280156114a657506114a4600283612f8e565b155b806114c45750821580156114c457506114c0600283612f8e565b6001145b156114e3576114e0825f5160206130c85f395f51905f52612d7c565b91505b8780156116be5760fe81901c151593506001600160fe1b03165f5160206130c85f395f51905f5260035f5160206130c85f395f51905f528084850984090891505f61152d83611a46565b90508480156115445750611542600282612f8e565b155b80611562575084158015611562575061155e600282612f8e565b6001145b156115815761157e815f5160206130c85f395f51905f52612d7c565b90505b825f5160206130c85f395f51905f52828309146115e05760405162461bcd60e51b815260206004820152601c60248201527f696e76616c696420706172656e7420636f6c6c656374696f6e20494400000000604482015260640161036b565b604080516020810188905290810185905260608101839052608081018290525f90819060069060a00160408051601f198184030181529082905261162391612fa1565b5f60405180830381855afa9150503d805f811461165b576040519150601f19603f3d011682016040523d82523d5f602084013e611660565b606091505b5091509150816116a15760405162461bcd60e51b815260206004820152600c60248201526b1958d859190819985a5b195960a21b604482015260640161036b565b808060200190518101906116b59190612fbc565b90985095505050505b6116c9600284612f8e565b6001036116da57600160fe1b851894505b5092979650505050505050565b6040516bffffffffffffffffffffffff19606084901b166020820152603481018290525f9060540160408051601f1981840301815291905280516020909101209392505050565b6001600160a01b03831661175657604051626a0d4560e21b81525f600482015260240161036b565b604080516001808252602082018590528183019081526060820184905260a082019092525f60808201818152919291611794918791859085906121e9565b5050505050565b6001600160a01b0384166117c457604051632bfa23e760e11b81525f600482015260240161036b565b604080516001808252602082018690528183019081526060820185905260808201909252906107855f878484876121e9565b6001600160a01b03841661181f57604051632bfa23e760e11b81525f600482015260240161036b565b6001600160a01b03851661184757604051626a0d4560e21b81525f600482015260240161036b565b61179485858585856121e9565b6001600160a01b03841661187d57604051632bfa23e760e11b81525f600482015260240161036b565b61188a5f858585856121e9565b50505050565b6040516bffffffffffffffffffffffff19606085901b16602082015260348101839052605481018290525f906074016040516020818303038152906040528051906020012090509392505050565b6001600160a01b03831661190657604051626a0d4560e21b81525f600482015260240161036b565b611921835f848460405180602001604052805f8152506121e9565b505050565b6001600160a01b03821661194e5760405162ced3e160e81b81525f600482015260240161036b565b6001600160a01b038381165f81815260016020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b6001600160a01b0384166119e357604051632bfa23e760e11b81525f600482015260240161036b565b6001600160a01b038516611a0b57604051626a0d4560e21b81525f600482015260240161036b565b60408051600180825260208201869052818301908152606082018590526080820190925290611a3d87878484876121e9565b50505050505050565b5f5f5160206130c85f395f51905f52808380099150808283098181820990508181840992508183850993508184840992508183840990508181820982818309905082818209905082818209905082818309915082828609945082858609915082828309915082828509935082848509915082828309915082828309915082828509915082828609945082858609915082828309915082828309915082828609915082828509935082848609945082858609915082828309915082828509935082848509915082828309905082818209905082818209905082818309915082828609945082858509935082848509915082828309915082828309915082828609945082858609915082828309915082828609915082828309915082828309915082828609915082828509935082848509915082828309905082818209905082818309905082818509905082818209905082818209905082818209905082818209905082818309915082828609945082858609915082828609915082828509935082848509915082828509915082828309915082828309905082818309905082818209838182099050838182099050838182099050838182099050838183099150508281830991508282860994508285850993508284850991508282860994508285850993508284860994508285850993508284860994508285860991508282860991508282830991508282850993508284850991508282830991508282860994508285850993508284850991508282850991508282860994508285850993508284860994508285850993508284850991508282830991508282850991508282860994508285860991508282860991508282850993508284860994508285850993508284860994508285850993508284850991508282850991508282830991508282860994508285850993508284850991508282850991508282830991508282860994508285860991508282830990508281820990508281830990508281860990508281820990508281820990508281820990508281820990508281830991508282850993508284860994508285850993508284860994508285860991508282860991508282830991508282830991508282830991508282860991508282850993508284850991508282850991508282830991508282860994508285860991508282860991508282850993508284860994508285860991508282830991508282850993508284860994508285860991508282850993508284860994508285850993508284850991508282850991508282860994508285850993508284850991508282850991508282830991508282830991508282860994508285860991508282830991508282830991508282860991508282850993508284860994508285860991508282860990508281820990508281820990508281830991508282850993508284850991508282860994508285850993508284860994508285850993508284860994508285850993508284850991508282850990508281850991508282830991508282830991508282820991505081818509935081848409925081838509935081848409925081838509935081848509905081818509905081818409925050808284099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808384099250808383099392505050565b6121f58585858561223c565b6001600160a01b03841615611794578251339060010361222e576020848101519084015161222783898985858961244b565b5050610785565b61078581878787878761256c565b805182511461226b5781518151604051635b05999160e01b81526004810192909252602482015260440161036b565b335f5b835181101561236d576020818102858101820151908501909101516001600160a01b0388161561231f575f828152602081815260408083206001600160a01b038c168452909152902054818110156122f9576040516303dee4c560e01b81526001600160a01b038a16600482015260248101829052604481018390526064810184905260840161036b565b5f838152602081815260408083206001600160a01b038d16845290915290209082900390555b6001600160a01b03871615612363575f828152602081815260408083206001600160a01b038b1684529091528120805483929061235d908490612dd2565b90915550505b505060010161226e565b5082516001036123ed5760208301515f906020840151909150856001600160a01b0316876001600160a01b0316846001600160a01b03167fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f6285856040516123de929190918252602082015260400190565b60405180910390a45050611794565b836001600160a01b0316856001600160a01b0316826001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb868660405161243c929190612fde565b60405180910390a45050505050565b6001600160a01b0384163b156107855760405163f23a6e6160e01b81526001600160a01b0385169063f23a6e619061248f908990899088908890889060040161300b565b6020604051808303815f875af19250505080156124c9575060408051601f3d908101601f191682019092526124c69181019061304f565b60015b612530573d8080156124f6576040519150601f19603f3d011682016040523d82523d5f602084013e6124fb565b606091505b5080515f0361252857604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b805181602001fd5b6001600160e01b0319811663f23a6e6160e01b14611a3d57604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b6001600160a01b0384163b156107855760405163bc197c8160e01b81526001600160a01b0385169063bc197c81906125b0908990899088908890889060040161306a565b6020604051808303815f875af19250505080156125ea575060408051601f3d908101601f191682019092526125e79181019061304f565b60015b612617573d8080156124f6576040519150601f19603f3d011682016040523d82523d5f602084013e6124fb565b6001600160e01b0319811663bc197c8160e01b14611a3d57604051632bfa23e760e11b81526001600160a01b038616600482015260240161036b565b828054828255905f5260205f2090810192821561268c579160200282015b8281111561268c578251825591602001919060010190612671565b5061269892915061269c565b5090565b5b80821115612698575f815560010161269d565b6001600160a01b03811681146126c4575f5ffd5b50565b5f5f604083850312156126d8575f5ffd5b82356126e3816126b0565b946020939093013593505050565b5f5f83601f840112612701575f5ffd5b5081356001600160401b03811115612717575f5ffd5b6020830191508360208260051b8501011115612731575f5ffd5b9250929050565b5f5f5f5f5f6080868803121561274c575f5ffd5b8535612757816126b0565b9450602086013593506040860135925060608601356001600160401b0381111561277f575f5ffd5b61278b888289016126f1565b969995985093965092949392505050565b6001600160e01b0319811681146126c4575f5ffd5b5f602082840312156127c1575f5ffd5b81356107988161279c565b5f5f604083850312156127dd575f5ffd5b50508035926020909101359150565b5f602082840312156127fc575f5ffd5b5035919050565b5f5b8381101561281d578181015183820152602001612805565b50505f910152565b5f815180845261283c816020860160208601612803565b601f01601f19169290920160200192915050565b602081525f6107986020830184612825565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b038111828210171561289e5761289e612862565b604052919050565b5f6001600160401b038211156128be576128be612862565b5060051b60200190565b5f82601f8301126128d7575f5ffd5b81356128ea6128e5826128a6565b612876565b8082825260208201915060208360051b86010192508583111561290b575f5ffd5b602085015b83811015612928578035835260209283019201612910565b5095945050505050565b5f82601f830112612941575f5ffd5b81356001600160401b0381111561295a5761295a612862565b61296d601f8201601f1916602001612876565b818152846020838601011115612981575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f5f5f5f5f60a086880312156129b1575f5ffd5b85356129bc816126b0565b945060208601356129cc816126b0565b935060408601356001600160401b038111156129e6575f5ffd5b6129f2888289016128c8565b93505060608601356001600160401b03811115612a0d575f5ffd5b612a19888289016128c8565b92505060808601356001600160401b03811115612a34575f5ffd5b612a4088828901612932565b9150509295509295909350565b5f5f60408385031215612a5e575f5ffd5b82356001600160401b03811115612a73575f5ffd5b8301601f81018513612a83575f5ffd5b8035612a916128e5826128a6565b8082825260208201915060208360051b850101925087831115612ab2575f5ffd5b6020840193505b82841015612add578335612acc816126b0565b825260209384019390910190612ab9565b945050505060208301356001600160401b03811115612afa575f5ffd5b612b06858286016128c8565b9150509250929050565b5f8151808452602084019350602083015f5b82811015612b40578151865260209586019590910190600101612b22565b5093949350505050565b602081525f6107986020830184612b10565b5f5f5f5f5f5f60a08789031215612b71575f5ffd5b8635612b7c816126b0565b9550602087013594506040870135935060608701356001600160401b03811115612ba4575f5ffd5b612bb089828a016126f1565b979a9699509497949695608090950135949350505050565b5f5f5f60608486031215612bda575f5ffd5b8335612be5816126b0565b95602085013595506040909401359392505050565b5f5f5f60608486031215612c0c575f5ffd5b505081359360208301359350604090920135919050565b80151581146126c4575f5ffd5b5f5f60408385031215612c41575f5ffd5b8235612c4c816126b0565b91506020830135612c5c81612c23565b809150509250929050565b5f5f5f60408486031215612c79575f5ffd5b8335925060208401356001600160401b03811115612c95575f5ffd5b612ca1868287016126f1565b9497909650939450505050565b5f5f60408385031215612cbf575f5ffd5b8235612cca816126b0565b91506020830135612c5c816126b0565b5f5f5f5f5f60a08688031215612cee575f5ffd5b8535612cf9816126b0565b94506020860135612d09816126b0565b9350604086013592506060860135915060808601356001600160401b03811115612a34575f5ffd5b6020808252601a908201527f636f6e646974696f6e206e6f7420707265706172656420796574000000000000604082015260600190565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561030057610300612d68565b634e487b7160e01b5f52603260045260245ffd5b60208082526015908201527419dbdd081a5b9d985b1a59081a5b99195e081cd95d605a1b604082015260600190565b8082018082111561030057610300612d68565b808202811582820484141761030057610300612d68565b634e487b7160e01b5f52601260045260245ffd5b5f82612e1e57612e1e612dfc565b500490565b5f60208284031215612e33575f5ffd5b815161079881612c23565b8183525f6001600160fb1b03831115612e55575f5ffd5b8260051b80836020870137939093016020019392505050565b848152606060208201525f612e87606083018587612e3e565b905082604083015295945050505050565b600181811c90821680612eac57607f821691505b602082108103612eca57634e487b7160e01b5f52602260045260245ffd5b50919050565b6001600160a01b03851681526060602082018190525f90612e879083018587612e3e565b6020808252602a908201527f74686572652073686f756c64206265206d6f7265207468616e206f6e65206f756040820152691d18dbdb59481cdb1bdd60b21b606082015260800190565b5f6040820184835260406020840152808454808352606085019150855f5260205f2092505f5b81811015612f82578354835260019384019360209093019201612f64565b50909695505050505050565b5f82612f9c57612f9c612dfc565b500690565b5f8251612fb2818460208701612803565b9190910192915050565b5f5f60408385031215612fcd575f5ffd5b505080516020909101519092909150565b604081525f612ff06040830185612b10565b82810360208401526130028185612b10565b95945050505050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a0608082018190525f9061304490830184612825565b979650505050505050565b5f6020828403121561305f575f5ffd5b81516107988161279c565b6001600160a01b0386811682528516602082015260a0604082018190525f9061309590830186612b10565b82810360608401526130a78186612b10565b905082810360808401526130bb8185612825565b9897505050505050505056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47a26469706673582212202b1b4d5fa7f1d62e00bc43f25a36749f8354ac2351323b8dbbd480c0e0cbf12964736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\x1BW_5`\xE0\x1C\x80c\x85,j\xE2\x11a\0\xA9W\x80c\xD4-\xC0\xC2\x11a\0nW\x80c\xD4-\xC0\xC2\x14a\x02hW\x80c\xD9n\xE7T\x14a\x02\x87W\x80c\xDD4\xDEg\x14a\x02\x9AW\x80c\xE9\x85\xE9\xC5\x14a\x02\xB9W\x80c\xF2BC*\x14a\x02\xCCW__\xFD[\x80c\x85,j\xE2\x14a\x02\tW\x80c\x85b\x96\xF7\x14a\x02\x1CW\x80c\x9Er\x12\xAD\x14a\x02/W\x80c\xA2,\xB4e\x14a\x02BW\x80c\xC4\x92\x98\xAC\x14a\x02UW__\xFD[\x80c\x0E\x894\x1C\x11a\0\xEFW\x80c\x0E\x894\x1C\x14a\x01\x90W\x80c.\xB2\xC2\xD6\x14a\x01\xB0W\x80c9\xDDu0\x14a\x01\xC3W\x80cN\x12s\xF4\x14a\x01\xD6W\x80cr\xCEBu\x14a\x01\xF6W__\xFD[\x80b\xFD\xD5\x8E\x14a\x01\x1FW\x80c\x01\xB7\x03|\x14a\x01EW\x80c\x01\xFF\xC9\xA7\x14a\x01ZW\x80c\x05\x04\xC8\x14\x14a\x01}W[__\xFD[a\x012a\x01-6`\x04a&\xC7V[a\x02\xDFV[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01Xa\x01S6`\x04a'8V[a\x03\x06V[\0[a\x01ma\x01h6`\x04a'\xB1V[a\x06\x1AV[`@Q\x90\x15\x15\x81R` \x01a\x01<V[a\x012a\x01\x8B6`\x04a'\xCCV[a\x06iV[a\x01\xA3a\x01\x9E6`\x04a'\xECV[a\x06\x94V[`@Qa\x01<\x91\x90a(PV[a\x01Xa\x01\xBE6`\x04a)\x9DV[a\x07&V[a\x012a\x01\xD16`\x04a&\xC7V[a\x07\x8DV[a\x01\xE9a\x01\xE46`\x04a*MV[a\x07\x9FV[`@Qa\x01<\x91\x90a+JV[a\x01Xa\x02\x046`\x04a+\\V[a\x08iV[a\x012a\x02\x176`\x04a+\xC8V[a\x0B\xE8V[a\x012a\x02*6`\x04a+\xFAV[a\x0B\xFCV[a\x01Xa\x02=6`\x04a+\\V[a\x0C\x08V[a\x01Xa\x02P6`\x04a,0V[a\x0F`V[a\x01Xa\x02c6`\x04a,gV[a\x0FoV[a\x012a\x02v6`\x04a'\xECV[_\x90\x81R`\x03` R`@\x90 T\x90V[a\x01Xa\x02\x956`\x04a+\xC8V[a\x11\xE1V[a\x012a\x02\xA86`\x04a'\xECV[`\x04` R_\x90\x81R`@\x90 T\x81V[a\x01ma\x02\xC76`\x04a,\xAEV[a\x13fV[a\x01Xa\x02\xDA6`\x04a,\xDAV[a\x13\x93V[_\x81\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T[\x92\x91PPV[_\x83\x81R`\x04` R`@\x90 T\x80a\x03tW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`%`$\x82\x01R\x7Fresult for condition not receive`D\x82\x01Rd\x19\x08\x1EY]`\xDA\x1B`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[_\x84\x81R`\x03` R`@\x90 T\x80a\x03\x9FW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_\x80a\x03\xAE`\x01\x80\x85\x1Ba-|V[\x90P_[\x85\x81\x10\x15a\x04\xBBW_\x87\x87\x83\x81\x81\x10a\x03\xCDWa\x03\xCDa-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\x03\xE4WP\x82\x81\x10[a\x04\0W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[_a\x04\x15\x8Ca\x04\x10\x8D\x8D\x86a\x13\xF2V[a\x16\xE7V[\x90P_\x80[\x87\x81\x10\x15a\x04kW`\x01\x81\x1B\x84\x16\x15a\x04cW_\x8C\x81R`\x03` R`@\x90 \x80T\x82\x90\x81\x10a\x04LWa\x04La-\x8FV[\x90_R` _ \x01T\x82a\x04`\x91\x90a-\xD2V[\x91P[`\x01\x01a\x04\x1AV[P_a\x04w3\x84a\x02\xDFV[\x90P\x80\x15a\x04\xABW\x88a\x04\x8A\x83\x83a-\xE5V[a\x04\x94\x91\x90a.\x10V[a\x04\x9E\x90\x88a-\xD2V[\x96Pa\x04\xAB3\x84\x83a\x17.V[PP`\x01\x90\x92\x01\x91Pa\x03\xB2\x90PV[P\x81\x15a\x05\xBDW\x87a\x05\x9AW`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x8A\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x05\x11W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x055\x91\x90a.#V[a\x05\x95W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7Fcould not transfer payout to mes`D\x82\x01Rj9\xB0\xB3\xB2\x909\xB2\xB722\xB9`\xA9\x1B`d\x82\x01R`\x84\x01a\x03kV[a\x05\xBDV[a\x05\xBD3a\x05\xA8\x8B\x8Ba\x16\xE7V[\x84`@Q\x80` \x01`@R\x80_\x81RPa\x17\x9BV[\x87\x89`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x16\x7F&\x82\x01*JO\x19s\x11\x9F\x1C\x9B\x90t]\x1B\xD9\x1F\xA2\xBA\xB3\x874O\x04L\xB3Xhd\xD1\x8D\x8A\x8A\x8A\x88`@Qa\x06\x07\x94\x93\x92\x91\x90a.nV[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPV[_`\x01`\x01`\xE0\x1B\x03\x19\x82\x16cl\xDB=\x13`\xE1\x1B\x14\x80a\x06JWP`\x01`\x01`\xE0\x1B\x03\x19\x82\x16c\x03\xA2M\x07`\xE2\x1B\x14[\x80a\x03\0WPc\x01\xFF\xC9\xA7`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x83\x16\x14a\x03\0V[`\x03` R\x81_R`@_ \x81\x81T\x81\x10a\x06\x82W_\x80\xFD[\x90_R` _ \x01_\x91P\x91PPT\x81V[```\x02\x80Ta\x06\xA3\x90a.\x98V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x06\xCF\x90a.\x98V[\x80\x15a\x07\x1AW\x80`\x1F\x10a\x06\xF1Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x07\x1AV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x06\xFDW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x90P\x91\x90PV[3`\x01`\x01`\xA0\x1B\x03\x86\x16\x81\x14\x80\x15\x90a\x07GWPa\x07E\x86\x82a\x13fV[\x15[\x15a\x07xW`@Qcq\x1B\xEC\x91`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x87\x16`$\x82\x01R`D\x01a\x03kV[a\x07\x85\x86\x86\x86\x86\x86a\x17\xF6V[PPPPPPV[_a\x07\x98\x83\x83a\x16\xE7V[\x93\x92PPPV[``\x81Q\x83Q\x14a\x07\xD0W\x81Q\x83Q`@Qc[\x05\x99\x91`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x03kV[_\x83Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07\xEAWa\x07\xEAa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x08\x13W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x84Q\x81\x10\x15a\x08aW` \x80\x82\x02\x86\x01\x01Qa\x08<\x90` \x80\x84\x02\x87\x01\x01Qa\x02\xDFV[\x82\x82\x81Q\x81\x10a\x08NWa\x08Na-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x08\x18V[P\x93\x92PPPV[`\x01\x82\x11a\x08\xB9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fgot empty or singleton partition`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 T\x80a\x08\xE4W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_a\x08\xF2`\x01\x80\x84\x1Ba-|V[\x90P\x80_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\t\x0EWa\t\x0Ea(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\t7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x86`\x01`\x01`@\x1B\x03\x81\x11\x15a\tSWa\tSa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\t|W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x87\x81\x10\x15a\nqW_\x89\x89\x83\x81\x81\x10a\t\x9CWa\t\x9Ca-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\t\xB3WP\x85\x81\x10[a\t\xCFW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[\x80\x85\x82\x16\x14a\n\x19W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x1C\x18\\\x9D\x1A]\x1A[\xDB\x88\x1B\x9B\xDD\x08\x19\x1A\\\xDA\x9B\xDA[\x9D`R\x1B`D\x82\x01R`d\x01a\x03kV[\x93\x84\x18\x93a\n,\x8Da\x04\x10\x8E\x8E\x85a\x13\xF2V[\x84\x83\x81Q\x81\x10a\n>Wa\n>a-\x8FV[` \x02` \x01\x01\x81\x81RPP\x87\x83\x83\x81Q\x81\x10a\n]Wa\n]a-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01RP`\x01\x01a\t\x81V[P\x82_\x03a\x0BcW\x89a\x0BOW`@Qc#\xB8r\xDD`\xE0\x1B\x81R3`\x04\x82\x01R0`$\x82\x01R`D\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x8C\x16\x90c#\xB8r\xDD\x90`d\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\n\xCEW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xF2\x91\x90a.#V[a\x0BJW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`#`$\x82\x01R\x7Fcould not receive collateral tok`D\x82\x01Rbens`\xE8\x1B`d\x82\x01R`\x84\x01a\x03kV[a\x0BxV[a\x0BJ3a\x0B]\x8D\x8Da\x16\xE7V[\x88a\x17.V[a\x0Bx3a\x0B]\x8Da\x04\x10\x8E\x8E\x89\x8B\x18a\x13\xF2V[a\x0B\x923\x83\x83`@Q\x80` \x01`@R\x80_\x81RPa\x18TV[\x88\x8A3`\x01`\x01`\xA0\x1B\x03\x16\x7F.k\xB9\x1F\x8C\xBC\xDA\x0C\x93b<T\xD0@:CQO\xAB\xC4\0\x84\xEC\x96\xB6\xD57\x9Atxb\x98\x8E\x8C\x8C\x8C`@Qa\x0B\xD3\x94\x93\x92\x91\x90a.\xD0V[`@Q\x80\x91\x03\x90\xA4PPPPPPPPPPPV[_a\x0B\xF4\x84\x84\x84a\x18\x90V[\x94\x93PPPPV[_a\x0B\xF4\x84\x84\x84a\x13\xF2V[`\x01\x82\x11a\x0CXW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fgot empty or singleton partition`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 T\x80a\x0C\x83W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-1V[_a\x0C\x91`\x01\x80\x84\x1Ba-|V[\x90P\x80_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xADWa\x0C\xADa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\xD6W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x86`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xF2Wa\x0C\xF2a(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\r\x1BW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x87\x81\x10\x15a\x0E\x10W_\x89\x89\x83\x81\x81\x10a\r;Wa\r;a-\x8FV[\x90P` \x02\x015\x90P_\x81\x11\x80\x15a\rRWP\x85\x81\x10[a\rnW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a-\xA3V[\x80\x85\x82\x16\x14a\r\xB8W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x1C\x18\\\x9D\x1A]\x1A[\xDB\x88\x1B\x9B\xDD\x08\x19\x1A\\\xDA\x9B\xDA[\x9D`R\x1B`D\x82\x01R`d\x01a\x03kV[\x93\x84\x18\x93a\r\xCB\x8Da\x04\x10\x8E\x8E\x85a\x13\xF2V[\x84\x83\x81Q\x81\x10a\r\xDDWa\r\xDDa-\x8FV[` \x02` \x01\x01\x81\x81RPP\x87\x83\x83\x81Q\x81\x10a\r\xFCWa\r\xFCa-\x8FV[` \x90\x81\x02\x91\x90\x91\x01\x01RP`\x01\x01a\r V[Pa\x0E\x1C3\x83\x83a\x18\xDEV[\x82_\x03a\x0F\nW\x89a\x0E\xE7W`@Qc\xA9\x05\x9C\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x8C\x16\x90c\xA9\x05\x9C\xBB\x90`D\x01` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15a\x0ErW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0E\x96\x91\x90a.#V[a\x0E\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7Fcould not send collateral tokens`D\x82\x01R`d\x01a\x03kV[a\x0F\x1FV[a\x0E\xE23a\x0E\xF5\x8D\x8Da\x16\xE7V[\x88`@Q\x80` \x01`@R\x80_\x81RPa\x17\x9BV[a\x0F\x1F3a\x0E\xF5\x8Da\x04\x10\x8E\x8E\x89\x8B\x18a\x13\xF2V[\x88\x8A3`\x01`\x01`\xA0\x1B\x03\x16\x7Fo\x13\xCAbU?\xCC+\xCD#r\x18\nC\x94\x9C\x1EL\xEB\xBA`9\x01\xED\xE2\xF4\xE1O6\xB2\x82\xCA\x8E\x8C\x8C\x8C`@Qa\x0B\xD3\x94\x93\x92\x91\x90a.\xD0V[a\x0Fk3\x83\x83a\x19&V[PPV[\x80`\x01\x81\x11a\x0F\x90W`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a.\xF4V[_a\x0F\x9C3\x86\x84a\x18\x90V[_\x81\x81R`\x03` R`@\x90 T\x90\x91P\x82\x14a\x0F\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7Fcondition not prepared or found\0`D\x82\x01R`d\x01a\x03kV[_\x81\x81R`\x04` R`@\x90 T\x15a\x10VW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7Fpayout denominator already set\0\0`D\x82\x01R`d\x01a\x03kV[_\x80[\x83\x81\x10\x15a\x119W_\x86\x86\x83\x81\x81\x10a\x10tWa\x10ta-\x8FV[\x90P` \x02\x015\x90P\x80\x83a\x10\x89\x91\x90a-\xD2V[_\x85\x81R`\x03` R`@\x90 \x80T\x91\x94P\x90\x83\x90\x81\x10a\x10\xACWa\x10\xACa-\x8FV[\x90_R` _ \x01T_\x14a\x11\x03W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Fpayout numerator already set\0\0\0\0`D\x82\x01R`d\x01a\x03kV[_\x84\x81R`\x03` R`@\x90 \x80T\x82\x91\x90\x84\x90\x81\x10a\x11%Wa\x11%a-\x8FV[_\x91\x82R` \x90\x91 \x01UP`\x01\x01a\x10YV[P_\x81\x11a\x11\x80W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x14`$\x82\x01Rspayout is all zeroes``\x1B`D\x82\x01R`d\x01a\x03kV[_\x82\x81R`\x04` \x90\x81R`@\x80\x83 \x84\x90U`\x03\x90\x91R\x90\x81\x90 \x90Q\x87\x913\x91\x85\x91\x7F\xB4M\x84\xD3(\x96\x91\xF7\x14\x97VK\x85\xD4#6H\xD9\xDB\xAE\x8C\xBD\xBBC)\xF3\x01\xC3\xA0\x18X\x94\x91a\x11\xD1\x91\x89\x91a/>V[`@Q\x80\x91\x03\x90\xA4PPPPPPV[a\x01\0\x81\x11\x15a\x12,W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Rutoo many outcome slots`P\x1B`D\x82\x01R`d\x01a\x03kV[`\x01\x81\x11a\x12LW`@QbF\x1B\xCD`\xE5\x1B\x81R`\x04\x01a\x03k\x90a.\xF4V[_a\x12X\x84\x84\x84a\x18\x90V[_\x81\x81R`\x03` R`@\x90 T\x90\x91P\x15a\x12\xB6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7Fcondition already prepared\0\0\0\0\0\0`D\x82\x01R`d\x01a\x03kV[\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\xCEWa\x12\xCEa(bV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x12\xF7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P_\x82\x81R`\x03` \x90\x81R`@\x90\x91 \x82Qa\x13\x1A\x93\x91\x92\x91\x90\x91\x01\x90a&SV[P\x82\x84`\x01`\x01`\xA0\x1B\x03\x16\x82\x7F\xAB7`\xC3\xBD+\xB3\x8B[\xCFT\xDCy\x80.\xD6s8\xB4\xCF)\xF3\x05M\xEDg\xED$f\x1EAw\x85`@Qa\x13X\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA4PPPPV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x01` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R T`\xFF\x16\x90V[3`\x01`\x01`\xA0\x1B\x03\x86\x16\x81\x14\x80\x15\x90a\x13\xB4WPa\x13\xB2\x86\x82a\x13fV[\x15[\x15a\x13\xE5W`@Qcq\x1B\xEC\x91`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x83\x16`\x04\x83\x01R\x87\x16`$\x82\x01R`D\x01a\x03kV[a\x07\x85\x86\x86\x86\x86\x86a\x19\xBAV[__\x83\x83`@Q` \x01a\x14\x10\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x90P`\xFF\x81\x90\x1C\x15\x15_\x80[_Q` a0\xC8_9_Q\x90_R`\x01\x85\x08\x93P_Q` a0\xC8_9_Q\x90_R`\x03_Q` a0\xC8_9_Q\x90_R\x80\x87\x88\t\x87\t\x08\x90Pa\x14x\x81a\x1AFV[\x91P\x80_Q` a0\xC8_9_Q\x90_R\x83\x84\t\x03a\x144W\x82\x80\x15a\x14\xA6WPa\x14\xA4`\x02\x83a/\x8EV[\x15[\x80a\x14\xC4WP\x82\x15\x80\x15a\x14\xC4WPa\x14\xC0`\x02\x83a/\x8EV[`\x01\x14[\x15a\x14\xE3Wa\x14\xE0\x82_Q` a0\xC8_9_Q\x90_Ra-|V[\x91P[\x87\x80\x15a\x16\xBEW`\xFE\x81\x90\x1C\x15\x15\x93P`\x01`\x01`\xFE\x1B\x03\x16_Q` a0\xC8_9_Q\x90_R`\x03_Q` a0\xC8_9_Q\x90_R\x80\x84\x85\t\x84\t\x08\x91P_a\x15-\x83a\x1AFV[\x90P\x84\x80\x15a\x15DWPa\x15B`\x02\x82a/\x8EV[\x15[\x80a\x15bWP\x84\x15\x80\x15a\x15bWPa\x15^`\x02\x82a/\x8EV[`\x01\x14[\x15a\x15\x81Wa\x15~\x81_Q` a0\xC8_9_Q\x90_Ra-|V[\x90P[\x82_Q` a0\xC8_9_Q\x90_R\x82\x83\t\x14a\x15\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7Finvalid parent collection ID\0\0\0\0`D\x82\x01R`d\x01a\x03kV[`@\x80Q` \x81\x01\x88\x90R\x90\x81\x01\x85\x90R``\x81\x01\x83\x90R`\x80\x81\x01\x82\x90R_\x90\x81\x90`\x06\x90`\xA0\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x16#\x91a/\xA1V[_`@Q\x80\x83\x03\x81\x85Z\xFA\x91PP=\x80_\x81\x14a\x16[W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x16`V[``\x91P[P\x91P\x91P\x81a\x16\xA1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01Rk\x19X\xD8Y\x19\x08\x19\x98Z[\x19Y`\xA2\x1B`D\x82\x01R`d\x01a\x03kV[\x80\x80` \x01\x90Q\x81\x01\x90a\x16\xB5\x91\x90a/\xBCV[\x90\x98P\x95PPPP[a\x16\xC9`\x02\x84a/\x8EV[`\x01\x03a\x16\xDAW`\x01`\xFE\x1B\x85\x18\x94P[P\x92\x97\x96PPPPPPPV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x84\x90\x1B\x16` \x82\x01R`4\x81\x01\x82\x90R_\x90`T\x01`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x17VW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x85\x90R\x81\x83\x01\x90\x81R``\x82\x01\x84\x90R`\xA0\x82\x01\x90\x92R_`\x80\x82\x01\x81\x81R\x91\x92\x91a\x17\x94\x91\x87\x91\x85\x90\x85\x90a!\xE9V[PPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x17\xC4W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x86\x90R\x81\x83\x01\x90\x81R``\x82\x01\x85\x90R`\x80\x82\x01\x90\x92R\x90a\x07\x85_\x87\x84\x84\x87a!\xE9V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18\x1FW`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x18GW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x17\x94\x85\x85\x85\x85\x85a!\xE9V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18}W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x18\x8A_\x85\x85\x85\x85a!\xE9V[PPPPV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19``\x85\x90\x1B\x16` \x82\x01R`4\x81\x01\x83\x90R`T\x81\x01\x82\x90R_\x90`t\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x93\x92PPPV[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x19\x06W`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[a\x19!\x83_\x84\x84`@Q\x80` \x01`@R\x80_\x81RPa!\xE9V[PPPV[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x19NW`@Qb\xCE\xD3\xE1`\xE8\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x01` \x90\x81R`@\x80\x83 \x94\x87\x16\x80\x84R\x94\x82R\x91\x82\x90 \x80T`\xFF\x19\x16\x86\x15\x15\x90\x81\x17\x90\x91U\x91Q\x91\x82R\x7F\x170~\xAB9\xABa\x07\xE8\x89\x98E\xAD=Y\xBD\x96S\xF2\0\xF2 \x92\x04\x89\xCA+Y7il1\x91\x01`@Q\x80\x91\x03\x90\xA3PPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x19\xE3W`@Qc+\xFA#\xE7`\xE1\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x85\x16a\x1A\x0BW`@Qbj\rE`\xE2\x1B\x81R_`\x04\x82\x01R`$\x01a\x03kV[`@\x80Q`\x01\x80\x82R` \x82\x01\x86\x90R\x81\x83\x01\x90\x81R``\x82\x01\x85\x90R`\x80\x82\x01\x90\x92R\x90a\x1A=\x87\x87\x84\x84\x87a!\xE9V[PPPPPPPV[__Q` a0\xC8_9_Q\x90_R\x80\x83\x80\t\x91P\x80\x82\x83\t\x81\x81\x82\t\x90P\x81\x81\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x84\t\x90P\x81\x81\x82\t\x82\x81\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x90P\x82\x81\x85\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x90P\x82\x81\x83\t\x90P\x82\x81\x82\t\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x82\t\x90P\x83\x81\x83\t\x91PP\x82\x81\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x90P\x82\x81\x86\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x86\t\x91P\x82\x82\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x86\t\x91P\x82\x82\x86\t\x90P\x82\x81\x82\t\x90P\x82\x81\x82\t\x90P\x82\x81\x83\t\x91P\x82\x82\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x86\t\x94P\x82\x85\x85\t\x93P\x82\x84\x85\t\x91P\x82\x82\x85\t\x90P\x82\x81\x85\t\x91P\x82\x82\x83\t\x91P\x82\x82\x83\t\x91P\x82\x82\x82\t\x91PP\x81\x81\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x84\t\x92P\x81\x83\x85\t\x93P\x81\x84\x85\t\x90P\x81\x81\x85\t\x90P\x81\x81\x84\t\x92PP\x80\x82\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x84\t\x92P\x80\x83\x83\t\x93\x92PPPV[a!\xF5\x85\x85\x85\x85a\"<V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x17\x94W\x82Q3\x90`\x01\x03a\".W` \x84\x81\x01Q\x90\x84\x01Qa\"'\x83\x89\x89\x85\x85\x89a$KV[PPa\x07\x85V[a\x07\x85\x81\x87\x87\x87\x87\x87a%lV[\x80Q\x82Q\x14a\"kW\x81Q\x81Q`@Qc[\x05\x99\x91`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x03kV[3_[\x83Q\x81\x10\x15a#mW` \x81\x81\x02\x85\x81\x01\x82\x01Q\x90\x85\x01\x90\x91\x01Q`\x01`\x01`\xA0\x1B\x03\x88\x16\x15a#\x1FW_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8C\x16\x84R\x90\x91R\x90 T\x81\x81\x10\x15a\"\xF9W`@Qc\x03\xDE\xE4\xC5`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8A\x16`\x04\x82\x01R`$\x81\x01\x82\x90R`D\x81\x01\x83\x90R`d\x81\x01\x84\x90R`\x84\x01a\x03kV[_\x83\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8D\x16\x84R\x90\x91R\x90 \x90\x82\x90\x03\x90U[`\x01`\x01`\xA0\x1B\x03\x87\x16\x15a#cW_\x82\x81R` \x81\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x8B\x16\x84R\x90\x91R\x81 \x80T\x83\x92\x90a#]\x90\x84\x90a-\xD2V[\x90\x91UPP[PP`\x01\x01a\"nV[P\x82Q`\x01\x03a#\xEDW` \x83\x01Q_\x90` \x84\x01Q\x90\x91P\x85`\x01`\x01`\xA0\x1B\x03\x16\x87`\x01`\x01`\xA0\x1B\x03\x16\x84`\x01`\x01`\xA0\x1B\x03\x16\x7F\xC3\xD5\x81h\xC5\xAEs\x97s\x1D\x06=[\xBF=exTBsC\xF4\xC0\x83$\x0Fz\xAC\xAA-\x0Fb\x85\x85`@Qa#\xDE\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA4PPa\x17\x94V[\x83`\x01`\x01`\xA0\x1B\x03\x16\x85`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x7FJ9\xDC\x06\xD4\xC0\xDB\xC6Kp\xAF\x90\xFDi\x8A#:Q\x8A\xA5\xD0~Y]\x98;\x8C\x05&\xC8\xF7\xFB\x86\x86`@Qa$<\x92\x91\x90a/\xDEV[`@Q\x80\x91\x03\x90\xA4PPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x07\x85W`@Qc\xF2:na`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xF2:na\x90a$\x8F\x90\x89\x90\x89\x90\x88\x90\x88\x90\x88\x90`\x04\x01a0\x0BV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a$\xC9WP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra$\xC6\x91\x81\x01\x90a0OV[`\x01[a%0W=\x80\x80\x15a$\xF6W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a$\xFBV[``\x91P[P\x80Q_\x03a%(W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[\x80Q\x81` \x01\xFD[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16c\xF2:na`\xE0\x1B\x14a\x1A=W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[`\x01`\x01`\xA0\x1B\x03\x84\x16;\x15a\x07\x85W`@Qc\xBC\x19|\x81`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16\x90c\xBC\x19|\x81\x90a%\xB0\x90\x89\x90\x89\x90\x88\x90\x88\x90\x88\x90`\x04\x01a0jV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x92PPP\x80\x15a%\xEAWP`@\x80Q`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01\x90\x92Ra%\xE7\x91\x81\x01\x90a0OV[`\x01[a&\x17W=\x80\x80\x15a$\xF6W`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a$\xFBV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16c\xBC\x19|\x81`\xE0\x1B\x14a\x1A=W`@Qc+\xFA#\xE7`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x86\x16`\x04\x82\x01R`$\x01a\x03kV[\x82\x80T\x82\x82U\x90_R` _ \x90\x81\x01\x92\x82\x15a&\x8CW\x91` \x02\x82\x01[\x82\x81\x11\x15a&\x8CW\x82Q\x82U\x91` \x01\x91\x90`\x01\x01\x90a&qV[Pa&\x98\x92\x91Pa&\x9CV[P\x90V[[\x80\x82\x11\x15a&\x98W_\x81U`\x01\x01a&\x9DV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a&\xC4W__\xFD[PV[__`@\x83\x85\x03\x12\x15a&\xD8W__\xFD[\x825a&\xE3\x81a&\xB0V[\x94` \x93\x90\x93\x015\x93PPPV[__\x83`\x1F\x84\x01\x12a'\x01W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x17W__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a'1W__\xFD[\x92P\x92\x90PV[_____`\x80\x86\x88\x03\x12\x15a'LW__\xFD[\x855a'W\x81a&\xB0V[\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a'\x7FW__\xFD[a'\x8B\x88\x82\x89\x01a&\xF1V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x81\x14a&\xC4W__\xFD[_` \x82\x84\x03\x12\x15a'\xC1W__\xFD[\x815a\x07\x98\x81a'\x9CV[__`@\x83\x85\x03\x12\x15a'\xDDW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[_` \x82\x84\x03\x12\x15a'\xFCW__\xFD[P5\x91\x90PV[_[\x83\x81\x10\x15a(\x1DW\x81\x81\x01Q\x83\x82\x01R` \x01a(\x05V[PP_\x91\x01RV[_\x81Q\x80\x84Ra(<\x81` \x86\x01` \x86\x01a(\x03V[`\x1F\x01`\x1F\x19\x16\x92\x90\x92\x01` \x01\x92\x91PPV[` \x81R_a\x07\x98` \x83\x01\x84a(%V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a(\x9EWa(\x9Ea(bV[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15a(\xBEWa(\xBEa(bV[P`\x05\x1B` \x01\x90V[_\x82`\x1F\x83\x01\x12a(\xD7W__\xFD[\x815a(\xEAa(\xE5\x82a(\xA6V[a(vV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x86\x01\x01\x92P\x85\x83\x11\x15a)\x0BW__\xFD[` \x85\x01[\x83\x81\x10\x15a)(W\x805\x83R` \x92\x83\x01\x92\x01a)\x10V[P\x95\x94PPPPPV[_\x82`\x1F\x83\x01\x12a)AW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a)ZWa)Za(bV[a)m`\x1F\x82\x01`\x1F\x19\x16` \x01a(vV[\x81\x81R\x84` \x83\x86\x01\x01\x11\x15a)\x81W__\xFD[\x81` \x85\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x93\x92PPPV[_____`\xA0\x86\x88\x03\x12\x15a)\xB1W__\xFD[\x855a)\xBC\x81a&\xB0V[\x94P` \x86\x015a)\xCC\x81a&\xB0V[\x93P`@\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a)\xE6W__\xFD[a)\xF2\x88\x82\x89\x01a(\xC8V[\x93PP``\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\rW__\xFD[a*\x19\x88\x82\x89\x01a(\xC8V[\x92PP`\x80\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*4W__\xFD[a*@\x88\x82\x89\x01a)2V[\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15a*^W__\xFD[\x825`\x01`\x01`@\x1B\x03\x81\x11\x15a*sW__\xFD[\x83\x01`\x1F\x81\x01\x85\x13a*\x83W__\xFD[\x805a*\x91a(\xE5\x82a(\xA6V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x87\x83\x11\x15a*\xB2W__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a*\xDDW\x835a*\xCC\x81a&\xB0V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a*\xB9V[\x94PPPP` \x83\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*\xFAW__\xFD[a+\x06\x85\x82\x86\x01a(\xC8V[\x91PP\x92P\x92\x90PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a+@W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a+\"V[P\x93\x94\x93PPPPV[` \x81R_a\x07\x98` \x83\x01\x84a+\x10V[______`\xA0\x87\x89\x03\x12\x15a+qW__\xFD[\x865a+|\x81a&\xB0V[\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a+\xA4W__\xFD[a+\xB0\x89\x82\x8A\x01a&\xF1V[\x97\x9A\x96\x99P\x94\x97\x94\x96\x95`\x80\x90\x95\x015\x94\x93PPPPV[___``\x84\x86\x03\x12\x15a+\xDAW__\xFD[\x835a+\xE5\x81a&\xB0V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[___``\x84\x86\x03\x12\x15a,\x0CW__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[\x80\x15\x15\x81\x14a&\xC4W__\xFD[__`@\x83\x85\x03\x12\x15a,AW__\xFD[\x825a,L\x81a&\xB0V[\x91P` \x83\x015a,\\\x81a,#V[\x80\x91PP\x92P\x92\x90PV[___`@\x84\x86\x03\x12\x15a,yW__\xFD[\x835\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a,\x95W__\xFD[a,\xA1\x86\x82\x87\x01a&\xF1V[\x94\x97\x90\x96P\x93\x94PPPPV[__`@\x83\x85\x03\x12\x15a,\xBFW__\xFD[\x825a,\xCA\x81a&\xB0V[\x91P` \x83\x015a,\\\x81a&\xB0V[_____`\xA0\x86\x88\x03\x12\x15a,\xEEW__\xFD[\x855a,\xF9\x81a&\xB0V[\x94P` \x86\x015a-\t\x81a&\xB0V[\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a*4W__\xFD[` \x80\x82R`\x1A\x90\x82\x01R\x7Fcondition not prepared yet\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x03\0Wa\x03\0a-hV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[` \x80\x82R`\x15\x90\x82\x01Rt\x19\xDB\xDD\x08\x1A[\x9D\x98[\x1AY\x08\x1A[\x99\x19^\x08\x1C\xD9]`Z\x1B`@\x82\x01R``\x01\x90V[\x80\x82\x01\x80\x82\x11\x15a\x03\0Wa\x03\0a-hV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\0Wa\x03\0a-hV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a.\x1EWa.\x1Ea-\xFCV[P\x04\x90V[_` \x82\x84\x03\x12\x15a.3W__\xFD[\x81Qa\x07\x98\x81a,#V[\x81\x83R_`\x01`\x01`\xFB\x1B\x03\x83\x11\x15a.UW__\xFD[\x82`\x05\x1B\x80\x83` \x87\x017\x93\x90\x93\x01` \x01\x93\x92PPPV[\x84\x81R``` \x82\x01R_a.\x87``\x83\x01\x85\x87a.>V[\x90P\x82`@\x83\x01R\x95\x94PPPPPV[`\x01\x81\x81\x1C\x90\x82\x16\x80a.\xACW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03a.\xCAWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[`\x01`\x01`\xA0\x1B\x03\x85\x16\x81R``` \x82\x01\x81\x90R_\x90a.\x87\x90\x83\x01\x85\x87a.>V[` \x80\x82R`*\x90\x82\x01R\x7Fthere should be more than one ou`@\x82\x01Ri\x1D\x18\xDB\xDBYH\x1C\xDB\x1B\xDD`\xB2\x1B``\x82\x01R`\x80\x01\x90V[_`@\x82\x01\x84\x83R`@` \x84\x01R\x80\x84T\x80\x83R``\x85\x01\x91P\x85_R` _ \x92P_[\x81\x81\x10\x15a/\x82W\x83T\x83R`\x01\x93\x84\x01\x93` \x90\x93\x01\x92\x01a/dV[P\x90\x96\x95PPPPPPV[_\x82a/\x9CWa/\x9Ca-\xFCV[P\x06\x90V[_\x82Qa/\xB2\x81\x84` \x87\x01a(\x03V[\x91\x90\x91\x01\x92\x91PPV[__`@\x83\x85\x03\x12\x15a/\xCDW__\xFD[PP\x80Q` \x90\x91\x01Q\x90\x92\x90\x91PV[`@\x81R_a/\xF0`@\x83\x01\x85a+\x10V[\x82\x81\x03` \x84\x01Ra0\x02\x81\x85a+\x10V[\x95\x94PPPPPV[`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x82R\x85\x16` \x82\x01R`@\x81\x01\x84\x90R``\x81\x01\x83\x90R`\xA0`\x80\x82\x01\x81\x90R_\x90a0D\x90\x83\x01\x84a(%V[\x97\x96PPPPPPPV[_` \x82\x84\x03\x12\x15a0_W__\xFD[\x81Qa\x07\x98\x81a'\x9CV[`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x82R\x85\x16` \x82\x01R`\xA0`@\x82\x01\x81\x90R_\x90a0\x95\x90\x83\x01\x86a+\x10V[\x82\x81\x03``\x84\x01Ra0\xA7\x81\x86a+\x10V[\x90P\x82\x81\x03`\x80\x84\x01Ra0\xBB\x81\x85a(%V[\x98\x97PPPPPPPPV\xFE0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG\xA2dipfsX\"\x12 +\x1BM_\xA7\xF1\xD6.\0\xBCC\xF2Z6t\x9F\x83T\xAC#Q2;\x8D\xBB\xD4\x80\xC0\xE0\xCB\xF1)dsolcC\0\x08\x1C\x003",
    );
    /**Custom error with signature `ERC1155InsufficientBalance(address,uint256,uint256,uint256)` and selector `0x03dee4c5`.
    ```solidity
    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InsufficientBalance {
        pub sender: alloy::sol_types::private::Address,
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        pub needed: alloy::sol_types::private::primitives::aliases::U256,
        pub tokenId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InsufficientBalance> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InsufficientBalance) -> Self {
                (value.sender, value.balance, value.needed, value.tokenId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InsufficientBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0, balance: tuple.1, needed: tuple.2, tokenId: tuple.3 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InsufficientBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "ERC1155InsufficientBalance(address,uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [3u8, 222u8, 228u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.balance,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.needed,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.tokenId,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1155InvalidApprover(address)` and selector `0x3e31884e`.
    ```solidity
    error ERC1155InvalidApprover(address approver);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InvalidApprover {
        pub approver: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InvalidApprover> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InvalidApprover) -> Self {
                (value.approver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InvalidApprover {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { approver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InvalidApprover {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155InvalidApprover(address)";
            const SELECTOR: [u8; 4] = [62u8, 49u8, 136u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.approver,
                ),)
            }
        }
    };
    /**Custom error with signature `ERC1155InvalidArrayLength(uint256,uint256)` and selector `0x5b059991`.
    ```solidity
    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InvalidArrayLength {
        pub idsLength: alloy::sol_types::private::primitives::aliases::U256,
        pub valuesLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> =
            (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InvalidArrayLength> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InvalidArrayLength) -> Self {
                (value.idsLength, value.valuesLength)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InvalidArrayLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { idsLength: tuple.0, valuesLength: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InvalidArrayLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155InvalidArrayLength(uint256,uint256)";
            const SELECTOR: [u8; 4] = [91u8, 5u8, 153u8, 145u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.idsLength,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.valuesLength,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1155InvalidOperator(address)` and selector `0xced3e100`.
    ```solidity
    error ERC1155InvalidOperator(address operator);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InvalidOperator {
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InvalidOperator> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InvalidOperator) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InvalidOperator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InvalidOperator {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155InvalidOperator(address)";
            const SELECTOR: [u8; 4] = [206u8, 211u8, 225u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.operator,
                ),)
            }
        }
    };
    /**Custom error with signature `ERC1155InvalidReceiver(address)` and selector `0x57f447ce`.
    ```solidity
    error ERC1155InvalidReceiver(address receiver);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InvalidReceiver {
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InvalidReceiver> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InvalidReceiver) -> Self {
                (value.receiver,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InvalidReceiver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { receiver: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InvalidReceiver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155InvalidReceiver(address)";
            const SELECTOR: [u8; 4] = [87u8, 244u8, 71u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.receiver,
                ),)
            }
        }
    };
    /**Custom error with signature `ERC1155InvalidSender(address)` and selector `0x01a83514`.
    ```solidity
    error ERC1155InvalidSender(address sender);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155InvalidSender {
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155InvalidSender> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155InvalidSender) -> Self {
                (value.sender,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155InvalidSender {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { sender: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155InvalidSender {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155InvalidSender(address)";
            const SELECTOR: [u8; 4] = [1u8, 168u8, 53u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                    &self.sender,
                ),)
            }
        }
    };
    /**Custom error with signature `ERC1155MissingApprovalForAll(address,address)` and selector `0xe237d922`.
    ```solidity
    error ERC1155MissingApprovalForAll(address operator, address owner);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1155MissingApprovalForAll {
        pub operator: alloy::sol_types::private::Address,
        pub owner: alloy::sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> =
            (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> =
            (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1155MissingApprovalForAll> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1155MissingApprovalForAll) -> Self {
                (value.operator, value.owner)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1155MissingApprovalForAll {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0, owner: tuple.1 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1155MissingApprovalForAll {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1155MissingApprovalForAll(address,address)";
            const SELECTOR: [u8; 4] = [226u8, 55u8, 217u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                )
            }
        }
    };
    /**Event with signature `ApprovalForAll(address,address,bool)` and selector `0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31`.
    ```solidity
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct ApprovalForAll {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub approved: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ApprovalForAll {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ApprovalForAll(address,address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8, 69u8,
                    173u8, 61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8, 146u8, 4u8,
                    137u8, 202u8, 43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: topics.1, operator: topics.2, approved: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                    &self.approved,
                ),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ApprovalForAll {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ApprovalForAll> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ApprovalForAll) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ConditionPreparation(bytes32,address,bytes32,uint256)` and selector `0xab3760c3bd2bb38b5bcf54dc79802ed67338b4cf29f3054ded67ed24661e4177`.
    ```solidity
    event ConditionPreparation(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct ConditionPreparation {
        #[allow(missing_docs)]
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub oracle: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub questionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ConditionPreparation {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ConditionPreparation(bytes32,address,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    171u8, 55u8, 96u8, 195u8, 189u8, 43u8, 179u8, 139u8, 91u8, 207u8, 84u8, 220u8,
                    121u8, 128u8, 46u8, 214u8, 115u8, 56u8, 180u8, 207u8, 41u8, 243u8, 5u8, 77u8,
                    237u8, 103u8, 237u8, 36u8, 102u8, 30u8, 65u8, 119u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    conditionId: topics.1,
                    oracle: topics.2,
                    questionId: topics.3,
                    outcomeSlotCount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self.outcomeSlotCount,
                ),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.conditionId.clone(),
                    self.oracle.clone(),
                    self.questionId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.conditionId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oracle,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.questionId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ConditionPreparation {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ConditionPreparation> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ConditionPreparation) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ConditionResolution(bytes32,address,bytes32,uint256,uint256[])` and selector `0xb44d84d3289691f71497564b85d4233648d9dbae8cbdbb4329f301c3a0185894`.
    ```solidity
    event ConditionResolution(bytes32 indexed conditionId, address indexed oracle, bytes32 indexed questionId, uint256 outcomeSlotCount, uint256[] payoutNumerators);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct ConditionResolution {
        #[allow(missing_docs)]
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub oracle: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub questionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub payoutNumerators:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ConditionResolution {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "ConditionResolution(bytes32,address,bytes32,uint256,uint256[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    180u8, 77u8, 132u8, 211u8, 40u8, 150u8, 145u8, 247u8, 20u8, 151u8, 86u8, 75u8,
                    133u8, 212u8, 35u8, 54u8, 72u8, 217u8, 219u8, 174u8, 140u8, 189u8, 187u8, 67u8,
                    41u8, 243u8, 1u8, 195u8, 160u8, 24u8, 88u8, 148u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    conditionId: topics.1,
                    oracle: topics.2,
                    questionId: topics.3,
                    outcomeSlotCount: data.0,
                    payoutNumerators: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.outcomeSlotCount),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.payoutNumerators),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.conditionId.clone(),
                    self.oracle.clone(),
                    self.questionId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.conditionId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oracle,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.questionId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ConditionResolution {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ConditionResolution> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ConditionResolution) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `PayoutRedemption(address,address,bytes32,bytes32,uint256[],uint256)` and selector `0x2682012a4a4f1973119f1c9b90745d1bd91fa2bab387344f044cb3586864d18d`.
    ```solidity
    event PayoutRedemption(address indexed redeemer, address indexed collateralToken, bytes32 indexed parentCollectionId, bytes32 conditionId, uint256[] indexSets, uint256 payout);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct PayoutRedemption {
        #[allow(missing_docs)]
        pub redeemer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub collateralToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub indexSets:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        #[allow(missing_docs)]
        pub payout: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PayoutRedemption {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "PayoutRedemption(address,address,bytes32,bytes32,uint256[],uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    38u8, 130u8, 1u8, 42u8, 74u8, 79u8, 25u8, 115u8, 17u8, 159u8, 28u8, 155u8,
                    144u8, 116u8, 93u8, 27u8, 217u8, 31u8, 162u8, 186u8, 179u8, 135u8, 52u8, 79u8,
                    4u8, 76u8, 179u8, 88u8, 104u8, 100u8, 209u8, 141u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    redeemer: topics.1,
                    collateralToken: topics.2,
                    parentCollectionId: topics.3,
                    conditionId: data.0,
                    indexSets: data.1,
                    payout: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.indexSets),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.payout),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.redeemer.clone(),
                    self.collateralToken.clone(),
                    self.parentCollectionId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.redeemer,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.collateralToken,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(
                    &self.parentCollectionId,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PayoutRedemption {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PayoutRedemption> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PayoutRedemption) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `PositionSplit(address,address,bytes32,bytes32,uint256[],uint256)` and selector `0x2e6bb91f8cbcda0c93623c54d0403a43514fabc40084ec96b6d5379a74786298`.
    ```solidity
    event PositionSplit(address indexed stakeholder, address collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint256[] partition, uint256 amount);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct PositionSplit {
        #[allow(missing_docs)]
        pub stakeholder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub collateralToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub partition:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PositionSplit {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "PositionSplit(address,address,bytes32,bytes32,uint256[],uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    46u8, 107u8, 185u8, 31u8, 140u8, 188u8, 218u8, 12u8, 147u8, 98u8, 60u8, 84u8,
                    208u8, 64u8, 58u8, 67u8, 81u8, 79u8, 171u8, 196u8, 0u8, 132u8, 236u8, 150u8,
                    182u8, 213u8, 55u8, 154u8, 116u8, 120u8, 98u8, 152u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakeholder: topics.1,
                    collateralToken: data.0,
                    parentCollectionId: topics.2,
                    conditionId: topics.3,
                    partition: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.partition),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakeholder.clone(),
                    self.parentCollectionId.clone(),
                    self.conditionId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakeholder,
                );
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(
                    &self.parentCollectionId,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.conditionId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PositionSplit {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PositionSplit> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PositionSplit) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `PositionsMerge(address,address,bytes32,bytes32,uint256[],uint256)` and selector `0x6f13ca62553fcc2bcd2372180a43949c1e4cebba603901ede2f4e14f36b282ca`.
    ```solidity
    event PositionsMerge(address indexed stakeholder, address collateralToken, bytes32 indexed parentCollectionId, bytes32 indexed conditionId, uint256[] partition, uint256 amount);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct PositionsMerge {
        #[allow(missing_docs)]
        pub stakeholder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub collateralToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub partition:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PositionsMerge {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str =
                "PositionsMerge(address,address,bytes32,bytes32,uint256[],uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    111u8, 19u8, 202u8, 98u8, 85u8, 63u8, 204u8, 43u8, 205u8, 35u8, 114u8, 24u8,
                    10u8, 67u8, 148u8, 156u8, 30u8, 76u8, 235u8, 186u8, 96u8, 57u8, 1u8, 237u8,
                    226u8, 244u8, 225u8, 79u8, 54u8, 178u8, 130u8, 202u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    stakeholder: topics.1,
                    collateralToken: data.0,
                    parentCollectionId: topics.2,
                    conditionId: topics.3,
                    partition: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.partition),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.stakeholder.clone(),
                    self.parentCollectionId.clone(),
                    self.conditionId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.stakeholder,
                );
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(
                    &self.parentCollectionId,
                );
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.conditionId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PositionsMerge {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PositionsMerge> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PositionsMerge) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TransferBatch(address,address,address,uint256[],uint256[])` and selector `0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb`.
    ```solidity
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct TransferBatch {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ids:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        #[allow(missing_docs)]
        pub values:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TransferBatch {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str =
                "TransferBatch(address,address,address,uint256[],uint256[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    74u8, 57u8, 220u8, 6u8, 212u8, 192u8, 219u8, 198u8, 75u8, 112u8, 175u8, 144u8,
                    253u8, 105u8, 138u8, 35u8, 58u8, 81u8, 138u8, 165u8, 208u8, 126u8, 89u8, 93u8,
                    152u8, 59u8, 140u8, 5u8, 38u8, 200u8, 247u8, 251u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    from: topics.2,
                    to: topics.3,
                    ids: data.0,
                    values: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.ids),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.from.clone(),
                    self.to.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TransferBatch {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TransferBatch> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TransferBatch) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `TransferSingle(address,address,address,uint256,uint256)` and selector `0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62`.
    ```solidity
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct TransferSingle {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TransferSingle {
            type DataTuple<'a> =
                (alloy::sol_types::sol_data::Uint<256>, alloy::sol_types::sol_data::Uint<256>);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str =
                "TransferSingle(address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    195u8, 213u8, 129u8, 104u8, 197u8, 174u8, 115u8, 151u8, 115u8, 29u8, 6u8, 61u8,
                    91u8, 191u8, 61u8, 101u8, 120u8, 84u8, 66u8, 115u8, 67u8, 244u8, 192u8, 131u8,
                    36u8, 15u8, 122u8, 172u8, 170u8, 45u8, 15u8, 98u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { operator: topics.1, from: topics.2, to: topics.3, id: data.0, value: data.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.from.clone(),
                    self.to.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TransferSingle {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TransferSingle> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TransferSingle) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `URI(string,uint256)` and selector `0x6bb7ff708619ba0610cba295a58592e0451dee2622938c8755667688daf3529b`.
    ```solidity
    event URI(string value, uint256 indexed id);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    #[derive(Clone)]
    pub struct URI {
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for URI {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList =
                (alloy_sol_types::sol_data::FixedBytes<32>, alloy::sol_types::sol_data::Uint<256>);
            const SIGNATURE: &'static str = "URI(string,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    107u8, 183u8, 255u8, 112u8, 134u8, 25u8, 186u8, 6u8, 16u8, 203u8, 162u8, 149u8,
                    165u8, 133u8, 146u8, 224u8, 69u8, 29u8, 238u8, 38u8, 34u8, 147u8, 140u8, 135u8,
                    85u8, 102u8, 118u8, 136u8, 218u8, 243u8, 82u8, 155u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { value: data.0, id: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(alloy_sol_types::Error::invalid_event_signature_hash(
                        Self::SIGNATURE,
                        topics.0,
                        Self::SIGNATURE_HASH,
                    ));
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.value,
                ),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for URI {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&URI> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &URI) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
    ```solidity
    constructor(string uri_);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub uri_: alloy::sol_types::private::String,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.uri_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { uri_: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                    &self.uri_,
                ),)
            }
        }
    };
    /**Function with signature `balanceOf(address,uint256)` and selector `0x00fdd58e`.
    ```solidity
    function balanceOf(address account, uint256 id) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfCall {
        pub account: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`balanceOf(address,uint256)`](balanceOfCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfCall) -> Self {
                    (value.account, value.id)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0, id: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOf(address,uint256)";
            const SELECTOR: [u8; 4] = [0u8, 253u8, 213u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `balanceOfBatch(address[],uint256[])` and selector `0x4e1273f4`.
    ```solidity
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) external view returns (uint256[] memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfBatchCall {
        pub accounts: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
        pub ids:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`balanceOfBatch(address[],uint256[])`](balanceOfBatchCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct balanceOfBatchReturn {
        pub _0:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfBatchCall> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfBatchCall) -> Self {
                    (value.accounts, value.ids)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfBatchCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { accounts: tuple.0, ids: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<balanceOfBatchReturn> for UnderlyingRustTuple<'_> {
                fn from(value: balanceOfBatchReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for balanceOfBatchReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for balanceOfBatchCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = balanceOfBatchReturn;
            type ReturnTuple<'a> =
                (alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "balanceOfBatch(address[],uint256[])";
            const SELECTOR: [u8; 4] = [78u8, 18u8, 115u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.accounts),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.ids),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getCollectionId(bytes32,bytes32,uint256)` and selector `0x856296f7`.
    ```solidity
    function getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet) external view returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCollectionIdCall {
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        pub indexSet: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getCollectionId(bytes32,bytes32,uint256)`](getCollectionIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCollectionIdReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCollectionIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCollectionIdCall) -> Self {
                    (value.parentCollectionId, value.conditionId, value.indexSet)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCollectionIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { parentCollectionId: tuple.0, conditionId: tuple.1, indexSet: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCollectionIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getCollectionIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCollectionIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCollectionIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCollectionIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCollectionId(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [133u8, 98u8, 150u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentCollectionId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.indexSet),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getConditionId(address,bytes32,uint256)` and selector `0x852c6ae2`.
    ```solidity
    function getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external pure returns (bytes32);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConditionIdCall {
        pub oracle: alloy::sol_types::private::Address,
        pub questionId: alloy::sol_types::private::FixedBytes<32>,
        pub outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getConditionId(address,bytes32,uint256)`](getConditionIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConditionIdReturn {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConditionIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getConditionIdCall) -> Self {
                    (value.oracle, value.questionId, value.outcomeSlotCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConditionIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { oracle: tuple.0, questionId: tuple.1, outcomeSlotCount: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConditionIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getConditionIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConditionIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getConditionIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getConditionIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getConditionId(address,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [133u8, 44u8, 106u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oracle,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.questionId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.outcomeSlotCount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getOutcomeSlotCount(bytes32)` and selector `0xd42dc0c2`.
    ```solidity
    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOutcomeSlotCountCall {
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getOutcomeSlotCount(bytes32)`](getOutcomeSlotCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOutcomeSlotCountReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOutcomeSlotCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOutcomeSlotCountCall) -> Self {
                    (value.conditionId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOutcomeSlotCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { conditionId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOutcomeSlotCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOutcomeSlotCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOutcomeSlotCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOutcomeSlotCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOutcomeSlotCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOutcomeSlotCount(bytes32)";
            const SELECTOR: [u8; 4] = [212u8, 45u8, 192u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `getPositionId(address,bytes32)` and selector `0x39dd7530`.
    ```solidity
    function getPositionId(address collateralToken, bytes32 collectionId) external pure returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPositionIdCall {
        pub collateralToken: alloy::sol_types::private::Address,
        pub collectionId: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getPositionId(address,bytes32)`](getPositionIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPositionIdReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::FixedBytes<32>);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getPositionIdCall) -> Self {
                    (value.collateralToken, value.collectionId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPositionIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { collateralToken: tuple.0, collectionId: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPositionIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getPositionIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getPositionIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPositionIdCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::FixedBytes<32>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPositionIdReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPositionId(address,bytes32)";
            const SELECTOR: [u8; 4] = [57u8, 221u8, 117u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.collectionId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `isApprovedForAll(address,address)` and selector `0xe985e9c5`.
    ```solidity
    function isApprovedForAll(address account, address operator) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllCall {
        pub account: alloy::sol_types::private::Address,
        pub operator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isApprovedForAll(address,address)`](isApprovedForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isApprovedForAllReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (alloy::sol_types::private::Address, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllCall> for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllCall) -> Self {
                    (value.account, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isApprovedForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0, operator: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isApprovedForAllReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isApprovedForAllReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isApprovedForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isApprovedForAllCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Address);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isApprovedForAllReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isApprovedForAll(address,address)";
            const SELECTOR: [u8; 4] = [233u8, 133u8, 233u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `mergePositions(address,bytes32,bytes32,uint256[],uint256)` and selector `0x9e7212ad`.
    ```solidity
    function mergePositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory partition, uint256 amount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mergePositionsCall {
        pub collateralToken: alloy::sol_types::private::Address,
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        pub partition:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`mergePositions(address,bytes32,bytes32,uint256[],uint256)`](mergePositionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct mergePositionsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mergePositionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: mergePositionsCall) -> Self {
                    (
                        value.collateralToken,
                        value.parentCollectionId,
                        value.conditionId,
                        value.partition,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mergePositionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        collateralToken: tuple.0,
                        parentCollectionId: tuple.1,
                        conditionId: tuple.2,
                        partition: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<mergePositionsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: mergePositionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for mergePositionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for mergePositionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = mergePositionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "mergePositions(address,bytes32,bytes32,uint256[],uint256)";
            const SELECTOR: [u8; 4] = [158u8, 114u8, 18u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentCollectionId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.partition),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `payoutDenominator(bytes32)` and selector `0xdd34de67`.
    ```solidity
    function payoutDenominator(bytes32) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct payoutDenominatorCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`payoutDenominator(bytes32)`](payoutDenominatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct payoutDenominatorReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<payoutDenominatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: payoutDenominatorCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for payoutDenominatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<payoutDenominatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: payoutDenominatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for payoutDenominatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for payoutDenominatorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = payoutDenominatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "payoutDenominator(bytes32)";
            const SELECTOR: [u8; 4] = [221u8, 52u8, 222u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `payoutNumerators(bytes32,uint256)` and selector `0x0504c814`.
    ```solidity
    function payoutNumerators(bytes32, uint256) external view returns (uint256);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct payoutNumeratorsCall {
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`payoutNumerators(bytes32,uint256)`](payoutNumeratorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct payoutNumeratorsReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::FixedBytes<32>, alloy::sol_types::sol_data::Uint<256>);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<payoutNumeratorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: payoutNumeratorsCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for payoutNumeratorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<payoutNumeratorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: payoutNumeratorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for payoutNumeratorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for payoutNumeratorsCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::FixedBytes<32>, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = payoutNumeratorsReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "payoutNumerators(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [5u8, 4u8, 200u8, 20u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `prepareCondition(address,bytes32,uint256)` and selector `0xd96ee754`.
    ```solidity
    function prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct prepareConditionCall {
        pub oracle: alloy::sol_types::private::Address,
        pub questionId: alloy::sol_types::private::FixedBytes<32>,
        pub outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`prepareCondition(address,bytes32,uint256)`](prepareConditionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct prepareConditionReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<prepareConditionCall> for UnderlyingRustTuple<'_> {
                fn from(value: prepareConditionCall) -> Self {
                    (value.oracle, value.questionId, value.outcomeSlotCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for prepareConditionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { oracle: tuple.0, questionId: tuple.1, outcomeSlotCount: tuple.2 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<prepareConditionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: prepareConditionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for prepareConditionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for prepareConditionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = prepareConditionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "prepareCondition(address,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [217u8, 110u8, 231u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oracle,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.questionId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.outcomeSlotCount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `redeemPositions(address,bytes32,bytes32,uint256[])` and selector `0x01b7037c`.
    ```solidity
    function redeemPositions(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory indexSets) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct redeemPositionsCall {
        pub collateralToken: alloy::sol_types::private::Address,
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        pub indexSets:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`redeemPositions(address,bytes32,bytes32,uint256[])`](redeemPositionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct redeemPositionsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<redeemPositionsCall> for UnderlyingRustTuple<'_> {
                fn from(value: redeemPositionsCall) -> Self {
                    (
                        value.collateralToken,
                        value.parentCollectionId,
                        value.conditionId,
                        value.indexSets,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for redeemPositionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        collateralToken: tuple.0,
                        parentCollectionId: tuple.1,
                        conditionId: tuple.2,
                        indexSets: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<redeemPositionsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: redeemPositionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for redeemPositionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for redeemPositionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = redeemPositionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "redeemPositions(address,bytes32,bytes32,uint256[])";
            const SELECTOR: [u8; 4] = [1u8, 183u8, 3u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentCollectionId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.indexSets),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `reportPayouts(bytes32,uint256[])` and selector `0xc49298ac`.
    ```solidity
    function reportPayouts(bytes32 questionId, uint256[] memory payouts) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reportPayoutsCall {
        pub questionId: alloy::sol_types::private::FixedBytes<32>,
        pub payouts:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
    }
    ///Container type for the return parameters of the [`reportPayouts(bytes32,uint256[])`](reportPayoutsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct reportPayoutsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reportPayoutsCall> for UnderlyingRustTuple<'_> {
                fn from(value: reportPayoutsCall) -> Self {
                    (value.questionId, value.payouts)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reportPayoutsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { questionId: tuple.0, payouts: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<reportPayoutsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: reportPayoutsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for reportPayoutsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for reportPayoutsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = reportPayoutsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "reportPayouts(bytes32,uint256[])";
            const SELECTOR: [u8; 4] = [196u8, 146u8, 152u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.questionId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.payouts),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)` and selector `0x2eb2c2d6`.
    ```solidity
    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeBatchTransferFromCall {
        pub from: alloy::sol_types::private::Address,
        pub to: alloy::sol_types::private::Address,
        pub ids:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub values:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)`](safeBatchTransferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeBatchTransferFromReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeBatchTransferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: safeBatchTransferFromCall) -> Self {
                    (value.from, value.to, value.ids, value.values, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeBatchTransferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        from: tuple.0,
                        to: tuple.1,
                        ids: tuple.2,
                        values: tuple.3,
                        data: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeBatchTransferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: safeBatchTransferFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeBatchTransferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeBatchTransferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeBatchTransferFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)";
            const SELECTOR: [u8; 4] = [46u8, 178u8, 194u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.ids),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.values),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `safeTransferFrom(address,address,uint256,uint256,bytes)` and selector `0xf242432a`.
    ```solidity
    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFromCall {
        pub from: alloy::sol_types::private::Address,
        pub to: alloy::sol_types::private::Address,
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`safeTransferFrom(address,address,uint256,uint256,bytes)`](safeTransferFromCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct safeTransferFromReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFromCall> for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFromCall) -> Self {
                    (value.from, value.to, value.id, value.value, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFromCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { from: tuple.0, to: tuple.1, id: tuple.2, value: tuple.3, data: tuple.4 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<safeTransferFromReturn> for UnderlyingRustTuple<'_> {
                fn from(value: safeTransferFromReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for safeTransferFromReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for safeTransferFromCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = safeTransferFromReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "safeTransferFrom(address,address,uint256,uint256,bytes)";
            const SELECTOR: [u8; 4] = [242u8, 66u8, 67u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.from,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.id,
                    ),
                    <alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `setApprovalForAll(address,bool)` and selector `0xa22cb465`.
    ```solidity
    function setApprovalForAll(address operator, bool approved) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllCall {
        pub operator: alloy::sol_types::private::Address,
        pub approved: bool,
    }
    ///Container type for the return parameters of the [`setApprovalForAll(address,bool)`](setApprovalForAllCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setApprovalForAllReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Bool);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllCall> for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllCall) -> Self {
                    (value.operator, value.approved)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setApprovalForAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0, approved: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setApprovalForAllReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setApprovalForAllReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setApprovalForAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setApprovalForAllCall {
            type Parameters<'a> =
                (alloy::sol_types::sol_data::Address, alloy::sol_types::sol_data::Bool);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setApprovalForAllReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setApprovalForAll(address,bool)";
            const SELECTOR: [u8; 4] = [162u8, 44u8, 180u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.approved,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `splitPosition(address,bytes32,bytes32,uint256[],uint256)` and selector `0x72ce4275`.
    ```solidity
    function splitPosition(address collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] memory partition, uint256 amount) external;
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitPositionCall {
        pub collateralToken: alloy::sol_types::private::Address,
        pub parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
        pub conditionId: alloy::sol_types::private::FixedBytes<32>,
        pub partition:
            alloy::sol_types::private::Vec<alloy::sol_types::private::primitives::aliases::U256>,
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`splitPosition(address,bytes32,bytes32,uint256[],uint256)`](splitPositionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct splitPositionReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitPositionCall> for UnderlyingRustTuple<'_> {
                fn from(value: splitPositionCall) -> Self {
                    (
                        value.collateralToken,
                        value.parentCollectionId,
                        value.conditionId,
                        value.partition,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitPositionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        collateralToken: tuple.0,
                        parentCollectionId: tuple.1,
                        conditionId: tuple.2,
                        partition: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<splitPositionReturn> for UnderlyingRustTuple<'_> {
                fn from(value: splitPositionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for splitPositionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for splitPositionCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = splitPositionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "splitPosition(address,bytes32,bytes32,uint256[],uint256)";
            const SELECTOR: [u8; 4] = [114u8, 206u8, 66u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.collateralToken,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentCollectionId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.conditionId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.partition),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
    ```solidity
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall> for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::FixedBytes<4> as alloy_sol_types::SolType>::tokenize(
                    &self.interfaceId,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    /**Function with signature `uri(uint256)` and selector `0x0e89341c`.
    ```solidity
    function uri(uint256) external view returns (string memory);
    ```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uriCall {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`uri(uint256)`](uriCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct uriReturn {
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields, clippy::style)]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::primitives::aliases::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uriCall> for UnderlyingRustTuple<'_> {
                fn from(value: uriCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for uriCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<uriReturn> for UnderlyingRustTuple<'_> {
                fn from(value: uriReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for uriReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for uriCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = uriReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "uri(uint256)";
            const SELECTOR: [u8; 4] = [14u8, 137u8, 52u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<alloy::sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                    &self._0,
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    ///Container for all the [`ConditionalTokens`](self) function calls.
    pub enum ConditionalTokensCalls {
        balanceOf(balanceOfCall),
        balanceOfBatch(balanceOfBatchCall),
        getCollectionId(getCollectionIdCall),
        getConditionId(getConditionIdCall),
        getOutcomeSlotCount(getOutcomeSlotCountCall),
        getPositionId(getPositionIdCall),
        isApprovedForAll(isApprovedForAllCall),
        mergePositions(mergePositionsCall),
        payoutDenominator(payoutDenominatorCall),
        payoutNumerators(payoutNumeratorsCall),
        prepareCondition(prepareConditionCall),
        redeemPositions(redeemPositionsCall),
        reportPayouts(reportPayoutsCall),
        safeBatchTransferFrom(safeBatchTransferFromCall),
        safeTransferFrom(safeTransferFromCall),
        setApprovalForAll(setApprovalForAllCall),
        splitPosition(splitPositionCall),
        supportsInterface(supportsInterfaceCall),
        uri(uriCall),
    }
    #[automatically_derived]
    impl ConditionalTokensCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 253u8, 213u8, 142u8],
            [1u8, 183u8, 3u8, 124u8],
            [1u8, 255u8, 201u8, 167u8],
            [5u8, 4u8, 200u8, 20u8],
            [14u8, 137u8, 52u8, 28u8],
            [46u8, 178u8, 194u8, 214u8],
            [57u8, 221u8, 117u8, 48u8],
            [78u8, 18u8, 115u8, 244u8],
            [114u8, 206u8, 66u8, 117u8],
            [133u8, 44u8, 106u8, 226u8],
            [133u8, 98u8, 150u8, 247u8],
            [158u8, 114u8, 18u8, 173u8],
            [162u8, 44u8, 180u8, 101u8],
            [196u8, 146u8, 152u8, 172u8],
            [212u8, 45u8, 192u8, 194u8],
            [217u8, 110u8, 231u8, 84u8],
            [221u8, 52u8, 222u8, 103u8],
            [233u8, 133u8, 233u8, 197u8],
            [242u8, 66u8, 67u8, 42u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ConditionalTokensCalls {
        const NAME: &'static str = "ConditionalTokensCalls";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 19usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::balanceOf(_) => <balanceOfCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::balanceOfBatch(_) => {
                    <balanceOfBatchCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCollectionId(_) => {
                    <getCollectionIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getConditionId(_) => {
                    <getConditionIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOutcomeSlotCount(_) => {
                    <getOutcomeSlotCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPositionId(_) => <getPositionIdCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isApprovedForAll(_) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::mergePositions(_) => {
                    <mergePositionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::payoutDenominator(_) => {
                    <payoutDenominatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::payoutNumerators(_) => {
                    <payoutNumeratorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::prepareCondition(_) => {
                    <prepareConditionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::redeemPositions(_) => {
                    <redeemPositionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::reportPayouts(_) => <reportPayoutsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::safeBatchTransferFrom(_) => {
                    <safeBatchTransferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::safeTransferFrom(_) => {
                    <safeTransferFromCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setApprovalForAll(_) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::splitPosition(_) => <splitPositionCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::uri(_) => <uriCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<ConditionalTokensCalls>] = &[
                {
                    fn balanceOf(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <balanceOfCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(ConditionalTokensCalls::balanceOf)
                    }
                    balanceOf
                },
                {
                    fn redeemPositions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <redeemPositionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::redeemPositions)
                    }
                    redeemPositions
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn payoutNumerators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <payoutNumeratorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::payoutNumerators)
                    }
                    payoutNumerators
                },
                {
                    fn uri(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <uriCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(ConditionalTokensCalls::uri)
                    }
                    uri
                },
                {
                    fn safeBatchTransferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <safeBatchTransferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::safeBatchTransferFrom)
                    }
                    safeBatchTransferFrom
                },
                {
                    fn getPositionId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <getPositionIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::getPositionId)
                    }
                    getPositionId
                },
                {
                    fn balanceOfBatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <balanceOfBatchCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::balanceOfBatch)
                    }
                    balanceOfBatch
                },
                {
                    fn splitPosition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <splitPositionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::splitPosition)
                    }
                    splitPosition
                },
                {
                    fn getConditionId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <getConditionIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::getConditionId)
                    }
                    getConditionId
                },
                {
                    fn getCollectionId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <getCollectionIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::getCollectionId)
                    }
                    getCollectionId
                },
                {
                    fn mergePositions(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <mergePositionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::mergePositions)
                    }
                    mergePositions
                },
                {
                    fn setApprovalForAll(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::setApprovalForAll)
                    }
                    setApprovalForAll
                },
                {
                    fn reportPayouts(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <reportPayoutsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::reportPayouts)
                    }
                    reportPayouts
                },
                {
                    fn getOutcomeSlotCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <getOutcomeSlotCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::getOutcomeSlotCount)
                    }
                    getOutcomeSlotCount
                },
                {
                    fn prepareCondition(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <prepareConditionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::prepareCondition)
                    }
                    prepareCondition
                },
                {
                    fn payoutDenominator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <payoutDenominatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::payoutDenominator)
                    }
                    payoutDenominator
                },
                {
                    fn isApprovedForAll(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::isApprovedForAll)
                    }
                    isApprovedForAll
                },
                {
                    fn safeTransferFrom(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensCalls> {
                        <safeTransferFromCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensCalls::safeTransferFrom)
                    }
                    safeTransferFrom
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::balanceOfBatch(inner) => {
                    <balanceOfBatchCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getCollectionId(inner) => {
                    <getCollectionIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getConditionId(inner) => {
                    <getConditionIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getOutcomeSlotCount(inner) => {
                    <getOutcomeSlotCountCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getPositionId(inner) => {
                    <getPositionIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::mergePositions(inner) => {
                    <mergePositionsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::payoutDenominator(inner) => {
                    <payoutDenominatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::payoutNumerators(inner) => {
                    <payoutNumeratorsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::prepareCondition(inner) => {
                    <prepareConditionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::redeemPositions(inner) => {
                    <redeemPositionsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::reportPayouts(inner) => {
                    <reportPayoutsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::safeBatchTransferFrom(inner) => {
                    <safeBatchTransferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::safeTransferFrom(inner) => {
                    <safeTransferFromCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::splitPosition(inner) => {
                    <splitPositionCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::uri(inner) => <uriCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::balanceOf(inner) => {
                    <balanceOfCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::balanceOfBatch(inner) => {
                    <balanceOfBatchCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getCollectionId(inner) => {
                    <getCollectionIdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getConditionId(inner) => {
                    <getConditionIdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getOutcomeSlotCount(inner) => {
                    <getOutcomeSlotCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::getPositionId(inner) => {
                    <getPositionIdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isApprovedForAll(inner) => {
                    <isApprovedForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::mergePositions(inner) => {
                    <mergePositionsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::payoutDenominator(inner) => {
                    <payoutDenominatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::payoutNumerators(inner) => {
                    <payoutNumeratorsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::prepareCondition(inner) => {
                    <prepareConditionCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::redeemPositions(inner) => {
                    <redeemPositionsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::reportPayouts(inner) => {
                    <reportPayoutsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::safeBatchTransferFrom(inner) => {
                    <safeBatchTransferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::safeTransferFrom(inner) => {
                    <safeTransferFromCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setApprovalForAll(inner) => {
                    <setApprovalForAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::splitPosition(inner) => {
                    <splitPositionCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::uri(inner) => {
                    <uriCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`ConditionalTokens`](self) custom errors.
    pub enum ConditionalTokensErrors {
        ERC1155InsufficientBalance(ERC1155InsufficientBalance),
        ERC1155InvalidApprover(ERC1155InvalidApprover),
        ERC1155InvalidArrayLength(ERC1155InvalidArrayLength),
        ERC1155InvalidOperator(ERC1155InvalidOperator),
        ERC1155InvalidReceiver(ERC1155InvalidReceiver),
        ERC1155InvalidSender(ERC1155InvalidSender),
        ERC1155MissingApprovalForAll(ERC1155MissingApprovalForAll),
    }
    #[automatically_derived]
    impl ConditionalTokensErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 168u8, 53u8, 20u8],
            [3u8, 222u8, 228u8, 197u8],
            [62u8, 49u8, 136u8, 78u8],
            [87u8, 244u8, 71u8, 206u8],
            [91u8, 5u8, 153u8, 145u8],
            [206u8, 211u8, 225u8, 0u8],
            [226u8, 55u8, 217u8, 34u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ConditionalTokensErrors {
        const NAME: &'static str = "ConditionalTokensErrors";
        const MIN_DATA_LENGTH: usize = 32usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ERC1155InsufficientBalance(_) => {
                    <ERC1155InsufficientBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155InvalidApprover(_) => {
                    <ERC1155InvalidApprover as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155InvalidArrayLength(_) => {
                    <ERC1155InvalidArrayLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155InvalidOperator(_) => {
                    <ERC1155InvalidOperator as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155InvalidReceiver(_) => {
                    <ERC1155InvalidReceiver as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155InvalidSender(_) => {
                    <ERC1155InvalidSender as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1155MissingApprovalForAll(_) => {
                    <ERC1155MissingApprovalForAll as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<ConditionalTokensErrors>] = &[
                {
                    fn ERC1155InvalidSender(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InvalidSender as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InvalidSender)
                    }
                    ERC1155InvalidSender
                },
                {
                    fn ERC1155InsufficientBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InsufficientBalance as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InsufficientBalance)
                    }
                    ERC1155InsufficientBalance
                },
                {
                    fn ERC1155InvalidApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InvalidApprover as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InvalidApprover)
                    }
                    ERC1155InvalidApprover
                },
                {
                    fn ERC1155InvalidReceiver(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InvalidReceiver as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InvalidReceiver)
                    }
                    ERC1155InvalidReceiver
                },
                {
                    fn ERC1155InvalidArrayLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InvalidArrayLength as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InvalidArrayLength)
                    }
                    ERC1155InvalidArrayLength
                },
                {
                    fn ERC1155InvalidOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155InvalidOperator as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155InvalidOperator)
                    }
                    ERC1155InvalidOperator
                },
                {
                    fn ERC1155MissingApprovalForAll(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ConditionalTokensErrors> {
                        <ERC1155MissingApprovalForAll as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ConditionalTokensErrors::ERC1155MissingApprovalForAll)
                    }
                    ERC1155MissingApprovalForAll
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ERC1155InsufficientBalance(inner) => {
                    <ERC1155InsufficientBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1155InvalidApprover(inner) => {
                    <ERC1155InvalidApprover as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ERC1155InvalidArrayLength(inner) => {
                    <ERC1155InvalidArrayLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1155InvalidOperator(inner) => {
                    <ERC1155InvalidOperator as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ERC1155InvalidReceiver(inner) => {
                    <ERC1155InvalidReceiver as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ERC1155InvalidSender(inner) => {
                    <ERC1155InvalidSender as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ERC1155MissingApprovalForAll(inner) => {
                    <ERC1155MissingApprovalForAll as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ERC1155InsufficientBalance(inner) => {
                    <ERC1155InsufficientBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::ERC1155InvalidApprover(inner) => {
                    <ERC1155InvalidApprover as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::ERC1155InvalidArrayLength(inner) => {
                    <ERC1155InvalidArrayLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::ERC1155InvalidOperator(inner) => {
                    <ERC1155InvalidOperator as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::ERC1155InvalidReceiver(inner) => {
                    <ERC1155InvalidReceiver as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::ERC1155InvalidSender(inner) => {
                    <ERC1155InvalidSender as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::ERC1155MissingApprovalForAll(inner) => {
                    <ERC1155MissingApprovalForAll as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
            }
        }
    }
    ///Container for all the [`ConditionalTokens`](self) events.
    pub enum ConditionalTokensEvents {
        ApprovalForAll(ApprovalForAll),
        ConditionPreparation(ConditionPreparation),
        ConditionResolution(ConditionResolution),
        PayoutRedemption(PayoutRedemption),
        PositionSplit(PositionSplit),
        PositionsMerge(PositionsMerge),
        TransferBatch(TransferBatch),
        TransferSingle(TransferSingle),
        URI(URI),
    }
    #[automatically_derived]
    impl ConditionalTokensEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                23u8, 48u8, 126u8, 171u8, 57u8, 171u8, 97u8, 7u8, 232u8, 137u8, 152u8, 69u8, 173u8,
                61u8, 89u8, 189u8, 150u8, 83u8, 242u8, 0u8, 242u8, 32u8, 146u8, 4u8, 137u8, 202u8,
                43u8, 89u8, 55u8, 105u8, 108u8, 49u8,
            ],
            [
                38u8, 130u8, 1u8, 42u8, 74u8, 79u8, 25u8, 115u8, 17u8, 159u8, 28u8, 155u8, 144u8,
                116u8, 93u8, 27u8, 217u8, 31u8, 162u8, 186u8, 179u8, 135u8, 52u8, 79u8, 4u8, 76u8,
                179u8, 88u8, 104u8, 100u8, 209u8, 141u8,
            ],
            [
                46u8, 107u8, 185u8, 31u8, 140u8, 188u8, 218u8, 12u8, 147u8, 98u8, 60u8, 84u8,
                208u8, 64u8, 58u8, 67u8, 81u8, 79u8, 171u8, 196u8, 0u8, 132u8, 236u8, 150u8, 182u8,
                213u8, 55u8, 154u8, 116u8, 120u8, 98u8, 152u8,
            ],
            [
                74u8, 57u8, 220u8, 6u8, 212u8, 192u8, 219u8, 198u8, 75u8, 112u8, 175u8, 144u8,
                253u8, 105u8, 138u8, 35u8, 58u8, 81u8, 138u8, 165u8, 208u8, 126u8, 89u8, 93u8,
                152u8, 59u8, 140u8, 5u8, 38u8, 200u8, 247u8, 251u8,
            ],
            [
                107u8, 183u8, 255u8, 112u8, 134u8, 25u8, 186u8, 6u8, 16u8, 203u8, 162u8, 149u8,
                165u8, 133u8, 146u8, 224u8, 69u8, 29u8, 238u8, 38u8, 34u8, 147u8, 140u8, 135u8,
                85u8, 102u8, 118u8, 136u8, 218u8, 243u8, 82u8, 155u8,
            ],
            [
                111u8, 19u8, 202u8, 98u8, 85u8, 63u8, 204u8, 43u8, 205u8, 35u8, 114u8, 24u8, 10u8,
                67u8, 148u8, 156u8, 30u8, 76u8, 235u8, 186u8, 96u8, 57u8, 1u8, 237u8, 226u8, 244u8,
                225u8, 79u8, 54u8, 178u8, 130u8, 202u8,
            ],
            [
                171u8, 55u8, 96u8, 195u8, 189u8, 43u8, 179u8, 139u8, 91u8, 207u8, 84u8, 220u8,
                121u8, 128u8, 46u8, 214u8, 115u8, 56u8, 180u8, 207u8, 41u8, 243u8, 5u8, 77u8,
                237u8, 103u8, 237u8, 36u8, 102u8, 30u8, 65u8, 119u8,
            ],
            [
                180u8, 77u8, 132u8, 211u8, 40u8, 150u8, 145u8, 247u8, 20u8, 151u8, 86u8, 75u8,
                133u8, 212u8, 35u8, 54u8, 72u8, 217u8, 219u8, 174u8, 140u8, 189u8, 187u8, 67u8,
                41u8, 243u8, 1u8, 195u8, 160u8, 24u8, 88u8, 148u8,
            ],
            [
                195u8, 213u8, 129u8, 104u8, 197u8, 174u8, 115u8, 151u8, 115u8, 29u8, 6u8, 61u8,
                91u8, 191u8, 61u8, 101u8, 120u8, 84u8, 66u8, 115u8, 67u8, 244u8, 192u8, 131u8,
                36u8, 15u8, 122u8, 172u8, 170u8, 45u8, 15u8, 98u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ConditionalTokensEvents {
        const NAME: &'static str = "ConditionalTokensEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<ApprovalForAll as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ApprovalForAll as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ApprovalForAll)
                }
                Some(<ConditionPreparation as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ConditionPreparation as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ConditionPreparation)
                }
                Some(<ConditionResolution as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ConditionResolution as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ConditionResolution)
                }
                Some(<PayoutRedemption as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PayoutRedemption as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PayoutRedemption)
                }
                Some(<PositionSplit as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PositionSplit as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PositionSplit)
                }
                Some(<PositionsMerge as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PositionsMerge as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PositionsMerge)
                }
                Some(<TransferBatch as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TransferBatch as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TransferBatch)
                }
                Some(<TransferSingle as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TransferSingle as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TransferSingle)
                }
                Some(<URI as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <URI as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::URI)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ConditionalTokensEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ConditionPreparation(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ConditionResolution(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PayoutRedemption(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PositionSplit(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PositionsMerge(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TransferBatch(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TransferSingle(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::URI(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ApprovalForAll(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ConditionPreparation(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ConditionResolution(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PayoutRedemption(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PositionSplit(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PositionsMerge(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TransferBatch(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TransferSingle(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::URI(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`ConditionalTokens`](self) contract instance.

    See the [wrapper's documentation](`ConditionalTokensInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ConditionalTokensInstance<T, P, N> {
        ConditionalTokensInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

    Returns a new instance of the contract, if the deployment was successful.

    For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        uri_: alloy::sol_types::private::String,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<ConditionalTokensInstance<T, P, N>>>
    {
        ConditionalTokensInstance::<T, P, N>::deploy(provider, uri_)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
    and constructor arguments, if any.

    This is a simple wrapper around creating a `RawCallBuilder` with the data set to
    the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        uri_: alloy::sol_types::private::String,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        ConditionalTokensInstance::<T, P, N>::deploy_builder(provider, uri_)
    }
    /**A [`ConditionalTokens`](self) instance.

    Contains type-safe methods for interacting with an on-chain instance of the
    [`ConditionalTokens`](self) contract located at a given `address`, using a given
    provider `P`.

    If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
    documentation on how to provide it), the `deploy` and `deploy_builder` methods can
    be used to deploy a new instance of the contract.

    See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct ConditionalTokensInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ConditionalTokensInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ConditionalTokensInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ConditionalTokensInstance<T, P, N>
    {
        /**Creates a new wrapper around an on-chain [`ConditionalTokens`](self) contract instance.

        See the [wrapper's documentation](`ConditionalTokensInstance`) for more details.*/
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self { address, provider, _network_transport: ::core::marker::PhantomData }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

        Returns a new instance of the contract, if the deployment was successful.

        For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            uri_: alloy::sol_types::private::String,
        ) -> alloy_contract::Result<ConditionalTokensInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, uri_);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
        and constructor arguments, if any.

        This is a simple wrapper around creating a `RawCallBuilder` with the data set to
        the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            uri_: alloy::sol_types::private::String,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall { uri_ })[..],
                ]
                .concat()
                .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ConditionalTokensInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> ConditionalTokensInstance<T, P, N> {
            ConditionalTokensInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ConditionalTokensInstance<T, P, N>
    {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`balanceOf`] function.
        pub fn balanceOf(
            &self,
            account: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfCall, N> {
            self.call_builder(&balanceOfCall { account, id })
        }
        ///Creates a new call builder for the [`balanceOfBatch`] function.
        pub fn balanceOfBatch(
            &self,
            accounts: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            ids: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, balanceOfBatchCall, N> {
            self.call_builder(&balanceOfBatchCall { accounts, ids })
        }
        ///Creates a new call builder for the [`getCollectionId`] function.
        pub fn getCollectionId(
            &self,
            parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
            conditionId: alloy::sol_types::private::FixedBytes<32>,
            indexSet: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCollectionIdCall, N> {
            self.call_builder(&getCollectionIdCall { parentCollectionId, conditionId, indexSet })
        }
        ///Creates a new call builder for the [`getConditionId`] function.
        pub fn getConditionId(
            &self,
            oracle: alloy::sol_types::private::Address,
            questionId: alloy::sol_types::private::FixedBytes<32>,
            outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getConditionIdCall, N> {
            self.call_builder(&getConditionIdCall { oracle, questionId, outcomeSlotCount })
        }
        ///Creates a new call builder for the [`getOutcomeSlotCount`] function.
        pub fn getOutcomeSlotCount(
            &self,
            conditionId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOutcomeSlotCountCall, N> {
            self.call_builder(&getOutcomeSlotCountCall { conditionId })
        }
        ///Creates a new call builder for the [`getPositionId`] function.
        pub fn getPositionId(
            &self,
            collateralToken: alloy::sol_types::private::Address,
            collectionId: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPositionIdCall, N> {
            self.call_builder(&getPositionIdCall { collateralToken, collectionId })
        }
        ///Creates a new call builder for the [`isApprovedForAll`] function.
        pub fn isApprovedForAll(
            &self,
            account: alloy::sol_types::private::Address,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isApprovedForAllCall, N> {
            self.call_builder(&isApprovedForAllCall { account, operator })
        }
        ///Creates a new call builder for the [`mergePositions`] function.
        pub fn mergePositions(
            &self,
            collateralToken: alloy::sol_types::private::Address,
            parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
            conditionId: alloy::sol_types::private::FixedBytes<32>,
            partition: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, mergePositionsCall, N> {
            self.call_builder(&mergePositionsCall {
                collateralToken,
                parentCollectionId,
                conditionId,
                partition,
                amount,
            })
        }
        ///Creates a new call builder for the [`payoutDenominator`] function.
        pub fn payoutDenominator(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, payoutDenominatorCall, N> {
            self.call_builder(&payoutDenominatorCall { _0 })
        }
        ///Creates a new call builder for the [`payoutNumerators`] function.
        pub fn payoutNumerators(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, payoutNumeratorsCall, N> {
            self.call_builder(&payoutNumeratorsCall { _0, _1 })
        }
        ///Creates a new call builder for the [`prepareCondition`] function.
        pub fn prepareCondition(
            &self,
            oracle: alloy::sol_types::private::Address,
            questionId: alloy::sol_types::private::FixedBytes<32>,
            outcomeSlotCount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, prepareConditionCall, N> {
            self.call_builder(&prepareConditionCall { oracle, questionId, outcomeSlotCount })
        }
        ///Creates a new call builder for the [`redeemPositions`] function.
        pub fn redeemPositions(
            &self,
            collateralToken: alloy::sol_types::private::Address,
            parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
            conditionId: alloy::sol_types::private::FixedBytes<32>,
            indexSets: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, redeemPositionsCall, N> {
            self.call_builder(&redeemPositionsCall {
                collateralToken,
                parentCollectionId,
                conditionId,
                indexSets,
            })
        }
        ///Creates a new call builder for the [`reportPayouts`] function.
        pub fn reportPayouts(
            &self,
            questionId: alloy::sol_types::private::FixedBytes<32>,
            payouts: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, reportPayoutsCall, N> {
            self.call_builder(&reportPayoutsCall { questionId, payouts })
        }
        ///Creates a new call builder for the [`safeBatchTransferFrom`] function.
        pub fn safeBatchTransferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            ids: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            values: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, safeBatchTransferFromCall, N> {
            self.call_builder(&safeBatchTransferFromCall { from, to, ids, values, data })
        }
        ///Creates a new call builder for the [`safeTransferFrom`] function.
        pub fn safeTransferFrom(
            &self,
            from: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            id: alloy::sol_types::private::primitives::aliases::U256,
            value: alloy::sol_types::private::primitives::aliases::U256,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, safeTransferFromCall, N> {
            self.call_builder(&safeTransferFromCall { from, to, id, value, data })
        }
        ///Creates a new call builder for the [`setApprovalForAll`] function.
        pub fn setApprovalForAll(
            &self,
            operator: alloy::sol_types::private::Address,
            approved: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setApprovalForAllCall, N> {
            self.call_builder(&setApprovalForAllCall { operator, approved })
        }
        ///Creates a new call builder for the [`splitPosition`] function.
        pub fn splitPosition(
            &self,
            collateralToken: alloy::sol_types::private::Address,
            parentCollectionId: alloy::sol_types::private::FixedBytes<32>,
            conditionId: alloy::sol_types::private::FixedBytes<32>,
            partition: alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, splitPositionCall, N> {
            self.call_builder(&splitPositionCall {
                collateralToken,
                parentCollectionId,
                conditionId,
                partition,
                amount,
            })
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(&supportsInterfaceCall { interfaceId })
        }
        ///Creates a new call builder for the [`uri`] function.
        pub fn uri(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, uriCall, N> {
            self.call_builder(&uriCall { _0 })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ConditionalTokensInstance<T, P, N>
    {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`ApprovalForAll`] event.
        pub fn ApprovalForAll_filter(&self) -> alloy_contract::Event<T, &P, ApprovalForAll, N> {
            self.event_filter::<ApprovalForAll>()
        }
        ///Creates a new event filter for the [`ConditionPreparation`] event.
        pub fn ConditionPreparation_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ConditionPreparation, N> {
            self.event_filter::<ConditionPreparation>()
        }
        ///Creates a new event filter for the [`ConditionResolution`] event.
        pub fn ConditionResolution_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ConditionResolution, N> {
            self.event_filter::<ConditionResolution>()
        }
        ///Creates a new event filter for the [`PayoutRedemption`] event.
        pub fn PayoutRedemption_filter(&self) -> alloy_contract::Event<T, &P, PayoutRedemption, N> {
            self.event_filter::<PayoutRedemption>()
        }
        ///Creates a new event filter for the [`PositionSplit`] event.
        pub fn PositionSplit_filter(&self) -> alloy_contract::Event<T, &P, PositionSplit, N> {
            self.event_filter::<PositionSplit>()
        }
        ///Creates a new event filter for the [`PositionsMerge`] event.
        pub fn PositionsMerge_filter(&self) -> alloy_contract::Event<T, &P, PositionsMerge, N> {
            self.event_filter::<PositionsMerge>()
        }
        ///Creates a new event filter for the [`TransferBatch`] event.
        pub fn TransferBatch_filter(&self) -> alloy_contract::Event<T, &P, TransferBatch, N> {
            self.event_filter::<TransferBatch>()
        }
        ///Creates a new event filter for the [`TransferSingle`] event.
        pub fn TransferSingle_filter(&self) -> alloy_contract::Event<T, &P, TransferSingle, N> {
            self.event_filter::<TransferSingle>()
        }
        ///Creates a new event filter for the [`URI`] event.
        pub fn URI_filter(&self) -> alloy_contract::Event<T, &P, URI, N> {
            self.event_filter::<URI>()
        }
    }
}
